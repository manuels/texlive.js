%--------------------------------------------
%
% Package pgfplots
%
% Provides a user-friendly interface to create function plots (normal
% plots, semi-logplots and double-logplots).
% 
% It is based on Till Tantau's PGF package.
%
% Copyright 2007-2010 by Christian Feuers√§nger.
%
% This program is free software: you can redistribute it and/or modify
% it under the terms of the GNU General Public License as published by
% the Free Software Foundation, either version 3 of the License, or
% (at your option) any later version.
% 
% This program is distributed in the hope that it will be useful,
% but WITHOUT ANY WARRANTY; without even the implied warranty of
% MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
% GNU General Public License for more details.
% 
% You should have received a copy of the GNU General Public License
% along with this program.  If not, see <http://www.gnu.org/licenses/>.
%
%--------------------------------------------

% This file contains the code to process coordinates
% - coordinate input: \addplot and its variants,
% - coordinate loops,
% - single coordinate processing


% To be called inside of an axis as soon as the axis is ready and all
% point commands can be invoked.
\def\pgfplotspoint@initialisation{%
	\expandafter\global\expandafter\let\csname pgfplotspointouternormalvectorofaxis@cache@v00\endcsname\relax
	\expandafter\global\expandafter\let\csname pgfplotspointouternormalvectorofaxis@cache@v01\endcsname\relax
	\expandafter\global\expandafter\let\csname pgfplotspointouternormalvectorofaxis@cache@v10\endcsname\relax
	\expandafter\global\expandafter\let\csname pgfplotspointouternormalvectorofaxis@cache@v11\endcsname\relax
	\expandafter\global\expandafter\let\csname pgfplotspointouternormalvectorofaxis@cache@0v0\endcsname\relax
	\expandafter\global\expandafter\let\csname pgfplotspointouternormalvectorofaxis@cache@0v1\endcsname\relax
	\expandafter\global\expandafter\let\csname pgfplotspointouternormalvectorofaxis@cache@1v0\endcsname\relax
	\expandafter\global\expandafter\let\csname pgfplotspointouternormalvectorofaxis@cache@1v1\endcsname\relax
	\expandafter\global\expandafter\let\csname pgfplotspointouternormalvectorofaxis@cache@00v\endcsname\relax
	\expandafter\global\expandafter\let\csname pgfplotspointouternormalvectorofaxis@cache@01v\endcsname\relax
	\expandafter\global\expandafter\let\csname pgfplotspointouternormalvectorofaxis@cache@10v\endcsname\relax
	\expandafter\global\expandafter\let\csname pgfplotspointouternormalvectorofaxis@cache@11v\endcsname\relax
	%
	% Installs e_x, e_y and e_z such that (0,0) is the 'south west'
	% anchor of the axis and (1,1) the 'north east'.
	% It is used inside of descriptions.
	\def\pgfplots@install@description@xyzvec{%
		% this here is also used in color bars!
		\ifpgfplots@deprecated@anchors
			\pgfpointadd{\pgfplotspointxaxis}{\pgfplotspointyaxis}%
		\else
			\pgfplotspointbbdiagonal
		\fi
		\pgf@xx=\pgf@x
		\pgf@xy=0pt
		\pgf@yx=0pt
		\pgf@yy=\pgf@y
		\pgf@zx=0pt
		\pgf@zy=0pt
	}%
	%
	%
	\edef\pgfplotsplothandlerpointxyz##1##2##3{%
		\ifpgfplots@curplot@threedim
			\noexpand\pgfplotsqpointxyz{##1}{##2}{##3}%
		\else
			\noexpand\pgfplotsqpointxy{##1}{##2}%
		\fi
	}%
	%
	% A point command such that (0,0) is the 'south west' and (1,1)
	% the 'north east' point of an axis.
	\def\pgfplotspointdescriptionxy##1##2{%
		\pgf@process{%
			\pgfplots@install@description@xyzvec
			\pgfpointadd
				{\ifpgfplots@deprecated@anchors
					\pgfplotspointminminmin
				\else
					\pgfplotspointbblowerleft
				\fi}%
				{\pgfpointxy@orig{##1}{##2}}% 
				%I use the '@orig' variant here because descriptions may 
				%\let\pgfpointxy=\pgfplotspointdescriptionxy
		}%
	}%
	% the 'q' variant:
	\def\pgfplotsqpointdescriptionxy##1##2{%
		\pgf@process{%
			\pgfplots@install@description@xyzvec
			\pgfpointadd
				{\ifpgfplots@deprecated@anchors
					\pgfplotspointminminmin
				\else
					\pgfplotspointbblowerleft
				\fi}%
				{\pgfqpointxy@orig{##1}{##2}}% 
		}%
	}%
	\pgfplotspoint@initialisation@axes
	\pgfplotspoint@initialisation@units
	\pgfplotspoint@initialisation@center
	%
	% declare the '[xyz]ticklabel cs'
	\tikzdeclarecoordinatesystem{xticklabel}{\pgfplotspointticklabelcs{x}{##1}}%
	\tikzdeclarecoordinatesystem{yticklabel}{\pgfplotspointticklabelcs{y}{##1}}%
	\tikzdeclarecoordinatesystem{zticklabel}{\pgfplotspointticklabelcs{z}{##1}}%
	%
	% does also declare the 'near xticklabel*' variants.
	\pgfplotsdeclareborderanchorforticklabelaxis{x}{near xticklabel}%
	\pgfplotsdeclareborderanchorforticklabelaxis{y}{near yticklabel}%
	\pgfplotsdeclareborderanchorforticklabelaxis{z}{near zticklabel}%
	%
	\pgfkeysdef{/tikz/sloped like x axis}{\tikz@addtransform{\pgfplotstransformtoaxisdirection[##1]{x}}}%
	\pgfkeysdef{/tikz/sloped like y axis}{\tikz@addtransform{\pgfplotstransformtoaxisdirection[##1]{y}}}%
	\pgfkeysdef{/tikz/sloped like z axis}{\tikz@addtransform{\pgfplotstransformtoaxisdirection[##1]{z}}}%
	%
}%

% Determine final  axes this does also fix the axis' dimension.
% There are the following cases: 
% 1. the user really wants a fixed dimension,
%    i.e. he used 'scale only axis'.
%    Then, we have to work to get the correct dimension!
%
%    Up to now, the scaling mechanism looses to many significant
%    digits such that the final width/height differs by 1-2 pt.
%
%    If I am not mistaken, this does ONLY affect the final size,
%    not the relative plot precision.
%    
%    FIXME : really compute the plot precision!
% 
% 2. The use specified width and/or height, but not 'scale only
%    axis'. Accept inaccurate final widths/heights (see above).
%
% 3. The user supplied 'x' and or 'y'. Simply use them, its
% accurate.
% POSTCONDITION: the macros
% 	\pgfplotspointminminmin
% 	\pgfplotspoint[xyz]axis
% 	\pgfplotspoint[xyz]axislength
%   are defined (globally).
%
\def\pgfplotspoint@initialisation@axes{%
	\begingroup
	\ifpgfplots@threedim
		\def\pgfplotspointmaxminmin{\pgfplotsqpointxyz{\pgfplots@xmax}{\pgfplots@ymin}{\pgfplots@zmin}}%
		\def\pgfplotspointminmaxmin{\pgfplotsqpointxyz{\pgfplots@xmin}{\pgfplots@ymax}{\pgfplots@zmin}}%
		\pgfplotsqpointxyz{\pgfplots@xmin}{\pgfplots@ymin}{\pgfplots@zmin}%
	\else
		\def\pgfplotspointmaxminmin{\pgfplotsqpointxy{\pgfplots@xmax}{\pgfplots@ymin}}%
		\def\pgfplotspointminmaxmin{\pgfplotsqpointxy{\pgfplots@xmin}{\pgfplots@ymax}}%
		\pgfplotsqpointxy{\pgfplots@xmin}{\pgfplots@ymin}%
	\fi
	\xdef\pgfplotspointminminmin{\noexpand\pgf@x=\the\pgf@x\space\noexpand\pgf@y=\the\pgf@y\space}%
	% ATTENTION: I re-use registers here! Make sure they won't be
	% overwritten! \pgfpointdiff and \pgfplotsqpointxy are ok in this respect.
	\let\pgfplots@xcoordminTEX=\pgf@xb
	\let\pgfplots@ycoordminTEX=\pgf@yb
	\pgfplots@xcoordminTEX=\pgf@x
	\pgfplots@ycoordminTEX=\pgf@y
	%
	%--------------------------------------------------
	% FIXME : WHAT IS THIS HERE FOR? 
	% \pgfplotsqpointxy{\pgfplots@xmax}{\pgfplots@ymax}%
	% \ifx\pgfplots@rectangle@width\pgfutil@empty
	% 	\def\pgfplots@tmp@xmax@ymin{\pgfplotsqpointxy{\pgfplots@xmax}{\pgfplots@ymin}}%
	% \else
	% 	% this 'if' here should only make a difference of about
	% 	% 1-2pt, not more.
	% 	%
	% 	% and I am quite sure that this inaccuracy (and this
	% 	% work-around) only affects the
	% 	% final size, not the relative plot accuracy.
	% 	\pgf@x=\pgfplots@xcoordminTEX
	% 	\advance\pgf@x by\pgfplots@width
	% 	\edef\pgfplots@tmp@xmax@ymin{\noexpand\pgfqpoint{\the\pgf@x}{\noexpand\pgfplots@ycoordminTEX}}%
	% \fi
	% \ifx\pgfplots@rectangle@height\pgfutil@empty
	% 	\def\pgfplots@tmp@xmin@ymax{\pgfplotsqpointxy{\pgfplots@xmin}{\pgfplots@ymax}}%
	% \else
	% 	\pgf@x=\pgfplots@ycoordminTEX
	% 	\advance\pgf@x\pgfplots@height
	% 	\edef\pgfplots@tmp@xmin@ymax{\noexpand\pgfqpoint{\noexpand\pgfplots@xcoordminTEX}{\the\pgf@x}}%
	% \fi
	%-------------------------------------------------- 
	\pgfpointdiff
		{\pgfqpoint{\pgfplots@xcoordminTEX}{\pgfplots@ycoordminTEX}}
		{\pgfplotspointmaxminmin}%
	\xdef\pgfplotspointxaxis{\noexpand\pgf@x=\the\pgf@x\space\noexpand\pgf@y=\the\pgf@y\space}%
	\pgfmathveclen{\pgf@x}{\pgf@y}%
	\xdef\pgfplotspointxaxislength{\pgfmathresult pt}%
	%
	\pgfpointdiff
		{\pgfqpoint{\pgfplots@xcoordminTEX}{\pgfplots@ycoordminTEX}}
		{\pgfplotspointminmaxmin}%
	\xdef\pgfplotspointyaxis{\noexpand\pgf@x=\the\pgf@x\space\noexpand\pgf@y=\the\pgf@y\space}%
	\pgfmathveclen{\pgf@x}{\pgf@y}%
	\xdef\pgfplotspointyaxislength{\pgfmathresult pt}%
	%
	\ifpgfplots@threedim
		\pgfpointdiff
			{\pgfqpoint{\pgfplots@xcoordminTEX}{\pgfplots@ycoordminTEX}}
			{\pgfplotsqpointxyz{\pgfplots@xmin}{\pgfplots@ymin}{\pgfplots@zmax}}%
		\xdef\pgfplotspointzaxis{\noexpand\pgf@x=\the\pgf@x\space\noexpand\pgf@y=\the\pgf@y\space}%
		\pgfmathveclen{\pgf@x}{\pgf@y}%
		\xdef\pgfplotspointzaxislength{\pgfmathresult pt}%
	\else
		\global\let\pgfplotspointzaxis=\pgfpointorigin
		\gdef\pgfplotspointzaxislength{0pt}%
	\fi
	\endgroup
	%
}

% PRECONDITION: called after \pgfplotspoint@initialisation@axes
% POSTCONDITION:
% 	\pgfplotspointcenter is defined.
\def\pgfplotspoint@initialisation@center{%
	\begingroup
	%
	%
	\ifpgfplots@threedim
		%
		\pgfpointscale
			{0.5}%
			{\pgfplotspointxaxis
			\pgf@xa=\pgf@x
			\pgf@xb=\pgf@y
			\pgfplotspointyaxis%
			\advance\pgf@xa by\pgf@x
			\advance\pgf@xb by\pgf@y
			\pgfplotspointzaxis%
			\advance\pgf@xa by\pgf@x
			\advance\pgf@xb by\pgf@y
			\pgf@x=\pgf@xa
			\pgf@y=\pgf@xb
			}%
		\xdef\pgfplotspointcenter{\noexpand\pgf@x=\the\pgf@x\space\noexpand\pgf@y=\the\pgf@y\space}%
	\else
		\pgfpointscale
			{0.5}%
			{\pgfpointadd
				\pgfplotspointxaxis%
				\pgfplotspointyaxis%
			}%
		\xdef\pgfplotspointcenter{\noexpand\pgf@x=\the\pgf@x\space\noexpand\pgf@y=\the\pgf@y\space}%
	\fi
	\endgroup
}

% PRECONDITION:
% 	the unit vectors are set up
%
% POSTCONDITION:
% 	\pgfplotspointunit[xyz]
% 	\pgfplotspointunit[xyz]length
% 	\pgfplotspointunit[xyz]invlength
% 	are all set up.
\def\pgfplotspoint@initialisation@units{%
	\edef\pgfplotspointunitx{\pgf@x=\the\pgf@xx\space\pgf@y=\the\pgf@xy\space}%
	\edef\pgfplotspointunity{\pgf@x=\the\pgf@yx\space\pgf@y=\the\pgf@yy\space}%
	\let\pgfplotsunitxlength=\pgfplots@x@veclength
	\let\pgfplotsunitylength=\pgfplots@y@veclength
	\let\pgfplotsunitxinvlength=\pgfplots@x@inverseveclength
	\let\pgfplotsunityinvlength=\pgfplots@y@inverseveclength
	\ifpgfplots@threedim
		\edef\pgfplotspointunitz{\pgf@x=\the\pgf@zx\space\pgf@y=\the\pgf@zy\space}%
		\let\pgfplotsunitzlength=\pgfplots@z@veclength
		\let\pgfplotsunitzinvlength=\pgfplots@z@inverseveclength
	\fi
}%

% The idea here is the following:
%
% 1. A point coordinate (<x>,<y>) without units should use
% relative axis coordinate system.
%
% 2. Any other point coordinate should not be altered.
%
% Former versions installed a shift and changed e_x, e_y and
% e_z. However, that was misleading as it disabled point 2). 
% So, my idea here is to replace \pgfpointxy and \pgfqpointxy
% such that they install the correct coordinate system before
% doing anything else.
\def\pgfplots@change@pgfpoints@to@descriptioncs{%
	%
	\let\pgfpointxy=\pgfplotspointdescriptionxy
	\let\pgfqpointxy=\pgfplotsqpointdescriptionxy
	% e_z is zero, so the xyz variants ignore z:
	\def\pgfpointxyz##1##2##3{\pgfpointxy{##1}{##2}}%
	\def\pgfqpointxyz##1##2##3{\pgfqpointxy{##1}{##2}}%
	%
}%

% \pgfplotspointticklabelcs{<axis>}{<coordinate>}
% or
% \pgfplotspointticklabelcs[<default shift>]{<axis>}{<coordinate>}
%
% Yields a point in the '<axis>ticklabel cs'.
%
% The 'xticklabel cs' is a coordinate system which expects either one
% or two coordinates. The first is the coordinate on the axis where
% x tick label will be placed (or would be placed). The first
% coordinate '0' means the lower aixs site and the value '1' the upper
% range. The second (optional) coordinate of 'xticklabel cs' is a
% shift in direction of the outer normal vector of the axis. The
% minimum shift is the largest' tick labels dimensions. If the second
% argument is omitted, the <default shift> will be used (0pt if this
% argument has been omitted as well).
%
% \pgfplotspointticklabelcs#1#2: 
% #1 is the axis (either x,y or z)
% #2 is the coordinate (either <relative coord> or <relative coord>,<shift>)
%
% @see \pgfplotsvalueoflargesttickdimen
%
% This command actually boils down to a
% \pgfplotsqpointoutsideofticklabelaxisrel
% invocation which. Thus, you *can* get the *same* effect by using
% basic level commands -- and you are not restricted to the tick label
% axis.
% @see \pgfplotsqpointoutsideofaxisrel
\def\pgfplotspointticklabelcs{\pgfutil@ifnextchar[%
	{\pgfplotspointticklabelcs@opt}%
	{\pgfplotspointticklabelcs@opt[0pt]}%
}%
\def\pgfplotspointticklabelcs@opt[#1]#2#3{%
	\pgfutil@in@{,}{#3}%
	\ifpgfutil@in@
		\edef\pgfplots@loc@TMPa{#3}%
	\else
		\edef\pgfplots@loc@TMPa{#3,#1}%
	\fi
	\def\pgfplots@loc@TMPb##1,##2\relax{%
		% invoke
		% \pgfplotsqpointoutsideofticklabelaxisrel{#2}{##1}{ticklabel dimen + ##2}:
		\begingroup
			\pgfmathparse{##2}%
			\pgf@xa=\pgfmathresult pt\relax
			\advance\pgf@xa by\pgfplotsvalueoflargesttickdimen{#2} %<- keep this space!
			\xdef\pgfplots@glob@TMPa{\pgf@sys@tonumber\pgf@xa}%
		\endgroup
		\def\pgfplots@loc@TMPa{\pgfplotsqpointoutsideofticklabelaxisrel{#2}{##1}}%
		\expandafter\pgfplots@loc@TMPa\expandafter{\pgfplots@glob@TMPa}%
	}%
	\expandafter\pgfplots@loc@TMPb\pgfplots@loc@TMPa\relax
}%


% Converts a dimen (with unit!) to a corresponding x, y or z
% coordinate.
% The result will be written to \pgfmathresult (without units).
%
% It is possible to use the result within the \pointxyz command(s).
%
% #1: the axis (x,y or z)
% #2: the dimen
%
% example:
% \pgfplotsconvertunittocoordinate{x}{5pt}
\def\pgfplotsconvertunittocoordinate#1#2{%
	\begingroup
	\pgf@xa=#2\relax
	\pgf@xa=\csname pgfplots@#1@inverseveclength\endcsname\pgf@xa
	\edef\pgfmathresult{\pgf@sys@tonumber\pgf@xa}%
	\pgfmath@smuggleone\pgfmathresult
	\endgroup
}%

% This is the same as using \pgfplotsconvertunittocoordinate for each
% component #1, #2 and #3. The results are directly communicated to
% \pgfplotsqpointxyz.
%
% Expects #1, #2 and #3 to be numbers with units and issues a \pgfplotsqpointxyz 
\def\pgfplotsqpointxyzabsolutesize#1#2#3{%
	\begingroup
	\pgf@xa=#1\relax
	\pgf@xa=\pgfplots@x@inverseveclength\pgf@xa
	\pgf@xb=#2\relax
	\pgf@xb=\pgfplots@y@inverseveclength\pgf@xb
	\pgf@ya=#3\relax
	\pgf@ya=\pgfplots@z@inverseveclength\pgf@ya
	\xdef\pgfplots@glob@TMPa{{\pgf@sys@tonumber\pgf@xa}{\pgf@sys@tonumber\pgf@xb}{\pgf@sys@tonumber\pgf@ya}}%
	\endgroup
	\expandafter\pgfplotsqpointxyz\pgfplots@glob@TMPa
}%

% Denotes a point in a twodimensional hyperplane. The hyperplane is
% one of the six planes of the threedimensional axis cube.
% 
% The meaning of coordinates #1 and #2 will be redefined depending on
% which surface we are currently processing. You can get the axis
% names for '#1' (a) and '#2' (b) using the macros
% \pgfplotspointonorientedsurfaceA (one of the characters x,y or z)
% and
% \pgfplotspointonorientedsurfaceB.
% The surface normal direction is
% \pgfplotspointonorientedsurfaceN.
%
% Example:
% \pgfplotspointonorientedsurfaceabsetupfor xyz
% \pgfplotspointonorientedsurfaceabsetupforsetz{<lower z limit>}{0}
%
% ->
%  \pgfplotspointonorientedsurfaceA = x
%  \pgfplotspointonorientedsurfaceB = y
%  \pgfplotspointonorientedsurfaceN = z
%  \pgfplotspointonorientedsurfacespec = {ab0}
%  \pgfplotspointonorientedsurfacespecunordered = {vv0}
%  \pgfplotspointonorientedsurfaceab{3}{4} =\pgfqpointxyz{3}{4}{<lower z limit>}
%
% \pgfplotspointonorientedsurfaceabsetupfor yxz
% \pgfplotspointonorientedsurfaceabsetupforsetz{<lower z limit>}{0}
% ->
%  \pgfplotspointonorientedsurfaceA = y
%  \pgfplotspointonorientedsurfaceB = x
%  \pgfplotspointonorientedsurfaceN = z
%  \pgfplotspointonorientedsurfacespec = {ba0}
%  \pgfplotspointonorientedsurfacespecunordered = {vv0}
%  \pgfplotspointonorientedsurfaceab{3}{4} =\pgfqpointxyz{4}{3}{<lower z limit>}
%
% @see \pgfplotspointonorientedsurfaceabsetupfor xyz
\def\pgfplotspointonorientedsurfaceab#1#2{%
	\pgfplots@error{Internal logic error: \string\pgfplotspointonorientedsurfaceab\ used although surface has not been declared! You need to call \string\pgfplotspointonorientedsurfaceabsetupfor xyz\ or its friends to do so.}%
}%

% This is a shortcut for 
% \pgfpointadd
% 	{\pgfplotspointonorientedsurfaceab{#1}{#2}}
% 	{<shift in B direction of #3>}
%
% where #3 is a dimension (a number with unit).
\def\pgfplotspointonorientedsurfaceabwithbshift#1#2#3{%
	\begingroup
	\pgf@xa=#3\relax
	\ifdim\pgf@xa=0pt
	\else
		\pgf@xa=\csname pgfplots@\pgfplotspointonorientedsurfaceB @inverseveclength\endcsname\pgf@xa
	\fi
	\advance\pgf@xa by#2pt
	\edef\pgfplots@loc@b{\pgf@sys@tonumber\pgf@xa}%
	\pgf@process{\pgfplotspointonorientedsurfaceab{#1}{\pgfplots@loc@b}}%
	\endgroup
}

\pgfkeyssetvalue{/pgfplots/oriented surf installed}{}

% This macro will be defined after
% \pgfplotspointonorientedsurfaceabsetupfor...
% routines. It expands to a three-character string 
% where the first character contains information about the x axis,
% the second about the y axis and the third about the z axis.
%
% The single characters can be one of
% - 'a'  - the corresponding axis is the PRIMARY direction of the
%   oriented surface.
% - 'b'  - the corresponding axis is the SECONDARY direction of the
%   oriented surface.
% - anything else - the characters provides as second argument for
%   \pgfplotspointonorientedsurfaceabsetupforsetz{}{}, for example.
%   Common choices are '0' for lower limit, '1' for upper limit and
%   '2' for other.
\def\pgfplotspointonorientedsurfacespec{}%

% Similar to \pgfplotspointonorientedsurfacespec, this macro encodes
% the currently active oriented surface.
% However, it only contains the characters 'v', '0' and '1' and '2'.
% The distinction 'v in {a,b}' is eliminated.
\def\pgfplotspointonorientedsurfacespecunordered{}%

% As \pgfplotspointonorientedsurfacespec, this macro contains
% information about the current oriented surface: it contains the
% fixed symbol '0', '1' or '2' describing the only direction which is
% fixed.
\def\pgfplotspointonorientedsurfacespecsymbol{\pgfplotspointonorientedsurfaceabsetupfor@fixedsymbol}

\def\pgfplotspointonorientedsurfaceabsetupfor#1#2#3{%
	\pgfutil@ifundefined{pgfplotspointonorientedsurfaceabsetupfor@@#1#2#3}{%
		\pgfplots@error{Sorry, \string\pgfplotspointonorientedsurfaceabsetupfor\space#1#2#3 is not yet implemented.}%
	}{
		\csname pgfplotspointonorientedsurfaceabsetupfor@@#1#2#3\endcsname
	}%
}%
%
% Initialises \pgfplotspointonorientedsurfaceab such that 'a' is the x
% axis and 'b' is the y axis and the z coordinate has been fixed with
% \pgfplotspointonorientedsurfaceabsetupforsetz{}.
%
% The Z value needs to be fixed with 
% \pgfplotspointonorientedsurfaceabsetupforsetz .
\def\pgfplotspointonorientedsurfaceabsetupfor@@xyz{%
	\def\pgfplotspointonorientedsurfaceab##1##2{\pgfplotsqpointxyz{##1}{##2}{\pgfplotspointonorientedsurfaceabsetupfor@fixedz}}%
	\def\pgfplotspointonorientedsurfaceA{x}%
	\def\pgfplotspointonorientedsurfaceB{y}%
	\def\pgfplotspointonorientedsurfaceN{z}%
	\edef\pgfplotspointonorientedsurfacespec{ab\pgfplotspointonorientedsurfaceabsetupfor@fixedsymbol}%
	\edef\pgfplotspointonorientedsurfacespecunordered{vv\pgfplotspointonorientedsurfaceabsetupfor@fixedsymbol}%
	\pgfkeysvalueof{/pgfplots/oriented surf installed}%
}%
\def\pgfplotspointonorientedsurfaceabsetupfor@@yxz{%
	\def\pgfplotspointonorientedsurfaceab##1##2{\pgfplotsqpointxyz{##2}{##1}{\pgfplotspointonorientedsurfaceabsetupfor@fixedz}}%
	\def\pgfplotspointonorientedsurfaceA{y}%
	\def\pgfplotspointonorientedsurfaceB{x}%
	\def\pgfplotspointonorientedsurfaceN{z}%
	\edef\pgfplotspointonorientedsurfacespec{ba\pgfplotspointonorientedsurfaceabsetupfor@fixedsymbol}%
	\edef\pgfplotspointonorientedsurfacespecunordered{vv\pgfplotspointonorientedsurfaceabsetupfor@fixedsymbol}%
	\pgfkeysvalueof{/pgfplots/oriented surf installed}%
}%
\def\pgfplotspointonorientedsurfaceabsetupfor@@xzy{%
	\def\pgfplotspointonorientedsurfaceab##1##2{\pgfplotsqpointxyz{##1}{\pgfplotspointonorientedsurfaceabsetupfor@fixedy}{##2}}%
	\def\pgfplotspointonorientedsurfaceA{x}%
	\def\pgfplotspointonorientedsurfaceB{z}%
	\def\pgfplotspointonorientedsurfaceN{y}%
	\edef\pgfplotspointonorientedsurfacespec{a\pgfplotspointonorientedsurfaceabsetupfor@fixedsymbol b}%
	\edef\pgfplotspointonorientedsurfacespecunordered{v\pgfplotspointonorientedsurfaceabsetupfor@fixedsymbol v}%
	\pgfkeysvalueof{/pgfplots/oriented surf installed}%
}%
\def\pgfplotspointonorientedsurfaceabsetupfor@@zxy{%
	\def\pgfplotspointonorientedsurfaceab##1##2{\pgfplotsqpointxyz{##2}{\pgfplotspointonorientedsurfaceabsetupfor@fixedy}{##1}}%
	\def\pgfplotspointonorientedsurfaceA{z}%
	\def\pgfplotspointonorientedsurfaceB{x}%
	\def\pgfplotspointonorientedsurfaceN{y}%
	\edef\pgfplotspointonorientedsurfacespec{b\pgfplotspointonorientedsurfaceabsetupfor@fixedsymbol a}%
	\edef\pgfplotspointonorientedsurfacespecunordered{v\pgfplotspointonorientedsurfaceabsetupfor@fixedsymbol v}%
	\pgfkeysvalueof{/pgfplots/oriented surf installed}%
}%
\def\pgfplotspointonorientedsurfaceabsetupfor@@yzx{%
	\def\pgfplotspointonorientedsurfaceab##1##2{\pgfplotsqpointxyz{\pgfplotspointonorientedsurfaceabsetupfor@fixedx}{##1}{##2}}%
	\def\pgfplotspointonorientedsurfaceA{y}%
	\def\pgfplotspointonorientedsurfaceB{z}%
	\def\pgfplotspointonorientedsurfaceN{x}%
	\edef\pgfplotspointonorientedsurfacespec{\pgfplotspointonorientedsurfaceabsetupfor@fixedsymbol ab}%
	\edef\pgfplotspointonorientedsurfacespecunordered{\pgfplotspointonorientedsurfaceabsetupfor@fixedsymbol vv}%
	\pgfkeysvalueof{/pgfplots/oriented surf installed}%
}%
\def\pgfplotspointonorientedsurfaceabsetupfor@@zyx{%
	\def\pgfplotspointonorientedsurfaceab##1##2{\pgfplotsqpointxyz{\pgfplotspointonorientedsurfaceabsetupfor@fixedx}{##2}{##1}}%
	\def\pgfplotspointonorientedsurfaceA{z}%
	\def\pgfplotspointonorientedsurfaceB{y}%
	\def\pgfplotspointonorientedsurfaceN{x}%
	\edef\pgfplotspointonorientedsurfacespec{\pgfplotspointonorientedsurfaceabsetupfor@fixedsymbol ba}%
	\edef\pgfplotspointonorientedsurfacespecunordered{\pgfplotspointonorientedsurfaceabsetupfor@fixedsymbol vv}%
	\pgfkeysvalueof{/pgfplots/oriented surf installed}%
}%

% Fixes 'x' to #1 for use in
% \pgfplotspointonorientedsurfaceabsetupfor zyx and 
% \pgfplotspointonorientedsurfaceabsetupfor yzx.
%
% #1: The fixed value for 'x' (a coordinate in transformed range).
% #2: a one-character symbol describing 'x'.
% Command characters are
% 	 0 : x is the lower x-axis range.
% 	 1 : x is the upper x-axis range.
% 	 2 : other.
\def\pgfplotspointonorientedsurfaceabsetupforsetx#1#2{%
	\edef\pgfplotspointonorientedsurfaceabsetupfor@fixedx{#1}%
	\edef\pgfplotspointonorientedsurfaceabsetupfor@fixedsymbol{#2}%
}%
\def\pgfplotspointonorientedsurfaceabsetupforsety#1#2{%
	\edef\pgfplotspointonorientedsurfaceabsetupfor@fixedy{#1}%
	\edef\pgfplotspointonorientedsurfaceabsetupfor@fixedsymbol{#2}%
}%
\def\pgfplotspointonorientedsurfaceabsetupforsetz#1#2{%
	\edef\pgfplotspointonorientedsurfaceabsetupfor@fixedz{#1}%
	\edef\pgfplotspointonorientedsurfaceabsetupfor@fixedsymbol{#2}%
}%

% Helper methods which should be used if no Z component exists (pure
% 2d plots).
\def\pgfplotspointonorientedsurfaceabsetupfor@@xy{%
	\def\pgfplotspointonorientedsurfaceabsetupfor@fixedsymbol{0}%
	\def\pgfplotspointonorientedsurfaceab##1##2{\pgfplotsqpointxy{##1}{##2}}%
	\def\pgfplotspointonorientedsurfaceA{x}%
	\def\pgfplotspointonorientedsurfaceB{y}%
	\def\pgfplotspointonorientedsurfaceN{z}%
	\edef\pgfplotspointonorientedsurfacespec{ab\pgfplotspointonorientedsurfaceabsetupfor@fixedsymbol}%
	\edef\pgfplotspointonorientedsurfacespecunordered{vv\pgfplotspointonorientedsurfaceabsetupfor@fixedsymbol}%
	\pgfkeysvalueof{/pgfplots/oriented surf installed}%
}%
\def\pgfplotspointonorientedsurfaceabsetupfor@@yx{%
	\def\pgfplotspointonorientedsurfaceabsetupfor@fixedsymbol{0}%
	\def\pgfplotspointonorientedsurfaceab##1##2{\pgfplotsqpointxy{##2}{##1}}%
	\def\pgfplotspointonorientedsurfaceA{y}%
	\def\pgfplotspointonorientedsurfaceB{x}%
	\def\pgfplotspointonorientedsurfaceN{z}%
	\edef\pgfplotspointonorientedsurfacespec{ba\pgfplotspointonorientedsurfaceabsetupfor@fixedsymbol}%
	\edef\pgfplotspointonorientedsurfacespecunordered{vv\pgfplotspointonorientedsurfaceabsetupfor@fixedsymbol}%
	\pgfkeysvalueof{/pgfplots/oriented surf installed}%
}%


% Assuming we have an oriented surface installed, this command defines
% \pgfplotsretval to be the three-char-string such that the 'a' axis
% if the oriented surface takes value '#1', the 'b' axis of the
% oriented surface takes '#2' and the remaining axis has its fixed
% symbol anyway.
\def\pgfplotspointonorientedsurfaceabtolinespec#1#2{%
	\expandafter\pgfplotspointonorientedsurfaceabtolinespec@a\pgfplotspointonorientedsurfacespec\relax#1%
	\expandafter\pgfplotspointonorientedsurfaceabtolinespec@b\pgfplotsretval\relax#2%
}%
\def\pgfplotspointonorientedsurfaceabtolinespec@a#1a#2\relax#3{\edef\pgfplotsretval{#1#3#2}}
\def\pgfplotspointonorientedsurfaceabtolinespec@b#1b#2\relax#3{\edef\pgfplotsretval{#1#3#2}}

% Assuming that an oriented surface has been initialised, say 'a0b',
% we have the following possible axis lines which can be drawn:
% - b=0: 'v00'
% - b=1: 'v01'
% - b=2: 'v02'
%
% To check which of them should be drawn, this macro here converts 'a'
% to 'v' and 'b' to '#1'. The remaining possible character will be
% copied as-is.
%
% The resulting three-character-string is written into '#2'.
%
% #1 : the replacement value which will be inserted instead of 'b' in
% the currently active oriented surface.
% #2 : the macro which will contain the output axis line specification
% (three-char-string).
% 
% Example:
% \pgfplotspointonorientedsurfaceabsetupfor xyz
% \pgfplotspointonorientedsurfaceabsetupforsetz{<lower z limit>}{0}
% -> the oriented surface is 'ab0'
%  ...
% \pgfplotspointonorientedsurfaceabgetcontainedaxisline{0}\pgfplotsretval
% -> \pgfplotsretval = 'v00'
% \pgfplotspointonorientedsurfaceabgetcontainedaxisline{1}\pgfplotsretval
% -> \pgfplotsretval = 'v10'
% \pgfplotspointonorientedsurfaceabgetcontainedaxisline{2}\pgfplotsretval
% -> \pgfplotsretval = 'v20'
\def\pgfplotspointonorientedsurfaceabgetcontainedaxisline#1#2{%
	\expandafter\pgfplotspointonorientedsurfaceabgetcontainedaxisline@\pgfplotspointonorientedsurfacespec\relax{#1}%
	\let#2=\pgfplots@loc@TMPa
}%
% writes into \pgfplots@loc@TMPa:
\def\pgfplotspointonorientedsurfaceabgetcontainedaxisline@#1#2#3\relax#4{%
	\pgfplotspointonorientedsurfaceabgetcontainedaxisline@single{#1}{#4}\to\pgfplots@loc@TMPa
	\pgfplotspointonorientedsurfaceabgetcontainedaxisline@single{#2}{#4}\to\pgfplots@loc@TMPb
	\pgfplotspointonorientedsurfaceabgetcontainedaxisline@single{#3}{#4}\to\pgfplots@loc@TMPc
	\edef\pgfplots@loc@TMPa{\pgfplots@loc@TMPa\pgfplots@loc@TMPb\pgfplots@loc@TMPc}%
}%
\def\pgfplotspointonorientedsurfaceabgetcontainedaxisline@single#1#2\to#3{%
	\if#1a%
		\def#3{v}%
	\else
		\if#1b%
			\def#3{#2}%
		\else
			\def#3{#1}%
		\fi
	\fi
}%


% Finds the two surfaces which are adjacent to an axis line encoded as
% three-character-string.
%
% There are the following possibilities:
% #1 = 'v**' where '*' is not 'v'.
% 	-> #2 = 'vv*'  and #3 = 'v*v'
%
% #1 = '*v*'
% 	-> #2 = 'vv*'  and #3 = '*vv'
%
% #1 = '**v'
% 	-> #2 = 'v*v'  and #3 = '*vv'
\def\pgfplotsgetadjacentsurfsforaxisline#1\to#2#3{%
	\edef\pgfplots@loc@TMPa{#1}%
	\expandafter\pgfplotsgetadjacentsurfsforaxisline@\pgfplots@loc@TMPa\relax{#2}{#3}%
}%
\def\pgfplotsgetadjacentsurfsforaxisline@#1#2#3\relax#4#5{%
	\if#1v%
		\def#4{vv#3}%
		\def#5{v#2v}%
	\else
		\if#2v%
			\def#4{vv#3}%
			\def#5{#1vv}%
		\else
			\def#4{v#2v}%
			\def#5{#1vv}%
		\fi
	\fi
}%

% Executes code '#2' if the axis surface denoted by the
% three-character-string '#1' is a foreground surface and code '#3' if
% the surface '#1' is a background surface.
%
% #1: a three-char-string with the keys 
% 	'v' = 'varying', 
% 	'0' = 'lower axis limit',
% 	'1' = 'upper axis limit'.
% 	The string 'v0v' means that x and z are varying in that surface
% 	and 'y' is fixed to the lower axis limit.
% #2: code to execute if '#1' is foreground.
% #3: code to execute if '#1' is background.
\def\pgfplotsifaxissurfaceisforeground#1#2#3{%
	\pgfutil@ifundefined{pgfplots@surfviewdepth@#1}{%
		\pgfplots@error{\string\pgfplotsifaxissurfaceisforeground{#1}: undefined three-character-string '#1' provided.}%
		#3%
	}{%
		\if f\csname pgfplots@surfviewdepth@#1\endcsname #2\else #3\fi
	}%
}%

% As \pgfplotsifaxissurfaceisforeground, but for axis lines.
%
% #1: a three-character string with the same keys as in
% \pgfplotsifaxissurfaceisforeground. However, there should be only
% one varying direction as we are dealing with an axis line.
% #2: code to execute if '#1' is foreground.
% #3: code to execute if '#1' is background.
%
\def\pgfplotsifaxislineisforeground#1#2#3{%
	\pgfplotsgetadjacentsurfsforaxisline#1\to\pgfplots@loc@TMPb\pgfplots@loc@TMPc
	\pgfplotsifaxissurfaceisforeground{\pgfplots@loc@TMPb}{%
		#2%
	}{%
		\pgfplotsifaxissurfaceisforeground{\pgfplots@loc@TMPc}{%
			#2%
		}{%
			#3%
		}%
	}%
}%
% Executes code '#2' if the axis surface denoted by the
% three-char-string '#1' is on the convex hull of the projected axis
% cube or code '#3' if that is not the case.
%
% The arguments are the same as for \pgfplotsifaxislineisforeground:
% #1: a three-character string with the same keys as in
% \pgfplotsifaxissurfaceisforeground. However, there should be only
% one varying direction as we are dealing with an axis line.
% #2: code to execute if '#1' is foreground.
% #3: code to execute if '#1' is background.
\def\pgfplotsifaxislineisonconvexhull#1#2#3{%
	\pgfplotsgetadjacentsurfsforaxisline#1\to\pgfplots@loc@TMPb\pgfplots@loc@TMPc
	% '#1' is on the convex hull if ONE of the adjacent surfs is
	% foreground and the other one is background.
	\pgfplots@loc@tmpfalse
	\pgfplotsifaxissurfaceisforeground{\pgfplots@loc@TMPb}{%
		\pgfplotsifaxissurfaceisforeground{\pgfplots@loc@TMPc}{%
		}{%
			\pgfplots@loc@tmptrue
		}%
	}{%
	}%
	\pgfplotsifaxissurfaceisforeground{\pgfplots@loc@TMPb}{%
	}{%
		\pgfplotsifaxissurfaceisforeground{\pgfplots@loc@TMPc}{%
			\pgfplots@loc@tmptrue
		}{%
		}%
	}%
	\ifpgfplots@loc@tmp #2\else #3\fi
}%

% Returns either '' (empty) or '-' (minus) for each of the two variing sides of the
% oriented surface described by #1.
%
% The output value #2 = '' means that the positive b axis points to
% the direction of the convex hull of the projected figure.
%
% The output value #2 = '-' means that the NEGATIVE b axis points to
% the direction of the convex hull of the projected figure.
%
% The output value #3 is also either '' or '-'. It refers to the
% direction of the 'n' axis of the surface which points to the convex
% hull of the projected figure.
%
% The returned values are used to decide how to align tick labels such
% that they are always outside of the convex hull of the projected
% axis.
%
% #1: three characters denoting an oriented surface.
% #2: a macro name. Will be filled either with '' (empty string) or
% '-', encoding the direction of the 'b' axis of surface #1 which
% points to the convex hull.
% #3: a macro name. It takes the same values as '#2', but it refers to
% the 'n' axis of surface #1.
\def\pgfplotsgetdirectionstoconvexhullforsurf#1#2#3{%
	\pgfplotsgetdirectionstoconvexhullforsurf@#1\relax{#2}{#3}%
}

% Executes code '#2' if the axis line with 'b=#1' on the current
% oriented surface shall be drawn.
% If that is not the case, the code '#3' will be executed.
%
% Example:
% Let's assume the current oriented surface is 'b0a'.
% Then,
%   \pgfplots@ifaxisline@B@onorientedsurf@should@be@drawn{0}{draw it!}{\relax}
% will check whether the line '00v' shall be drawn while
%   \pgfplots@ifaxisline@B@onorientedsurf@should@be@drawn{1}{draw it!}{\relax}
% will check whether the line '10v' shall be drawn.
%
% The check is based on
% 1. foreground/background flags
% 2. the current configuration of the axis lines key(s)
%
% @see \pgfplotspointonorientedsurfaceabgetcontainedaxisline
\def\pgfplots@ifaxisline@B@onorientedsurf@should@be@drawn#1#2#3{%
	\pgfplots@ifaxisline@B@onorientedsurf@should@be@drawn@{#1}{%
		\edef\pgfplots@loc@TMPe{\csname pgfplots@\pgfplotspointonorientedsurfaceA axislinesnum\endcsname}%
		\if0\pgfplots@loc@TMPe
			% boxed axis lines
			#2%
		\else
			\if2\pgfplots@loc@TMPe
				% centered axis lines
				#2%
			\else
				% either the 'left' or 'right' positioned cases.
				% These have exactly one line which is the one where
				% tick labels will be placed. And this, in turn, is
				% already known, even for 3D. Check if we have it:
				\pgfplotspointonorientedsurfaceabtolinespec v#1%
				\edef\pgfplots@loc@TMPe{\csname pgfplots@\pgfplotspointonorientedsurfaceA ticklabelaxisspec\endcsname}%
				\ifx\pgfplots@loc@TMPe\pgfplotsretval
					#2%
				\else
					#3%
				\fi
			\fi
		\fi
	}{%
		#3%
	}%
}%
\def\pgfplots@ifaxisline@B@onorientedsurf@should@be@drawn@allaxislinevariations#1#2#3{%
	\pgfplots@ifaxisline@B@onorientedsurf@should@be@drawn@{#1}{%
		#2%
	}{%
		#3%
	}%
}%

% A sub-part of \pgfplots@ifaxisline@B@onorientedsurf@should@be@drawn
% which is /only/ based on foreground/background flags.
%
% @ATTENTION : this command will be always true for the 2D case. (it
% will be overwritten, see \pgfplots@decide@which@figure@surfaces@are@drawn)
\def\pgfplots@ifaxisline@B@onorientedsurf@should@be@drawn@#1#2#3{%
	\pgfplotspointonorientedsurfaceabgetcontainedaxisline#1\pgfplots@loc@TMPc
	\pgfplotsgetadjacentsurfsforaxisline\pgfplots@loc@TMPc\to\pgfplots@loc@TMPb\pgfplots@loc@TMPc
	\pgfplotsifaxissurfaceisforeground{\pgfplots@loc@TMPb}{%
		\pgfplotsifaxissurfaceisforeground{\pgfplots@loc@TMPc}{%
			#3%
		}{%
			#2%
		}%
	}{%
		#2%
	}%
}%

% Similar to \pgfplots@ifaxisline@B@onorientedsurf@should@be@drawn,
% this thing here execute '#1' if grid lines on the currently
% initialised oriented surfaces shall be drawn and '#2' if not.
%
% This does only handle foreground/background issues; it has NOTHING
% to do with the actual checks if grid lines are active or not.
\def\pgfplots@ifgridlines@onorientedsurf@should@be@drawn#1#2{%
	% grid lines shall be drawn 
	% if and only if BOTH adjacent axis lines shall be drawn:
	\pgfplots@ifaxisline@B@onorientedsurf@should@be@drawn@allaxislinevariations{0}{%
		% remark: this is ALWAYS true for 2D plots.
		\pgfplots@ifaxisline@B@onorientedsurf@should@be@drawn@allaxislinevariations{1}{%
			#1%
		}{%
			#2%
		}%
	}{%
		#2%
	}%
}%

% Checks whether the line specified by a three-character-string '#1'
% is inside of the currently set-up oriented surface.
%
% The return value is encoded as integer into the macro #2 as
% described below.
%
% #1 : a three-character string uniquely identifing an axis line.
%      Each of the three characters can be 'v', '0' or '1'.
%      The value '0' denotes the lower axis range while '1' denotes
%      the upper axis range. The character 'v' stands for 'varying'
%      and indicates the direction in which the line varies. The first
%      character contains the values for the 'x' axis, the second
%      character for the 'y' axis and the third character for the 'z'
%      axis.
%      Example:
%      	'v01' is the axis line with 'y=lower y limit' and 'z=upper z limit'
%      	'10v' is the axis line with 'x=upper x limit' and 'y=lower y limit'
%      The 'v' character indicates the varying component. There may be
%      only one 'v'.
% #2 : a macro name. It will be empty if the line is NOT on the
% 		current surface. If will be non-empty if it IS on the current
% 		surface.
% 		To be more precise, If the line IS on the current surface, '#2' will be set to
% 		the character in '#1' which belongs to the second oriented
% 		surface axis (which is called the 'b' axis).
% 		Thus, the following values for '#2' can be expected:
% 		- '' (empty) if the line is not on the surface,
% 		- 'v' if the line IS on the surface, and '#1' contains a 'v' 
% 		in direction of the surface's 'b' axis.
% 		- '0' if the line IS on the surface and '#1' contains a '0' in
% 		direction of the surface's 'b' axis,
% 		- '1' if the line IS on the surface and '#1' contains a '1' in
% 		direction of the surface's 'b' axis.
% 		No other values are possible.
%
% 		Example:
% 		\pgfplotspointonorientedsurfaceabsetupforsetz{\zmax}{1}
% 		\pgfplotspointonorientedsurfaceabsetupfor yxz
% 		\pgfplotspointonorientedsurfaceabmatchaxisline{v01}{\result}
% 		-> \result will be 'v' because 'x=v' in '{v01}
%
% 		\pgfplotspointonorientedsurfaceabsetupforsety{\ymin}{0}
% 		\pgfplotspointonorientedsurfaceabsetupfor xzy
% 		\pgfplotspointonorientedsurfaceabmatchaxisline{v01}{\result}
% 		-> \result will be '1' because 'z=1' in '{v01}
%
% 		\pgfplotspointonorientedsurfaceabsetupforsety{\ymax}{1}
% 		\pgfplotspointonorientedsurfaceabsetupfor xzy
% 		\pgfplotspointonorientedsurfaceabmatchaxisline{v01}{\result}
% 		-> \result will be empty because 'y=0' in '{v01}
%
% 		\pgfplotspointonorientedsurfaceabsetupforsetx{\xmax}{1}
% 		\pgfplotspointonorientedsurfaceabsetupfor yzx
% 		\pgfplotspointonorientedsurfaceabmatchaxisline{10v}{\result}
% 		-> \result will be 'v' because 'z=v' in '{10v}
\def\pgfplotspointonorientedsurfaceabmatchaxisline#1#2{%
	\pgfplotsmatchcubeparts{#1}{\pgfplotspointonorientedsurfacespec}{#2}%
}%

% Checks whether the line or surface specified by a three-character-string '#1'
% is inside of the surface designated by the three-character-string '#2'.
%
%
% Arguments:
% #1  a cube-part (axis line or surface) encoded as three character
%     string. Can be '0v1' or 'vv0' or so (see above).
% #2  a surface, also  encoded as three character string. Maybe
%     oriented.
% #3  The return value is encoded as char into the macro #3 as
%     described in \pgfplotspointonorientedsurfaceabmatchaxisline:
%     '#3' will be EMPTY if '#1' is NOT in '#2'.
%     '#3' will be NON-EMPTY if '#1' IS in '#2'.
\def\pgfplotsmatchcubeparts#1#2#3{%
	\edef\pgfplots@loc@TMPa{#1:#2}%
	\expandafter\pgfplotspointonorientedsurfaceabmatchaxisline@\pgfplots@loc@TMPa\pgfplots@EOI
	\let#3=\pgfplots@loc@TMPa
}%

% IMPLEMENTATION: 
% The return value is 'yes, #1#2#3 is on the oriented surface #4#5#6'
% if and only if for all three character pairs, the following single
% relations hold.
% Input char   oriented surface char
%  'v' :         is either a or b or v
%  '0' :         is either 0, a, b, v or 2 (i.e. NOT 1)
%  '1' :         is either 1, a, b, v or 2 (i.e. NOT 0)
% That's all. 
%
% If the 'oriented surface char' is 'v', then we actually don't have
% an oriented surface but just a surface.
% So, 'a0b' is the same surface as 'v0v', but the first choice has
% designated orientations.
%
% @POST \pgfplots@loc@TMPa contains the return value macro.
\def\pgfplotspointonorientedsurfaceabmatchaxisline@#1#2#3:#4#5#6\pgfplots@EOI{%
	% Search for the 'b' character:
	\if#4b%
		\def\pgfplots@loc@TMPa{#1}%
	\else
		\if#5b%
			\def\pgfplots@loc@TMPa{#2}%
		\else
			\if#6b%
				\def\pgfplots@loc@TMPa{#3}%
			\else
				\def\pgfplots@loc@TMPa{v}% FALLBACK solution.
			\fi
		\fi
	\fi
	% Now, check whether we need to clear the return value (i.e.
	% return false)
	\pgfplotspointonorientedsurfaceabmatchaxisline@single{#1}{#4}%
	\pgfplotspointonorientedsurfaceabmatchaxisline@single{#2}{#5}%
	\pgfplotspointonorientedsurfaceabmatchaxisline@single{#3}{#6}%
}
\def\pgfplotspointonorientedsurfaceabmatchaxisline@single#1#2{%
	\if#1v%
		\if#2a%
		\else
			\if#2b%
			\else
				\if#2v%
				\else
					\let\pgfplots@loc@TMPa=\pgfutil@empty
				\fi
			\fi
		\fi
	\else
		\if0#1%
			\if1#2%
				\let\pgfplots@loc@TMPa=\pgfutil@empty
			\fi
		\else
			\if1#1%
				\if0#2%
					\let\pgfplots@loc@TMPa=\pgfutil@empty
				\fi
			\else
				% return TRUE.
				% I admit I am not sure at all if this works in all
				% cases
				\pgfplotspointonorientedsurfaceabmatchaxisline@warn{#1}%
			\fi
		\fi
	\fi
}%
\def\pgfplotspointonorientedsurfaceabmatchaxisline@warn#1{%
	\pgfplots@warning{The internal implementation is suspicious that something is wrong: \string\pgfplotspointonorientedsurfaceabmatchaxisline@warn:  the character '#1' in a three-character axis line or surface description might not be fully supported...}%
}%

% Provides a point on an arbitrary axis (identified by a
% three-character-string) which can take any value on that axis and
% which is shifted in the direction of the outer normal vector. 
%
% #1: a three-character-string denoting the desired axis
% #2: the coordinate on that axis (the coordinate for the 'v'
% direction in '#1'). It needs to be given as it would be supplied to
% an \addplot or 'axis cs' coordinate; any logs or data
% transformations will be applied.
% #3: the distance (a dimension) describing how much we should move
% away from that axis. This points to the outside normal vector of the
% axis cube.
%
% @see \pgfplotsqpointoutsideofticklabelaxis
%
% If, in addition, the boolean \ifpgfslopedattime is true, the same
% transformations which would have been applied by
% \pgftransformlineattime will be applied, that means the 'sloped'
% feature of tikz is applied. FIXME : is that up-to-date!?
%
% @see \pgftransformlineattime -- it is quite similar.
\def\pgfplotsqpointoutsideofaxis#1#2#3{%
	\begingroup
	\def\pgfplotspointoutsideofaxis@plug@trafo##1##2{\csname pgfplotstransformcoordinate##1\endcsname{##2}}%
	\let\pgfplotspointoutsideofaxis@plug@getlimit=\pgfplotspointoutsideofaxis@getlimit@
	\edef\pgfplots@loc@TMPa{#1}%
	\expandafter\pgfplotspointoutsideofaxis@\pgfplots@loc@TMPa\relax{#2}{#3}%
}%

% A variant of \pgfplotsqpointoutsideofaxis with relative values for
% #2.
% That means  
%   '#2 = 0' === lower axis limit 
% and 
%   '#2 = 1' === upper axis limit.
\def\pgfplotsqpointoutsideofaxisrel#1#2#3{%
	\begingroup
	\def\pgfplotspointoutsideofaxis@plug@trafo##1##2{%
		\begingroup
			% compute ##1min + ##2 * (##1max - ##1min) :
			%
			\afterassignment\pgfplots@gobble@until@relax
			\pgf@xa=##2pt\relax
			\edef\pgfplots@loc@TMPa{\pgf@sys@tonumber\pgf@xa}%
			%
			\pgf@xa=\csname pgfplots@##1min\endcsname pt %
			\pgf@xb=\csname pgfplots@##1max\endcsname pt %
			\pgf@xc=\pgf@xb
			\ifpgfplots@allow@reversal@of@rel@axis@cs
				\if\pgfkeysvalueof{/pgfplots/##1 dir/value}r%
					% reverse: exchange min and max.
					\pgf@xb=\pgf@xa
					\pgf@xa=\pgf@xc
					\pgf@xc=\pgf@xb
				\fi
			\fi
			\advance\pgf@xc by-\pgf@xa
			\pgf@xc=\pgfplots@loc@TMPa\pgf@xc
			\advance\pgf@xc by\pgf@xa
			\edef\pgfmathresult{\pgf@sys@tonumber\pgf@xc}%
			\pgfmath@smuggleone\pgfmathresult
		\endgroup
	}%
	\let\pgfplotspointoutsideofaxis@plug@getlimit=\pgfplotspointoutsideofaxis@getlimit@
	\edef\pgfplots@loc@TMPa{#1}%
	\expandafter\pgfplotspointoutsideofaxis@\pgfplots@loc@TMPa\relax{#2}{#3}%
}%

% A variant of \pgfplotsqpointoutsideofaxis which accepts transformed
% values for '#2' (i.e. any data transformations and logs are already
% applied).
\def\pgfplotsqpointoutsideofaxistransformed#1#2#3{%
	\begingroup
	\def\pgfplotspointoutsideofaxis@plug@trafo##1##2{\def\pgfmathresult{##2}}%
	\let\pgfplotspointoutsideofaxis@plug@getlimit=\pgfplotspointoutsideofaxis@getlimit@
	\edef\pgfplots@loc@TMPa{#1}%
	\expandafter\pgfplotspointoutsideofaxis@\pgfplots@loc@TMPa\relax{#2}{#3}%
}%

% Computes the unit outer normal vector of the axis identified by a
% three-character-string '#1'.
%
% This is the same normal vector which is used inside of
% \pgfplotsqpointoutsideofaxis and its variants.
%
% The output of this command will be cached and re-used during the
% lifetime of an axis.
%
% The returned normal vector has length 1 (computed with
% \pgfpointnormalised).
%
% NOTE: some specialized axis types support non-linear axes (for
% example, polar axes). In that case, the outer normal vector *varies*
% along the `v' direction (of the three-character-string `#1').
% The value of `v' can be set using
% \pgfplotspointouternormalvectorofaxissetv{<axis three char string>}{<transformed coordinate>}
\def\pgfplotspointouternormalvectorofaxis#1{%
	\pgfplotspointouternormalvectorofaxis@ifdependson@v{#1}{%
		\expandafter\global\expandafter\let\csname pgfplotspointouternormalvectorofaxis@cache@#1\endcsname\relax
	}{%
	}%
	\expandafter\ifx\csname pgfplotspointouternormalvectorofaxis@cache@#1\endcsname\relax
		\begingroup
		\edef\pgfplots@loc@TMPa{#1}%
		\expandafter\pgfplotspointouternormalvectorofaxis@\pgfplots@loc@TMPa\relax%
		% \endgroup in \pgfplotspointouternormalvectorofaxis@.
		\expandafter\xdef\csname pgfplotspointouternormalvectorofaxis@cache@#1\endcsname{\global\pgf@x=\the\pgf@x\space\global\pgf@y=\the\pgf@y\space}%
	\else
		\csname pgfplotspointouternormalvectorofaxis@cache@#1\endcsname
	\fi
}%

% Fixes the "v" value for successive calls to
% \pgfplotspointouternormalvectorofaxis{#1}.
%
% #1 the three-character-string of an axis or the empty string.
% If #1 is empty, the actual configuration of oriented surfaces may be
% used to check which normal vector is intented.
%
% #2 the "v" value to store. It should be a transformed coordinate.
\def\pgfplotspointouternormalvectorofaxissetv#1#2{%
	\edef\pgfplots@loc@TMPa{#1}%
	\ifx\pgfplots@loc@TMPa\pgfutil@empty
		\expandafter\edef\csname pgfplotspointouternormalvectorofaxis@v@\pgfplotspointonorientedsurfaceA\endcsname{#2}%
	\else
		\expandafter\edef\csname pgfplotspointouternormalvectorofaxis@v@#1\endcsname{#2}%
	\fi
}%

% Defines \pgfplotsretval to contain the 'v' value for an outer normal
% vector (if there is one known). If there is no such value,
% \pgfplotsretval will be empty.
% #1 a three-character-string
\def\pgfplotspointouternormalvectorofaxisgetv#1{%
	\edef\pgfplots@loc@TMPa{#1}%
	\expandafter\pgfplotspointouternormalvectorofaxisgetv@\pgfplots@loc@TMPa\relax\relax\relax\relax
}
\def\pgfplotspointouternormalvectorofaxisgetv@#1#2#3\relax{%
	\pgfutil@ifundefined{pgfplotspointouternormalvectorofaxis@v@#1#2#3}{%
		% no value found so far.
		\if#1v%
			\def\pgfplotsretval{x}%
		\else
			\if#2v%
				\def\pgfplotsretval{y}%
			\else
				\def\pgfplotsretval{z}%
			\fi
		\fi
		\pgfutil@ifundefined{pgfplotspointouternormalvectorofaxis@v@\pgfplotsretval}{%
			\let\pgfplotsretval\pgfutil@empty
		}{%
			\edef\pgfplotsretval{\csname pgfplotspointouternormalvectorofaxis@v@\pgfplotsretval\endcsname}%
		}%
	}{%
		\edef\pgfplotsretval{\csname pgfplotspointouternormalvectorofaxis@v@#1#2#3\endcsname}%
	}%
}%

% invokes #2 if the outer normal for the axis #1 (identified by a
% three-character-string) depends on a coordinate on that axis and #3
% otherwise.
%
% Overwrite in subclasses if necessary.
\def\pgfplotspointouternormalvectorofaxis@ifdependson@v#1#2#3{#3}

% FIXME : this doesn't work if one of the three characters is '2' (for
% center)
\def\pgfplotspointouternormalvectorofaxis@#1#2#3\relax{%
	\if v#1%
		\def\pgfplots@loc@point@orthogonal@to@v##1##2{%
			\pgfplotsqpointxyz{0}{##1}{##2}%
		}%
		\def\pgfplots@loc@char@for@baxis{#2}%
		\def\pgfplots@loc@char@for@naxis{#3}%
		\def\pgfplots@loc@baxis{y}%
		\def\pgfplots@loc@naxis{z}%
	\else
		\if v#2%
			\def\pgfplots@loc@point@orthogonal@to@v##1##2{%
				\pgfplotsqpointxyz{##1}{0}{##2}%
			}%
			\def\pgfplots@loc@char@for@baxis{#1}%
			\def\pgfplots@loc@char@for@naxis{#3}%
			\def\pgfplots@loc@baxis{x}%
			\def\pgfplots@loc@naxis{z}%
		\else
			\def\pgfplots@loc@point@orthogonal@to@v##1##2{%
				\pgfplotsqpointxyz{##1}{##2}{0}%
			}%
			\def\pgfplots@loc@char@for@baxis{#1}%
			\def\pgfplots@loc@char@for@naxis{#2}%
			\def\pgfplots@loc@baxis{x}%
			\def\pgfplots@loc@naxis{y}%
		\fi
	\fi
	\if0\pgfplots@loc@char@for@baxis%
		% this means : the '##1' direction of the surface
		% orthogonal to the 'v' vector is on the lower axis
		% limit. Since I need a vector pointing to the OUTSIDE of
		% the axis, I need sign = -1
		\def\pgfplots@loc@baxissign{-}%
	\else
		% in this case, the OUTSIDE area requires a plus sign - the b
		% axis already points to the inside.
		\def\pgfplots@loc@baxissign{+}%
	\fi
	\pgfplotsmath@ifzero{\csname pgfplots@\pgfplots@loc@baxis @veclength\endcsname}{%
		\def\pgfplots@loc@baxissign{0}%
		\def\pgfplots@loc@baxisscale{0}%
	}{%
		\edef\pgfplots@loc@baxisscale{\pgfplots@loc@baxissign\csname pgfplots@\pgfplots@loc@baxis @inverseveclength\endcsname}%
	}%
	%
	% Now the same game for the other axis:
	\if0\pgfplots@loc@char@for@naxis%
		% this means : the '##2' direction of the surface
		% orthogonal to the 'v' vector is on the lower axis
		% limit. Since I need a vector pointing to the OUTSIDE of
		% the axis, I need sign = -1
		\def\pgfplots@loc@naxissign{-}%
	\else
		% in this case, the OUTSIDE area requires a plus sign - the n
		% axis already points to the inside.
		\def\pgfplots@loc@naxissign{+}%
	\fi
	\pgfplotsmath@ifzero{\csname pgfplots@\pgfplots@loc@naxis @veclength\endcsname}{%
		\def\pgfplots@loc@naxissign{0}%
		\def\pgfplots@loc@naxisscale{0}%
	}{%
		\edef\pgfplots@loc@naxisscale{\pgfplots@loc@naxissign\csname pgfplots@\pgfplots@loc@naxis @inverseveclength\endcsname}%
	}%
	%
	% Ok, compute and normalize the vector:
	\pgf@process{%
		\pgfpointnormalised
			{\pgfplots@loc@point@orthogonal@to@v{\pgfplots@loc@baxisscale}{\pgfplots@loc@naxisscale}}%
	}%
	\endgroup
}%

% very-low-level internal routine. Never invoke it directly.
% @PRECONDITION:
% 	an \begingroup has been opened.
% @POSTCONDITION
% 	an \endgroup has been closed and \pgf@x and \pgf@y are assigned.
%
% This grouping stuff has the intention to keep the "plug" things
% local.
%
% #1#2#3 are the three characters for the line, delimited by \relax.
% #4: the argument supplied as coordinate on that axis.
% #5: the shift along the outer unit normal.
\def\pgfplotspointoutsideofaxis@#1#2#3\relax#4#5{%
	\if v#1%
		\pgfplotspointoutsideofaxis@plug@getlimit{y}{#2}\let\pgfplots@loc@TMPa=\pgfmathresult
		\pgfplotspointonorientedsurfaceabsetupforsety{\pgfplots@loc@TMPa}{#2}%
		%
		\pgfplotspointonorientedsurfaceabsetupfor xzy%
		\pgfplotspointoutsideofaxis@plug@trafo{x}{#4}\let\pgfplots@loc@A=\pgfmathresult
		\ifpgfplots@threedim
			\pgfplotspointoutsideofaxis@plug@getlimit{z}{#3}\let\pgfplots@loc@B=\pgfmathresult
		\else
			\def\pgfplots@loc@B{0}%
		\fi
	\else
		\if v#2%
			\ifpgfplots@threedim
				\pgfplotspointoutsideofaxis@plug@getlimit{z}{#3}\let\pgfplots@loc@TMPa=\pgfmathresult
			\else
				\def\pgfplots@loc@TMPa{0}%
			\fi
			\pgfplotspointonorientedsurfaceabsetupforsetz{\pgfplots@loc@TMPa}{#3}%
			%
			\pgfplotspointonorientedsurfaceabsetupfor yxz%
			\pgfplotspointoutsideofaxis@plug@trafo{y}{#4}\let\pgfplots@loc@A=\pgfmathresult
			\pgfplotspointoutsideofaxis@plug@getlimit{x}{#1}\let\pgfplots@loc@B=\pgfmathresult
		\else
			\pgfplotspointoutsideofaxis@plug@getlimit{x}{#1}\let\pgfplots@loc@TMPa=\pgfmathresult
			\pgfplotspointonorientedsurfaceabsetupforsetx{\pgfplots@loc@TMPa}{#1}%
			%
			\pgfplotspointonorientedsurfaceabsetupfor zyx%
			\ifpgfplots@threedim
				\pgfplotspointoutsideofaxis@plug@trafo{z}{#4}\let\pgfplots@loc@A=\pgfmathresult
			\else
				\def\pgfplots@loc@A{0}%
			\fi
			\pgfplotspointoutsideofaxis@plug@getlimit{y}{#2}\let\pgfplots@loc@B=\pgfmathresult
		\fi
	\fi
	%
	% read dimen argument #5:
	\afterassignment\pgfplots@gobble@until@relax
	\pgf@xa=#5pt\relax
	\edef\pgfplots@loc@distalong@normal{\pgf@sys@tonumber\pgf@xa}%
	%
	%
	\pgf@process{%
		\pgfpointadd
			{\pgfplotspointonorientedsurfaceab{\pgfplots@loc@A}{\pgfplots@loc@B}}
			{%
				\pgfplotspointouternormalvectorofaxissetv{#1#2#3}{\pgfplots@loc@A}%
				\pgfqpointscale
					{\pgfplots@loc@distalong@normal}%
					{\pgfplotspointouternormalvectorofaxis{#1#2#3}}%
			}%
	}%
	\endgroup
}%
%--------------------------------------------------
% \def\pgfplotspointoutsideofaxis@#1#2#3\relax#4#5{%
% 	\if v#1%
% 		\def\pgfplots@loc@point@orthogonal@to@v{%
% 			\pgfplotspointoutsideofaxis@plug@trafo{x}{#4}\let\pgfplots@loc@TMPa=\pgfmathresult
% 			\pgfplotspointoutsideofaxis@plug@getlimit{y}{#2}\let\pgfplots@loc@TMPb=\pgfmathresult
% 			\ifpgfplots@threedim
% 				\pgfplotspointoutsideofaxis@plug@getlimit{z}{#3}\let\pgfplots@loc@TMPc=\pgfmathresult
% 			\else
% 				\def\pgfplots@loc@TMPc{0}%
% 			\fi
% 			\pgfplotsqpointxyz{\pgfplots@loc@TMPa}{\pgfplots@loc@TMPb}{\pgfplots@loc@TMPc}%
% 		}%
% 	\else
% 		\if v#2%
% 			\def\pgfplots@loc@point@orthogonal@to@v{%
% 				\pgfplotspointoutsideofaxis@plug@trafo{y}{#4}\let\pgfplots@loc@TMPa=\pgfmathresult
% 				\pgfplotspointoutsideofaxis@plug@getlimit{x}{#1}\let\pgfplots@loc@TMPb=\pgfmathresult
% 				\ifpgfplots@threedim
% 					\pgfplotspointoutsideofaxis@plug@getlimit{z}{#3}\let\pgfplots@loc@TMPc=\pgfmathresult
% 				\else
% 					\def\pgfplots@loc@TMPc{0}%
% 				\fi
% 				\pgfplotsqpointxyz{\pgfplots@loc@TMPb}{\pgfplots@loc@TMPa}{\pgfplots@loc@TMPc}%
% 			}%
% 		\else
% 			\def\pgfplots@loc@point@orthogonal@to@v{%
% 				\ifpgfplots@threedim
% 					\pgfplotspointoutsideofaxis@plug@trafo{z}{#4}\let\pgfplots@loc@TMPa=\pgfmathresult
% 				\else
% 					\def\pgfplots@loc@TMPa{0}%
% 				\fi
% 				\pgfplotspointoutsideofaxis@plug@getlimit{x}{#1}\let\pgfplots@loc@TMPb=\pgfmathresult
% 				\pgfplotspointoutsideofaxis@plug@getlimit{y}{#2}\let\pgfplots@loc@TMPc=\pgfmathresult
% 				\pgfplotsqpointxyz{\pgfplots@loc@TMPb}{\pgfplots@loc@TMPc}{\pgfplots@loc@TMPa}%
% 			}%
% 		\fi
% 	\fi
% 	%
% 	% read dimen argument #5:
% 	\afterassignment\pgfplots@gobble@until@relax
% 	\pgf@xa=#5pt\relax
% 	\edef\pgfplots@loc@distalong@normal{\pgf@sys@tonumber\pgf@xa}%
% 	%
% 	%
% 	\pgf@process{%
% 		\pgfpointadd
% 			{\pgfplots@loc@point@orthogonal@to@v}
% 			{%
% 				\pgfqpointscale
% 					{\pgfplots@loc@distalong@normal}%
% 					{\pgfplotspointouternormalvectorofaxis{#1#2#3}}%
% 			}%
% 	}%
% 	\endgroup
% }%
%-------------------------------------------------- 

% Helper method for \pgfplotsqpointoutsideofaxis and its variants.
% #1: an axis (x,y or z)
% #2: o(\pgfplots@loc@TMPa - \pgfplots@loc@TMPb) ne of '0', '1' or '2' where
% 	0 == add lower #1 axis limit,
% 	1 == add upper #1 axis limit,
% 	2 == add nothing.
% #3: the value to add.
\def\pgfplotspointoutsideofaxis@getlimit@#1#2{%
	\if#20%
		\expandafter\let\expandafter\pgfmathresult\csname pgfplots@#1min\endcsname
	\else
		\if#21%
			\expandafter\let\expandafter\pgfmathresult\csname pgfplots@#1max\endcsname
		\fi
	\fi
}%

\newif\ifpgfplots@sloped
\pgfplots@slopedtrue % its only purpose is to *DEACTIVATE* the sloped transformation after it has been activated.
\newif\ifpgfplots@sloped@resets@nontranslations
\newif\ifpgfplots@sloped@allowupsidedown
\pgfkeys{
	/pgfplots/sloped/true/.code={\pgfplots@slopedtrue},
	/pgfplots/sloped/false/.code={\pgfplots@slopedfalse},
	/pgfplots/sloped/allow upside down/.is if=pgfplots@sloped@allowupsidedown,
	/pgfplots/sloped/allow upside down/.default=true,
	/pgfplots/sloped/execute for upside down/.initial=,
	/pgfplots/sloped/reset nontranslations/.is if=pgfplots@sloped@resets@nontranslations,
	/pgfplots/sloped/reset nontranslations/.default=true,
}
% Installs a rotation transformation matrix such that labels or
% whatever are aligned precisely in direction of one of the two/three
% coordinate directions.
%
% \pgfplotstransformtoaxisdirection[<options>]{<axis char>}
% 
% <axis char>: the coordinate direction (one of x,y or z)
%
% The code is pretty much the same as \pgftransformlineattime, except
% that the computation is considerably simpler as axis directions are
% a well known quantity.
%
% This command uses \ifpgfplots@sloped@allowupsidedown (=false) and
% \ifpgfplots@sloped@resets@nontranslations (= true). The default
% setting is reinitialised before options are processed
\def\pgfplotstransformtoaxisdirection{%
	\pgfutil@ifnextchar[{\pgfplotstransformtoaxisdirection@}{\pgfplotstransformtoaxisdirection@[]}%
}%
\def\pgfplotstransformtoaxisdirection@[#1]#2{%
	\pgfplots@sloped@allowupsidedownfalse
	\pgfplots@sloped@resets@nontranslationstrue
	%
	\def\pgfplots@loc@TMPa{#1}%
	\ifx\pgfplots@loc@TMPa\pgfutil@empty
	\else
		\pgfqkeys{/pgfplots/sloped}{#1}%
	\fi
	\ifpgfplots@sloped
	%
	\ifpgfplots@sloped@resets@nontranslations
		\pgftransformresetnontranslations
	\fi
	%
	% compute unit length vector pointing into the direction of
	% '#1#2#3':
	\pgfqpointscale{\csname pgfplotsunit#2invlength\endcsname}{\csname pgfplotspointunit#2\endcsname}%
	%
	\ifdim\pgf@x<0pt%   
		% oh. upside down.
		\pgfkeysvalueof{/pgfplots/sloped/execute for upside down}%
		\ifpgfplots@sloped@allowupsidedown
		\else
			% do not allow upside down labels:
			\global\pgf@x=-\pgf@x%
			\global\pgf@y=-\pgf@y%
		\fi
	\fi%
	%
	\pgf@ya=-\pgf@y%
	% set up rotation matrix 
	%  [ cos(alpha) sin(alpha); 
	%   -sin(alpha) cos(alpha) ]
	% where cos(alpha) = n_x and sin(alpha) = n_y:
	\pgftransformcm%
	{\pgf@sys@tonumber{\pgf@x}}{\pgf@sys@tonumber{\pgf@y}}%
	{\pgf@sys@tonumber{\pgf@ya}}{\pgf@sys@tonumber{\pgf@x}}{\pgfpointorigin}%
	\fi
}


% Adds a further, temporary anchor to every node which will be
% processed. The anchor will be named '#3'. It is placed such that
% 1. the node's center is on a line in direction of the inwards normal
% vector of the axis line denoted by '#2' and the 'at' position of the node,
% 2. the node does not intrude the axis.
%
% #1: either x,y or z the direction which varies
% #2: a three-char-string uniquely identifying the axis line.
%   The parameter '#1' is redundand: it is the same as the 'v'
%   character in '#2'.
% #3: the newly defined achor name.
%
% @see \pgfplotsdeclareborderanchorforticklabelaxis
\def\pgfplotsdeclareborderanchorforaxis#1#2#3{%
	%
	%
	\pgfdeclaregenericanchor{#3}{\pgfplots@borderanchor@for@axis{#1}{#2}{##1}}
	% 
	% This variant will ALWAYS be placed on the boundary of the node.
	% It is deprecated, I am keeping it for some time....
	\pgfdeclaregenericanchor{#3*}{%
		\csname pgf@anchor@##1@border\endcsname{%
			\pgf@process{%
				%
				% I want to rotate the node FIRST, then 
				% I'd like to get the boundary anchor! 
				%
				% My idea: apply the INVERSE transformation
				% matrix, then compute the boundary anchor.
				%
				% As soon as pgf draws the node, the
				% transformation matrix will be applied and
				% everything is fine.
				\pgfutil@ifundefined{pgfreferencednodename}{%
					% use given transformation matrix.
				}{%
					\ifx\pgfreferencednodename\pgfutil@empty
						% just use the given transformation matrix - we are
						% typesetting an unlabeled node.
					\else
						\pgfsettransform{\csname pgf@sh@nt@\pgfreferencednodename\endcsname}%
					\fi
				}%
				\pgftransforminvert
				%
				% This here is the anchor as such.
				\pgfqpointscale{-1}{\pgfplotspointouternormalvectorofaxis{#2}}%
				%
				\pgf@pos@transform\pgf@x\pgf@y
			}%
		}%
	}%
}%

% this does the work for \pgfplotsdeclareborderanchorforaxis.
%
% It depends on \pgfplotspointunit[xyz] and
% \pgfplotspointouternormalvectorofaxis
%
% #1: either x,y or z the direction which varies
% #2: a three-char-string uniquely identifying the axis line.
%   The parameter '#1' is redundand: it is the same as the 'v'
%   character in '#2'.
% #3: the shape, provided as argument by the pgf routine invoking the
% anchor.
\def\pgfplots@borderanchor@for@axis#1#2#3{%
	\begingroup
	\pgfutil@ifundefined{pgfreferencednodename}{%
		% use given transformation matrix.
	}{%
		\ifx\pgfreferencednodename\pgfutil@empty
			% just use the given transformation matrix - we are
			% typesetting an unlabeled node.
		\else
			\pgfsettransform{\csname pgf@sh@nt@\pgfreferencednodename\endcsname}%
		\fi
	}%
	% I only need to apply the trafo matrix to direction vectors. Eliminate
	% shifts.
	\pgf@pt@x=0pt
	\pgf@pt@y=0pt
	%
	% I'll apply the inverse transformation matrix to direction
	% vectors. To ensure the relative position of these vectors
	% and the anchors of the node, I have to invert the matrix:
	\pgftransforminvert
	%
	%
	% This here is the normal direction (points to the axis)
	\pgfqpointscale{-1}{\pgfplotspointouternormalvectorofaxis{#2}}%
	%
	% we apply the inverse CM onto it here:
	\pgf@pos@transform\pgf@x\pgf@y
	\edef\pgfplots@tmp@normaldir{\global\pgf@x=\the\pgf@x\space\global\pgf@y=\the\pgf@y\space}%
	% 
	% Now:
	% auto-determine the canonical (north, north east etc) anchor
	% at which the node touches the axis (remember: the axis is to
	% be found in direction of the normal vector).  If we choose
	% this anchor, we *won't* penetrate the axis!
	%
	% This is a heuristicial procedure.
	%
	\def\pgfplots@thresh{0.17pt }% 80 degrees
	%\def\pgfplots@thresh{0.3pt }%
	%\def\pgfplots@thresh{0.707pt }% 45 degrees
	\ifdim\pgf@y>0pt
		\ifdim\pgf@y>\pgfplots@thresh
			% only north anchor
			\def\pgfplots@ycomp{north}%
		\else
			\def\pgfplots@ycomp{}%
		\fi
	\else
		\ifdim\pgf@y<-\pgfplots@thresh
			\def\pgfplots@ycomp{south}%
			% south anchor
		\else
			\def\pgfplots@ycomp{}%
		\fi
	\fi
	\ifdim\pgf@x>0pt
		\ifdim\pgf@x>\pgfplots@thresh
			\def\pgfplots@xcomp{east}%
		\else
			\def\pgfplots@xcomp{}%
		\fi
	\else
		\ifdim\pgf@x<-\pgfplots@thresh
			\def\pgfplots@xcomp{west}%
		\else
			\def\pgfplots@xcomp{}%
		\fi
	\fi
	\edef\pgfplots@anchor{%
		\pgfplots@ycomp
		\ifx\pgfplots@ycomp\pgfutil@empty
		\else
			\ifx\pgfplots@xcomp\pgfutil@empty
			\else
				\space
			\fi
		\fi
		\pgfplots@xcomp}%
	%
	%
	% Now, I'd like the 'center' of the node on one line with the
	% 'at={}' coordinate at which it shall be placed!
	% This can be done as follows:
	%
	% Now, compute two lines:
	% 1. a line parallel to the #1 axis which goes
	% through our recently identified anchor,
	%   { x = x_a + r_1 * (#1 axis direction)
	% 2. a line from center in direction of the normal,
	% 	{ x = x_c + r_2 n, r in R }
	%
	% Calculate the intersection point and return it! This
	% involves a lot of arithmetics :-(
	%
	% compute (unit#1 - normal):
	\pgfplots@tmp@normaldir
	\pgf@xb=\pgf@x
	\pgf@yb=\pgf@y
	%
	% and the axis direction (in fact, I use -axis dir. But that
	% doesn't matter).
	% Scale unit vector to length 1 to improve conditioning:
	\pgfqpointscale
		{\csname pgfplotsunit#1invlength\endcsname}
		{\csname pgfplotspointunit#1\endcsname}%
	\pgf@xa=\pgf@x 
	\pgf@ya=\pgf@y
	\pgf@pos@transform\pgf@xa\pgf@ya
	%
	% verify that |n^T d | 
	\pgf@xc=\pgf@sys@tonumber\pgf@xa\pgf@xb
	\advance\pgf@xc by\pgf@sys@tonumber\pgf@ya\pgf@yb
	\ifdim\pgf@xc<0pt \pgf@xc=-\pgf@xc \fi
	\ifdim\pgf@xc<0.8pt
		% ok. 'n' and 'd' are not parallel.
		%
		\edef\pgfplots@LEQ{%
		% solve linear system
		% 	a11 a12
		% 	a21 a22
			{\pgf@sys@tonumber\pgf@xb}{\pgf@sys@tonumber\pgf@xa}%
			{\pgf@sys@tonumber\pgf@yb}{\pgf@sys@tonumber\pgf@ya}%
		}%
		% 
		\pgf@sh@reanchor{#3}{center}%
		\edef\pgfplots@loc@center{\global\pgf@x=\the\pgf@x\space\global\pgf@y=\the\pgf@y\space}%
		%
		% apply inverse matrix to right-hand-side (and compute RHS):
		\pgfpointdiff% {<start>}{<end>} -> computes <end> - <start>
			{\pgfplots@loc@center}%
			{\pgf@sh@reanchor{#3}{\pgfplots@anchor}}%
		\edef\pgfplots@RHS{{\pgf@sys@tonumber\pgf@x}{\pgf@sys@tonumber\pgf@y}}%
		%
		\pgfutilsolvetwotwoleq{\pgfplots@LEQ}{\pgfplots@RHS}%
		\def\pgfplots@extract##1##2{%
			\def\pgfplots@r{##1}%
		}%
		\expandafter\pgfplots@extract\pgfmathresult
		% GOT IT!
		%
		% compute x_c + r*n:
		\pgfpointadd
			{\pgfplots@loc@center}%
			{\pgfqpointscale{\pgfplots@r}{\pgfplots@tmp@normaldir}}%
	\else
		\message{^^JPGFPlots warning: The ticklabel anchor cannot be determined, the normal vector -(\the\pgf@xb,\the\pgf@yb) and the unit #1 vector (\the\pgf@xa,\the\pgf@ya) are almost parallel (abs(cos(angle)) = \the\pgf@xc)!^^J}%
		% Something went awry: normal and unit#1 are almost parallel!?
		% just use the determined anchor.
		\def\pgfplots@r{0}%
		\pgf@sh@reanchor{#3}{\pgfplots@anchor}%
	\fi
%\message{==========>>>>>>>>>> I got finally (\the\pgf@x,\the\pgf@y). <<<<<<<<<===================}%
	\pgf@process{}% <- transport outside of group
	\endgroup
}%

% Takes azimuth (horizontal angle) '#1' and elongation (vertical
% angle) '#2' (both in degrees) and computes 
% x,y and z vectors which define the view in the direction
% defined by '#1' and '#2'.
%
% 'azimuth' means a rotation around the viewport's x axis. 'elongation' means
% a rotation around the original coordinate system's z axis.
%
% The method works by computing 
% Az = [ cos(azimuth) -sin(azimuth) 0; ...
%     sin(azimuth) cos(azimuth) 0; ...
%     0 0 1 ];
% 
%
% Ax = [ 1 0 0; ...
%     0 cos(elevation) -sin(elevation) ;...
%     0 sin(elevation) cos(elevation) ];
%
% v= Ax * Az;
% = [ ...
% 	cosaz  -sinaz cosel  sinaz sinel; ...
% 	sinaz  cosaz cosel   -sinel cosaz; ...
% 	0	  sinel         cosel ];
%
% Then, we use the rotated XZ plane as viewport, that means 
%   xvec = v * [1 0 0]' = <first column of v>
%   zvec = v * [0 0 1]' = <third column of v>
% and we define the projection onto the twodimensional surface
% spanned by 'xvec' and 'zvec' as
%   P( q ) = [ q^T xvec,  q^T zvec ]'
% for q in R^3.
% As a consequence, we compute the three unit vectors as
%  x = P( [1 0 0] )
%  	 = [ cosaz,  sinaz sinel ]'
%  y = P( [0 1 0] )
%    = [ sinaz,  -sinel cosaz ]'
%  z = P( [0 0 1] )
%    = [ 0,  cosel]'
%
% Furthermore, the 3D view vector which points into the direction of the view
% is
%   n = v * [0 1 0 ]' = <second column of v> =  [-sinaz cosel,  cosaz cosel,  sinel]' 
% because the normal view point was the XZ plane with y as its normal
% vector.
% The 3D vector n is returned by this routine as well - it is
% necessary for some kind of z buffering (determining what is
% foreground and what is background).
%
% INPUT:
% - #1 : azimuth ("yaw")
% - #2 : elevation ("pitch")
% OUTPUT:
% - #3 : a macro which will be set to '1' if and only if 
%      the viewport is the standard XY axis (i.e. azimuth=0, elevation=90).
% - [xyz] vectors,
%   \pgfplots@[xyz]@veclength,
%   \pgfplots@[xyz]@inverseveclength
%   are set properly
%   \pgfplots@view@dir@threedim@[xyz] will contain the three components
%   of 'n' (without the suffix 'pt', but in units of 'pt').
\def\pgfplotssetaxesfromazel#1#2#3{%
	\begingroup
	\pgfmathparse{#1}%
	\let\pgfplots@az=\pgfmathresult
	\pgfmathparse{#2}%
	\edef\pgfplots@el{-\pgfmathresult}%
	\pgfmathsin@{\pgfplots@az}%
	\let\sinaz=\pgfmathresult
	\pgfmathcos@{\pgfplots@az}%
	\let\cosaz=\pgfmathresult
	\pgfmathsin@{\pgfplots@el}%
	\let\sinel=\pgfmathresult
	\pgfmathcos@{\pgfplots@el}%
	\let\cosel=\pgfmathresult
	% x:
	\pgfmathmultiply@{\sinaz}{\sinel}%
	\xdef\pgfplots@glob@TMPa{\noexpand\pgfqpoint{\cosaz pt}{\pgfmathresult pt}}%
	% y:
	\pgfmathmultiply@{-\sinel}{\cosaz}%
	\xdef\pgfplots@glob@TMPb{\noexpand\pgfqpoint{\sinaz pt}{\pgfmathresult pt}}%
	% z:
	\xdef\pgfplots@glob@TMPc{\noexpand\pgfqpoint{0pt}{\cosel pt}}%
	%
	\pgfkeysgetvalue{/pgfplots/x dir/value}\pgfplots@loc@dirvalue@x
	\pgfkeysgetvalue{/pgfplots/y dir/value}\pgfplots@loc@dirvalue@y
	\pgfkeysgetvalue{/pgfplots/z dir/value}\pgfplots@loc@dirvalue@z
	\if r\pgfplots@loc@dirvalue@x
		\t@pgfplots@toka=\expandafter{\pgfplots@glob@TMPa}%
		\xdef\pgfplots@glob@TMPa{\noexpand\pgfqpointscale{-1}{\the\t@pgfplots@toka}}%
	\fi
	\if r\pgfplots@loc@dirvalue@y
		\t@pgfplots@toka=\expandafter{\pgfplots@glob@TMPb}%
		\xdef\pgfplots@glob@TMPb{\noexpand\pgfqpointscale{-1}{\the\t@pgfplots@toka}}%
	\fi
	\if r\pgfplots@loc@dirvalue@z
		\t@pgfplots@toka=\expandafter{\pgfplots@glob@TMPc}%
		\xdef\pgfplots@glob@TMPc{\noexpand\pgfqpointscale{-1}{\the\t@pgfplots@toka}}%
	\fi
	%
	% Process 'plot box ratio':
	\def\pgfplots@extract@plot@box@ratio##1##2##3##4\pgfplots@EOI{%
		\pgfmathparse{##1}\let\pgfplots@plotboxratio@x=\pgfmathresult
		\pgfmathparse{##2}\let\pgfplots@plotboxratio@y=\pgfmathresult
		\pgfmathparse{##3}\let\pgfplots@plotboxratio@z=\pgfmathresult
	}%
	\def\pgfplots@extract@plot@box@ratio@spaces##1 ##2 ##3 ##4\pgfplots@EOI{%
		\pgfplots@extract@plot@box@ratio{##1}{##2}{##3}{##4}\pgfplots@EOI
	}%
	\pgfkeysgetvalue{/pgfplots/plot box ratio}\pgfplots@loc@TMPa
	% Auto-determine input format which is either '{x}{y}{z}' or 'x y z'
	\def\pgfplots@loc@TMPb{%
		\pgfutil@ifnextchar\bgroup{%
			\pgfplots@loc@tmptrue
			\pgfplots@gobble@until@EOI
		}{%
			\pgfplots@loc@tmpfalse
			\pgfplots@gobble@until@EOI
		}%
	}%
	\expandafter\pgfplots@loc@TMPb\pgfplots@loc@TMPa\pgfplots@EOI
	\ifpgfplots@loc@tmp
		% Ah- braces format.
		\edef\pgfplots@loc@TMPa{\pgfplots@loc@TMPa{1}{1}{1}}%
		\expandafter\pgfplots@extract@plot@box@ratio\pgfplots@loc@TMPa\pgfplots@EOI
	\else
		% Ah- space-separated
		\edef\pgfplots@loc@TMPa{\pgfplots@loc@TMPa\space 1 1 1}%
		\expandafter\pgfplots@extract@plot@box@ratio@spaces\pgfplots@loc@TMPa\pgfplots@EOI
	\fi
	%
	% process it:
	\ifdim\pgfplots@plotboxratio@x pt=1pt
	\else
		\t@pgfplots@toka=\expandafter{\pgfplots@glob@TMPa}%
		\xdef\pgfplots@glob@TMPa{\noexpand\pgfqpointscale{\pgfplots@plotboxratio@x}{\the\t@pgfplots@toka}}%
	\fi
	\ifdim\pgfplots@plotboxratio@y pt=1pt
	\else
		\t@pgfplots@toka=\expandafter{\pgfplots@glob@TMPb}%
		\xdef\pgfplots@glob@TMPb{\noexpand\pgfqpointscale{\pgfplots@plotboxratio@y}{\the\t@pgfplots@toka}}%
	\fi
	\ifdim\pgfplots@plotboxratio@z pt=1pt
	\else
		\t@pgfplots@toka=\expandafter{\pgfplots@glob@TMPc}%
		\xdef\pgfplots@glob@TMPc{\noexpand\pgfqpointscale{\pgfplots@plotboxratio@z}{\the\t@pgfplots@toka}}%
	\fi
	%
	% n (3D!)
	\pgfmathmultiply@{-\sinaz}{\cosel}%
	\let\pgfmathresultNx=\pgfmathresult
	\pgfmathmultiply@{\cosaz}{\cosel}%
	\xdef\pgfplots@glob@TMPd{{\pgfmathresultNx}{\pgfmathresult}{\sinel}}%
	\endgroup
%\message{Setting x,y and z from {#1}{#2} to^^J x = \meaning\pgfplots@glob@TMPa,^^J y = \meaning\pgfplots@glob@TMPb,^^J z = \meaning\pgfplots@glob@TMPc,^^J n = \pgfplots@glob@TMPd.^^J}%
	\pgfsetxvec{\pgfplots@glob@TMPa}%
	\pgfsetyvec{\pgfplots@glob@TMPb}%
	\pgfsetzvec{\pgfplots@glob@TMPc}%
	\def\pgfplots@loc@TMPa##1##2##3{%
		\def\pgfplots@view@dir@threedim@x{##1}%
		\def\pgfplots@view@dir@threedim@y{##2}%
		\def\pgfplots@view@dir@threedim@z{##3}%
	}%
	\expandafter\pgfplots@loc@TMPa\pgfplots@glob@TMPd\relax
	\def#3{0}%
	\pgfplots@scale@plotbox@to@widthheight
}%

\def\message@pgfplots@units{%
	\begingroup
	\pgfmathparse{veclen(\pgf@zx,\pgf@zy)}\let\Z=\pgfmathresult
	\ifdim\Z pt=0pt
		\def\Z{1}%
	\fi
	\pgfmathparse{veclen(\pgf@xx,\pgf@xy)/\Z}\let\X=\pgfmathresult
	\pgfmathparse{veclen(\pgf@yx,\pgf@yy)/\Z}\let\Y=\pgfmathresult
	\message{^^J 
		x = (\the\pgf@xx,\the\pgf@xy),^^J 
		y =(\the\pgf@yx,\the\pgf@yy),^^J 
		z = (\the\pgf@zx,\the\pgf@zy),^^J 
		\expandafter\ifx\csname pgfplots@view@dir@threedim@x\endcsname\relax
		\else
			n = (\pgfplots@view@dir@threedim@x,\pgfplots@view@dir@threedim@y,\pgfplots@view@dir@threedim@z),^^J
		\fi
		unit vector ratio=[\X\space\Y\space 1],^^J}%
	\endgroup
}%

% Takes the current plot box, defined by the actual PGF x,y and z unit
% vectors, and re-scales it such that it fits into the 
% width and height of the axis (as they have been provided by the
% user).
%
% @see \pgfplots@scale@axisbox@to@widthheight
% @see\pgfplots@scaleaxes@to@BB
\def\pgfplots@scale@plotbox@to@widthheight{%
	\pgfplots@initsizes@get@width@withoutlabels
	\let\pgfplots@loc@TMPa=\pgfmathresult
	\pgfplots@initsizes@get@height@withoutlabels
	\edef\pgfplots@loc@TMPa{{\pgfplots@loc@TMPa}{\pgfmathresult}}%
	\let\pgfplots@BB@for@plotbox=\pgfplots@BB@for@plotbox@relative
	\let\pgfplots@BB@for@plotbox@compute@post@scales=\pgfplots@BB@for@plotbox@compute@post@scales@relative
	\expandafter\pgfplots@scaleaxes@to@BB\pgfplots@loc@TMPa
}


% A variant of \pgfplots@scale@plotbox@to@widthheight which does not
% use the given x,y,z vectors to define the plot box. Instead, it uses
% the lower and upper axis limits.
\def\pgfplots@scale@axisbox@to@widthheight{%
	\pgfplots@initsizes@get@width@withoutlabels
	\let\pgfplots@loc@TMPa=\pgfmathresult
	\pgfplots@initsizes@get@height@withoutlabels
	\edef\pgfplots@loc@TMPa{{\pgfplots@loc@TMPa}{\pgfmathresult}}%
	\let\pgfplots@BB@for@plotbox=\pgfplots@BB@for@plotbox@computelimits
	\let\pgfplots@BB@for@plotbox@compute@post@scales=\pgfplots@BB@for@plotbox@compute@post@scales@NOP
	\expandafter\pgfplots@scaleaxes@to@BB\pgfplots@loc@TMPa
}


% Takes the current PGF x,y and z unit vectors and scales them such
% that the bounding box of the final image has width #1 and height #2.
%
% The relative length of the input vectors is important for the 3D case: it
% will be scaled as-is. 
%
% PRECONDITION
% 	- the x, y and z unit vectors have been set to the proper
% 	DIRECTIONS. Their relative vector lengths are set-up properly
% 	(i.e. y is twice as large as x and half as large as z or so).
%	- \pgfplots@[xyz]@veclength and
%	  \pgfplots@[xyz]@inverseveclength
%	  are set correctly.
%	- the \ifpgfplots@threedim boolean is set.
%	- the data limits have been initialised and transformed according
%	to the data transformation.
% 
% POSTCONDITION
% 	- the unit vectors have been re-scaled such that the final plot
% 	has the desired dimensions.
% 	- the @veclength and @inverseveclength have been re-scaled as
% 	well.
\def\pgfplots@scaleaxes@to@BB#1#2{%
%\message{before scaling:}\message@pgfplots@units
	\if0\pgfplots@scale@mode@choice
		% scale mode=auto
		\def\pgfplots@scale@mode@choice{2}% stretch to fill
	\fi
	\if1\pgfplots@scale@mode@choice
		% scale mode=none
	\else
		\pgfplots@scaleaxes@to@BB@{#1}{#2}%
	\fi
	% FIXME 
	% I suppose I should call \pgfplotsgetnormalforcurrentview now?
	\pgfplots@computeunitvectorlengths
%\message{after scaling:}\message@pgfplots@units
}%
\def\pgfplots@BB@for@plotbox@relative{%
	% We just need the
	% relative sizes, i.e.
	%  "0" == lower axis limit
	%  "1" == upper axis limit
	%
	\ifpgfplots@threedim
		\pgfpathmoveto{\pgfqpointxyz000}%
		\pgfpathmoveto{\pgfqpointxyz001}%
		\pgfpathmoveto{\pgfqpointxyz010}%
		\pgfpathmoveto{\pgfqpointxyz011}%
		\pgfpathmoveto{\pgfqpointxyz100}%
		\pgfpathmoveto{\pgfqpointxyz101}%
		\pgfpathmoveto{\pgfqpointxyz110}%
		\pgfpathmoveto{\pgfqpointxyz111}%
	\else
		\pgfpathmoveto{\pgfqpointxy00}%
		\pgfpathmoveto{\pgfqpointxy01}%
		\pgfpathmoveto{\pgfqpointxy10}%
		\pgfpathmoveto{\pgfqpointxy11}%
	\fi
}%
\let\pgfplots@BB@for@plotbox=\pgfplots@BB@for@plotbox@relative
\def\pgfplots@BB@for@plotbox@compute@post@scales@relative#1#2#3{%
	% Consequently, we have to multiply  with 1/(max-min):
	\pgfmathsubtract@{\pgfplots@xmax}{\pgfplots@xmin}%
	% compute 1/(xmax - xmin) in float for more recent versions (see /pgfplots/compat/scaling).
	% I observed that it is much more accurate 
	\pgfplotscoordmath{\pgfplots@compat@scaling@coordmath}{parsenumber}{\pgfmathresult}%
	\pgfplotscoordmath{\pgfplots@compat@scaling@coordmath}{op}{reciprocal}{{\pgfmathresult}}%
	\pgfplotscoordmath{\pgfplots@compat@scaling@coordmath}{tofixed}{\pgfmathresult}%
	\let#1=\pgfmathresult
	%
	\pgfmathsubtract@{\pgfplots@ymax}{\pgfplots@ymin}%
	\pgfplotscoordmath{\pgfplots@compat@scaling@coordmath}{parsenumber}{\pgfmathresult}%
	\pgfplotscoordmath{\pgfplots@compat@scaling@coordmath}{op}{reciprocal}{{\pgfmathresult}}%
	\pgfplotscoordmath{\pgfplots@compat@scaling@coordmath}{tofixed}{\pgfmathresult}%
	\let#2=\pgfmathresult
	%
	\ifpgfplots@threedim
		\pgfmathsubtract@{\pgfplots@zmax}{\pgfplots@zmin}%
		\pgfplotscoordmath{\pgfplots@compat@scaling@coordmath}{parsenumber}{\pgfmathresult}%
		\pgfplotscoordmath{\pgfplots@compat@scaling@coordmath}{op}{reciprocal}{{\pgfmathresult}}%
		\pgfplotscoordmath{\pgfplots@compat@scaling@coordmath}{tofixed}{\pgfmathresult}%
	\else
		\def\pgfmathresult{1}%
	\fi
	\let#3=\pgfmathresult
}%
\let\pgfplots@BB@for@plotbox@compute@post@scales=\pgfplots@BB@for@plotbox@compute@post@scales@relative
\def\pgfplots@BB@for@plotbox@computelimits{%
	\ifpgfplots@threedim
		\pgfpathmoveto{\pgfqpointxyz\pgfplots@xmin\pgfplots@ymin\pgfplots@zmin}%
		\pgfpathmoveto{\pgfqpointxyz\pgfplots@xmin\pgfplots@ymin\pgfplots@zmax}%
		\pgfpathmoveto{\pgfqpointxyz\pgfplots@xmin\pgfplots@ymax\pgfplots@zmin}%
		\pgfpathmoveto{\pgfqpointxyz\pgfplots@xmin\pgfplots@ymax\pgfplots@zmax}%
		\pgfpathmoveto{\pgfqpointxyz\pgfplots@xmax\pgfplots@ymin\pgfplots@zmin}%
		\pgfpathmoveto{\pgfqpointxyz\pgfplots@xmax\pgfplots@ymin\pgfplots@zmax}%
		\pgfpathmoveto{\pgfqpointxyz\pgfplots@xmax\pgfplots@ymax\pgfplots@zmin}%
		\pgfpathmoveto{\pgfqpointxyz\pgfplots@xmax\pgfplots@ymax\pgfplots@zmax}%
	\else
		\pgfpathmoveto{\pgfqpointxy\pgfplots@xmin\pgfplots@ymin}%
		\pgfpathmoveto{\pgfqpointxy\pgfplots@xmin\pgfplots@ymax}%
		\pgfpathmoveto{\pgfqpointxy\pgfplots@xmax\pgfplots@ymin}%
		\pgfpathmoveto{\pgfqpointxy\pgfplots@xmax\pgfplots@ymax}%
	\fi
}%
\def\pgfplots@BB@for@plotbox@compute@post@scales@NOP#1#2#3{%
	\let#1=\pgfutil@empty
	\let#2=\pgfutil@empty
	\let#3=\pgfutil@empty
}%
\def\pgfplots@scaleaxes@to@BB@#1#2{%
	\begingroup
	\pgfinterruptboundingbox
	% STEP 1: compute the bounding box for the plot box.
	\pgfplots@BB@for@plotbox
	%
	% TMPa = width
	\pgf@xa=\pgf@pathmaxx
	\advance\pgf@xa by-\pgf@pathminx
	% TMPb = height
	\pgf@xb=\pgf@pathmaxy
	\advance\pgf@xb by-\pgf@pathminy
	\pgf@ya=#1\relax
	\pgf@yb=#2\relax
%\message{PGFPLOTS: the current unit vectors result in a UNIT BB of (\the\pgf@xa,\the\pgf@xb). Scaling it to (\the\pgf@ya,\the\pgf@yb)...}%
	\ifcase\pgfplots@scale@mode@choice
		% scale mode=auto  does not happen here
	\or
		% scale mode=none  does not happen here
	\or
		% scale mode=stretch to fill
		% Compute individual scaling factors for X and Y
		% such that the UNIT-BB will have size #1,#2:
		\pgfplotsutil@edef@invoke\pgfmathdivide@{%
			{\pgf@sys@tonumber\pgf@ya}%
			{\pgf@sys@tonumber\pgf@xa}%
		}%
		% TMPa = scalex
		\global\let\pgfplots@glob@TMPa=\pgfmathresult
		\pgfplotsutil@edef@invoke\pgfmathdivide@{%
			{\pgf@sys@tonumber\pgf@yb}%
			{\pgf@sys@tonumber\pgf@xb}%
		}%
		% TMPb = scaley
		\global\let\pgfplots@glob@TMPb=\pgfmathresult
		\global\let\pgfplots@glob@TMPc=\relax
	\or
		% scale mode=scale uniformly
		% compute ONE common scale for both, X and Y.
		%
		\pgfplotsutil@edef@invoke\pgfmathdivide@{%
			{\pgf@sys@tonumber\pgf@ya}%
			{\pgf@sys@tonumber\pgf@xa}%
		}%
		\global\let\pgfplots@glob@TMPa=\pgfmathresult
		\global\let\pgfplots@glob@TMPb=\pgfplots@glob@TMPa
		\global\let\pgfplots@glob@TMPc=\relax
		\ifdim\pgf@zy=0pt
			\ifdim\pgf@yx=0pt
				\pgfplots@prepare@vertical@rescaling@for@scale@uniformly@in@dir{y}\returninto\pgfplots@glob@TMPc
			\else
				\pgfplots@error@scale@uniformly@failed
			\fi
		\else
			\ifdim\pgf@zx=0pt
				\pgfplots@prepare@vertical@rescaling@for@scale@uniformly@in@dir{z}\returninto\pgfplots@glob@TMPc
			\else
				\pgfplots@error@scale@uniformly@failed
			\fi
		\fi
	\fi
	\pgfusepath{discard}%
	\endpgfinterruptboundingbox
	\endgroup
	% Ok, we know the W,H scalings now.
	%
	% But remember that we have worked with RELATIVE scales up to now.
	% We have to convert them now, by interpreting "1 == upper limit"
	% and "0 == lower limit" for every direction.
	%
	\pgfplots@BB@for@plotbox@compute@post@scales{\pgfplots@loc@TMPa}{\pgfplots@loc@TMPb}{\pgfplots@loc@TMPc}%
	%
	% ok. Now apply all scalings.
	% Let's hope all these temporary macros are still valid!
%\message{got scaleW = \pgfplots@glob@TMPa\space and scaleH = \pgfplots@glob@TMPb; scalex=\pgfplots@loc@TMPa, scaley=\pgfplots@loc@TMPb, scalez=\pgfplots@loc@TMPc.}%
	\pgf@xx=\pgfplots@glob@TMPa\pgf@xx
	\pgf@xy=\pgfplots@glob@TMPb\pgf@xy
	\pgf@xx=\pgfplots@loc@TMPa\pgf@xx
	\pgf@xy=\pgfplots@loc@TMPa\pgf@xy
	%
	\pgf@yx=\pgfplots@glob@TMPa\pgf@yx
	\pgf@yy=\pgfplots@glob@TMPb\pgf@yy
	\pgf@yx=\pgfplots@loc@TMPb\pgf@yx
	\pgf@yy=\pgfplots@loc@TMPb\pgf@yy
	%
	\ifpgfplots@threedim
		\pgf@zx=\pgfplots@glob@TMPa\pgf@zx
		\pgf@zy=\pgfplots@glob@TMPb\pgf@zy
		\pgf@zx=\pgfplots@loc@TMPc\pgf@zx
		\pgf@zy=\pgfplots@loc@TMPc\pgf@zy
	\fi
	\pgfplots@glob@TMPc
}%

\def\pgfplots@error@scale@uniformly@failed{%
	\pgfplots@error{Sorry, 'scale uniformly' failed because its actual implementation works only if y_x = 0 (for 2d axes) or if z_x = 0 (for 3d axes). The result will not fill the prescribed dimensions. For 2d axes, you may also want to consider the 'unit vector ratio' key}%
}%
\def\pgfplots@prepare@vertical@rescaling@for@scale@uniformly@in@dir#1\returninto#2{%
	% The strategy is as follows:
	% 1. I want to fit the axis into width #1 (\pgf@ya) and
	% height #1 (\pgf@yb).
	% 2. I want to MAINTAIN the unit vector ratio. 
	% 3. I want to MAINTAIN the unit vector directions.
	%
	% I already know the scaling factor to fit the width (it
	% is stored in \pgfplots@glob@TMPa = \pgfplots@glob@TMPb).
	% Let's call it "s".
	%
	% Consequently, a uniform scaling by "s" leads the image
	% height
	% h = s* (r_x * e_xy + r_y * e_yy + r_z * e_zy)
	% where r_i = (imax - imin). This here is essentially the
	% same as the bounding box computation above (at least for
	% standart orthographic 3D axes).
	%
	% What I want now is to enlarge the limits such that I
	% have BOTH, width #1 AND height #2, without obscuring the
	% unit vector ratio. Recall that width #1 is already
	% given.
	%
	% In my opinion the ONLY way to achieve this goal is to
	% modify axis limits for an axis whose unit vector is
	% parallel to the canvas y axis, i.e. e_i = (0,*). To see
	% this, remember that a rescaling of the other limits will
	% also modify the width.
	%
	% That means I have to introduce a SECOND scale s_z which
	% applies only to the Z unit vector (since e_z = (0,*) ).
	% If H = #2 is the desired height, I find the target
	% equation for s_z,
	%
	% H = s* r_x e_xy + s * r_y e_yy + s_z * s * r_z * e_zy
	% =>
	% s_z = ( H- s*r_x e_xy - s*r_y e_yy) / ( s * r_z * e_zy).
	%
	% Remember that 
	% s = \pgfplots@glob@TMPa
	% and
	% \pgfplots@glob@TMPa * \pgf@xb = s*h
	% 
	\pgf@xc=\csname pgfplots@#1max\endcsname\csname pgf@#1y\endcsname% FIXME : what if we are working with relative coords?
	\advance\pgf@xc by -\csname pgfplots@#1min\endcsname\csname pgf@#1y\endcsname
	%
	\advance\pgf@xb by-\pgf@xc
	\pgf@xb=\pgfplots@glob@TMPa\pgf@xb
	\advance\pgf@yb by-\pgf@xb
	\pgf@xb=\pgfplots@glob@TMPa\pgf@xc
	\pgfplotsutil@edef@invoke\pgfmathdivide@{%
		{\pgf@sys@tonumber\pgf@yb}%
		{\pgf@sys@tonumber\pgf@xb}%
	}%
	% Now, s_z = \pgfmathresult .
	%
	% Now, adjust the z limits.
	% Note that \pgfplots@apply@unit@vector@rescale@keep@size
	% has a slightly different context; it assumes that the
	% unit vector has been rescaled, not the axis limits.
	% Consequently, the inverse of the scaling factor enters.
	% Since \pgfplots@apply@unit@vector@rescale@keep@size
	% expects the inverse of the scale, we can provide
	% \pgfmathresult:
	\xdef#2{%
		\noexpand\pgfplots@apply@unit@vector@rescale@keep@size{#1}{\pgfmathresult}%
	}%
}

\def\pgfplots@computeunitvectorlengths{%
	\pgfplotsutil@edef@invoke\pgfmathveclen@{%
		{\pgf@sys@tonumber\pgf@xx}%
		{\pgf@sys@tonumber\pgf@xy}%
	}%
	\let\pgfplots@x@veclength=\pgfmathresult
	\pgfplotsmath@ifzero{\pgfplots@x@veclength}{%
		\def\pgfmathresult{infty}%
		% this case will be caught in \pgfplots@initsizes
	}{%
		\expandafter\pgfmath@basic@reciprocal@\expandafter{\pgfmathresult}%
	}%
	\let\pgfplots@x@inverseveclength=\pgfmathresult
	%
	\pgfplotsutil@edef@invoke\pgfmathveclen@{%
		{\pgf@sys@tonumber\pgf@yx}%
		{\pgf@sys@tonumber\pgf@yy}%
	}%
	\let\pgfplots@y@veclength=\pgfmathresult
	\pgfplotsmath@ifzero{\pgfplots@y@veclength}{%
		\def\pgfmathresult{infty}%
		% this case will be caught in \pgfplots@initsizes
	}{%
		\expandafter\pgfmath@basic@reciprocal@\expandafter{\pgfmathresult}%
	}%
	\let\pgfplots@y@inverseveclength=\pgfmathresult
	%
	\ifpgfplots@threedim
		\pgfplotsutil@edef@invoke\pgfmathveclen@{%
			{\pgf@sys@tonumber\pgf@zx}%
			{\pgf@sys@tonumber\pgf@zy}%
		}%
		\let\pgfplots@z@veclength=\pgfmathresult
		\pgfplotsmath@ifzero{\pgfplots@z@veclength}{%
			\def\pgfmathresult{infty}%
			% this case will be caught in \pgfplots@initsizes
		}{%
			\expandafter\pgfmath@basic@reciprocal@\expandafter{\pgfmathresult}%
		}%
		\let\pgfplots@z@inverseveclength=\pgfmathresult
	\fi
}%

% Defines \pgfplots@view@dir@threedim@[xyz] according to the actual
% configuration of x,y,z (2d) unit vectors, assuming the associated
% unit vectors form a right-handed-system.
%
% The algorithm works for standard three dimensional axes. It works as
% follows:
%
% First, observe that we have a normal direction N if all its
% multiples are on the mapped onto the same point in 2D canvas
% coordinates. In other words: all 3D coordinates which are mapped
% onto an arbitrary point in 2D canvas coordinates (take, for example,
% the origin (0,0)  ) are on a line in direction of N.
%
% We use this observation to compute the normal axis, i.e. we search
% for all points which are mapped onto the 2D canvas coordinate (0,0):
%  N_x e_xx + N_y e_yx + N_z e_zx = 0
%  N_x e_xy + N_y e_yy + N_z e_zy = 0.
% All solutions make up a linear space of dimension 1 (up to special
% cases). In the general case, we can chose an arbitrary  N_z != 0
% and reduce the linear system to
%  N_x e_xx + N_y e_yx = - N_z e_zx
%  N_x e_xy + N_y e_yy = - N_z e_zy.
% Choosing *any* N_z != 0, say, N_z=-1 (which corresponds to view
% from above) will lead to a vector parallel to the normal direction.
% But it might have the wrong sign.
%
% To find the correct sign for N, I have made several case
% distinctions to identify the cases when we have to multiply with -1.
% The key idea is to assume a right-handed-system of unit vectors;
% this is the condition which allows to determine the sign.
%
% Furthermore, I assume that e_z points to the top, i.e. that e_zy >0.
% Then, there are (mainly) four conditions on the signs of e_x and e_y
% which indicate that we are viewing from below and should switch the
% sign of N (keep in mind that our initial choice was N_z =-1, see above).
%
% The conditions can be identified by drawing a 3D box and
% identifying the corner which represents the lower left 3D limits.
%
% You can visualize these cases using
%--------------------------------------------------
% \pgfplotsset{
% 		separate axis lines,
% 		every outer x axis line/.append style= {-stealth},
% 		every outer y axis line/.append style= {-stealth},
% 		every outer z axis line/.append style= {-stealth},
% 		samples=2,shader=interp,title={view=\h,\v},
% 		domain=0:1,
% 		enlargelimits=false,
% 		view=\h\v,xlabel=x,ylabel=y,
% 		extra description/.code={%
% 			\node[draw,fill=white] at (axis cs:0,0,0) {};
% 		},
% }
% 
% \def\v{30}
% \foreach \h in {30,120,210,300} {
% \message{VIEW={\h}{\v}^^J}
% \begin{tikzpicture}
% 	\begin{axis}
% 	\addplot3[surf] {x};
% 	\end{axis}
% \end{tikzpicture}
% 
% }
% 
% \def\v{-30}
% \foreach \h in {30,120,210,300} {
% \message{VIEW={\h}{\v}^^J}
% \begin{tikzpicture}
% 	\begin{axis}
% 	\addplot3[surf] {x};
% 	\end{axis}
% \end{tikzpicture}
% 
% }
%-------------------------------------------------- 
%  The precise formulas can be found below in the source code.
%
% You can override this function by the /pgfplots/view dir key.
\def\pgfplotsgetnormalforcurrentview{%
	\pgfkeysgetvalue{/pgfplots/view dir}\pgfplots@loc@TMPc
	\ifx\pgfplots@loc@TMPc\pgfutil@empty
	\begingroup	
		\xdef\pgfplots@view@dir@threedim@z{-1}% hold it at some arbitrary value
		\pgf@xa=-\pgfplots@view@dir@threedim@z\pgf@zx
		\pgf@ya=-\pgfplots@view@dir@threedim@z\pgf@zy
		\edef\pgfplots@loc@TMPa{%
			{%
				{\pgf@sys@tonumber\pgf@xx}{\pgf@sys@tonumber\pgf@yx}%
				{\pgf@sys@tonumber\pgf@xy}{\pgf@sys@tonumber\pgf@yy}%
			}%
			{%
				{\pgf@sys@tonumber\pgf@xa}{\pgf@sys@tonumber\pgf@ya}%
			}%
		}%
		\expandafter\pgfutilsolvetwotwoleq\pgfplots@loc@TMPa
		\def\pgfplots@loc@TMPb##1##2{%
			\xdef\pgfplots@view@dir@threedim@x{##1}%
			\xdef\pgfplots@view@dir@threedim@y{##2}%
		}%
		\expandafter\pgfplots@loc@TMPb\pgfmathresult
		%
		% Identify if we need to switch the sign.
		% To verify that these cases are useful, I suggest visualizing
		% that stuff using the TeX code from above...
		%
		% I guess it is correct up to collapsing views (as you see, I
		% did not properly identify the cases with "=0" )
		\def\pgfplots@scale{1}%
		\ifdim\pgf@xx>0pt
			\ifdim\pgf@yx>0pt
				%
				\ifdim\pgf@xy>0pt
					\ifdim\pgf@yy<0pt
						\def\pgfplots@scale{-1}%
					\fi
				\fi
				%
			\fi
		\else
			\ifdim\pgf@xx<0pt
				\ifdim\pgf@yx<0pt
					%
					\ifdim\pgf@xy<0pt
						\ifdim\pgf@yy>0pt
							\def\pgfplots@scale{-1}%
						\fi
					\fi
					%
				\fi
			\fi
		\fi
		\ifdim\pgf@xy>0pt
			\ifdim\pgf@yy>0pt
				%
				\ifdim\pgf@xx<0pt
					\ifdim\pgf@yx>0pt
						\def\pgfplots@scale{-1}%
					\fi
				\fi
				%
			\fi
		\else
			\ifdim\pgf@xy<0pt
				\ifdim\pgf@yy<0pt
					%
					\ifdim\pgf@xx>0pt
						\ifdim\pgf@yx<0pt
							\def\pgfplots@scale{-1}%
						\fi
					\fi
					%
				\fi
			\fi
		\fi
		\pgfmathmultiply@{\pgfplots@scale}{\pgfplots@view@dir@threedim@x}%
		\global\let\pgfplots@view@dir@threedim@x\pgfmathresult
		\pgfmathmultiply@{\pgfplots@scale}{\pgfplots@view@dir@threedim@y}%
		\global\let\pgfplots@view@dir@threedim@y\pgfmathresult
		\pgfmathmultiply@{\pgfplots@scale}{\pgfplots@view@dir@threedim@z}%
		\global\let\pgfplots@view@dir@threedim@z\pgfmathresult
	\endgroup
	\else
		\def\pgfplots@loc@TMPb##1##2##3{%
			\xdef\pgfplots@view@dir@threedim@x{##1}%
			\xdef\pgfplots@view@dir@threedim@y{##2}%
			\xdef\pgfplots@view@dir@threedim@z{##3}%
		}%
		\expandafter\pgfplots@loc@TMPb\pgfplots@loc@TMPc
	\fi
%\message{\string\pgfplotsgetnormalforcurrentview:  got (\pgfplots@view@dir@threedim@x,\pgfplots@view@dir@threedim@y,\pgfplots@view@dir@threedim@z)^^J}%
}%

% ==================================================================================
% 
% COORDINATE MATH.
%
% ==================================================================================

% Declares a new "subclass" to perform coordinate math.
%
% Coordinate math usually needs a more powerful number format than the pgf
% basic layer, or at least a powerful mapping into the pgf basic
% layer. Both cases are realized by the coordinate math class.
%
% Different coordinates can use different instances, and it is also
% possible to use yet a further instance for point meta (or whatever).
%
% Coordinate math is used to compute axis limits and to map the range
% into the pgf number format. 
%
% It is *not* necessarily used for \pgfmathparse, since switching
% the number format of \pgfmathparse is quite involved (at the time of
% this writing). Instead, it is used for *single* operations (like
% max, min, multiply, add).
%
% #1: the name of the coord math class
% #2: methods to override the default.
%
% The available methods are documented and shown below in the
% \pgfqkeys listing. 
%
% @see the predefined examples, also shown below.
\def\pgfplotsdeclarecoordmath#1#2{%
	\edef\pgfplotsdeclarecoordmath@{@#1@}%
	\pgfqkeys{/pgfplots/@declare coord math}{%
		initialise=,
		parse=\pgfmathparse{##1},
		parsenumber=\pgfmathfloatparsenumber{##1}\pgfmathfloattofixed{##1},%
		zero=		\pgfplotscoordmath{\pgfplotscoordmathid}{parsenumber}{0},
		one=		\pgfplotscoordmath{\pgfplotscoordmathid}{parsenumber}{1},
		log e=		\pgfmathlog@{##1},%
		log to display log=\pgfmath@basic@multiply@{##1}{2.3025851},% * log(10)
		log from display log=\pgfmath@basic@multiply@{##1}{0.434294},% / log(10)
		log unsigned int={%
			\edef\pgfmathresult{%
				\ifcase##1
				\or0
				\or0.693147
				\or1.098612
				\or1.386294
				\or1.60943791
				\or1.7917594
				\or1.94591014
				\or2.07944154
				\or2.197224
				\fi
			}%
		},
		set log basis=\edef\pgfmathresult{{#1}{##1}}\expandafter\pgfplotscoordmath@log@set@basis\pgfmathresult,
		exp e={%
			% make sure the exponential can be represented, i.e. use
			% 'float' in the default repr:
			\pgfmathfloatparsenumber{##1}%
			\pgfmathfloatexp@\pgfmathresult%
			\pgfplotscoordmath{\pgfplotscoordmathid}{parsenumber}{\pgfmathresult}%
		},
		tofixed=	\edef\pgfmathresult{##1},%
		tostring=	\edef\pgfmathresult{##1},%
		max=		\pgfplotsmathmax{##1}{##2},%
		min=		\pgfplotsmathmin{##1}{##2},%
		min limit=	\def\pgfmathresult{-16300},%
		max limit=	\def\pgfmathresult{16300},%
		if less than=	{\pgfplotsmathlessthan{##1}{##2}\ifpgfmathfloatcomparison ##3\else ##4\fi},
		if is=	{%
			\if##20
				\ifdim##1pt=0pt ##2\else ##3\fi
			\else
				\if##2+\ifdim##1pt>0pt ##2\else ##3\fi
				\else
					\if##2-\ifdim##1pt<0pt ##2\else ##3\fi
					\else
						\def\pgfplots@loc@TMPd{##1}\ifx\pgfplots@loc@TMPd\pgfutil@empty ##2\else ##3\fi
					\fi
				\fi
			\fi
		},%
		if is bounded=\edef\pgfplotsretval{##1}\ifx\pgfplotsretval\pgfutil@empty ##3\else ##2\fi,
		suffix=		#1,%
		datascaletrafo set params=,
		datascaletrafo get params=	\def\pgfmathresult{{}{}},
		datascaletrafo=				\edef\pgfmathresult{##1},
		datascaletrafo inverse=		\edef\pgfmathresult{##1},
		datascaletrafo noshift inverse=		\edef\pgfmathresult{##1},
		datascaletrafo inverse to fixed=	\edef\pgfmathresult{##1},
		datascaletrafo noshift inverse to fixed=	\edef\pgfmathresult{##1},
		datascaletrafo noshift=		\edef\pgfmathresult{##1},
		datascaletrafo undo shift=	\edef\pgfmathresult{##1},
		datascaletrafo redo shift=	\edef\pgfmathresult{##1},
		#2%
	}%
	\expandafter\edef\csname pgfpmth\pgfplotsdeclarecoordmath@ op\endcsname##1##2{%
		\noexpand\edef\noexpand\pgfplotscoordmath@{##2}%
		\noexpand\expandafter\noexpand\expandafter\noexpand\csname pgfmath\csname pgfpmth@#1@suffix\endcsname ##1@\noexpand\endcsname\noexpand\pgfplotscoordmath@
	}%
	%
	%
	% these log function depend on the first argument of
	% \pgfplotscoordmath{}, which is available as
	% \pgfplotscoordmathid.
	\pgfplotsutilforeachcommasep{%
		exp,%
		log,%
		log to display log,%
		log from display log,%
		log to log 10,%
		log unsigned int}\as\pgfplots@loc@TMPa
	{%
		\expandafter\edef\csname pgfpmth\pgfplotsdeclarecoordmath@\pgfplots@loc@TMPa\endcsname{%
			% invoke \pgfpmth@#1@@<name>@<function>
			% for example
			% \pgfpmth@pgfbasic@@y@log
			\noexpand\csname pgfpmth\pgfplotsdeclarecoordmath@ @\noexpand\pgfplotscoordmathid @\pgfplots@loc@TMPa\noexpand\endcsname
		}%
	}%
	%
	\pgfutil@ifundefined{pgfpmth\pgfplotsdeclarecoordmath@ tmpl@log}{%
		\pgfutil@namelet
			{pgfpmth\pgfplotsdeclarecoordmath@ tmpl@log}
			{pgfpmth\pgfplotsdeclarecoordmath@ log e}%
	}{}%
	\pgfutil@ifundefined{pgfpmth\pgfplotsdeclarecoordmath@ tmpl@exp}{%
		\pgfutil@namelet
			{pgfpmth\pgfplotsdeclarecoordmath@ tmpl@exp}
			{pgfpmth\pgfplotsdeclarecoordmath@ exp e}%
	}{}%
	\pgfplotscoordmath@def@log@to@log@ten{#1}{}{tmpl}% empty arg
	%
}%
\pgfqkeys{/pgfplots/@declare coord math}{%
	initialise/.code=
		{\expandafter\def\csname pgfpmth\pgfplotsdeclarecoordmath@ initialise\endcsname{#1%
			\pgfplotscoordmath@initialise@logs
		}},%
	% takes a number literal as input and defines \pgfmathresult to be
	% the parsed result.
	parsenumber/.code=
		{\expandafter\def\csname pgfpmth\pgfplotsdeclarecoordmath@ parsenumber\endcsname##1{#1}},%
	%
	zero/.code=
		{\expandafter\def\csname pgfpmth\pgfplotsdeclarecoordmath@ zero\endcsname{#1}},%
	one/.code=
		{\expandafter\def\csname pgfpmth\pgfplotsdeclarecoordmath@ one\endcsname{#1}},%
	%
	% Calls pgfmathparse. Note that this might need to switch to the
	% required math library (which is not necessarily cheap)
	parse/.code=
		{\expandafter\def\csname pgfpmth\pgfplotsdeclarecoordmath@ parse\endcsname##1{#1}},%
	%
	% takes a parsed number and returns a fixed point number:
	tofixed/.code=
		{\expandafter\def\csname pgfpmth\pgfplotsdeclarecoordmath@ tofixed\endcsname##1{#1}},%
	%
	% chooses a human readable string (which can be processed by parsenumber):
	tostring/.code=
		{\expandafter\def\csname pgfpmth\pgfplotsdeclarecoordmath@ tostring\endcsname##1{#1}},%
	%
	% defines a max routine which returns the max of *exactly* two numbers:
	max/.code=
		{\expandafter\def\csname pgfpmth\pgfplotsdeclarecoordmath@ max\endcsname##1##2{#1}},%
	%
	% counterpart for max:
	min/.code=
		{\expandafter\def\csname pgfpmth\pgfplotsdeclarecoordmath@ min\endcsname##1##2{#1}},%
	%
	% defines \pgfmathresult to be the largest supported number.
	max limit/.code=
		{\expandafter\def\csname pgfpmth\pgfplotsdeclarecoordmath@ max limit\endcsname{#1}},%
	%
	% defines \pgfmathresult to be the smallest supported number.
	min limit/.code=
		{\expandafter\def\csname pgfpmth\pgfplotsdeclarecoordmath@ min limit\endcsname{#1}},%
	%
	% computes ##1 < ##2 and invokes ##3 in the true case and ##4 in
	% the false case.
	if less than/.code=
		{\expandafter\def\csname pgfpmth\pgfplotsdeclarecoordmath@ if less than\endcsname##1##2##3##4{#1}},%
	% checks if ##1 is 0, positive, negative or unbounded
	% ##1: the number to check
	% ##2: either 0 or + or - or u (u = unbounded)
	% ##3: true code
	% ##4: false code
	if is/.code=
		{\expandafter\def\csname pgfpmth\pgfplotsdeclarecoordmath@ if is\endcsname##1##2##3##4{#1}},%
	%
	% Checks if the argument ##1 is bounded and invokes ##2 in that
	% case. IF the argument is unbounded, it invokes #3.
	if is bounded/.code=
		{\expandafter\def\csname pgfpmth\pgfplotsdeclarecoordmath@ if is bounded\endcsname##1##2##3{#1}},%
	%
	% applies the natural logarithm. If the log is not defined, the
	% argument is "unbounded", see 'if is bounded'
	%
	% 'log' is special in that it accepts a number literal which may
	% be OUTSIDE of the accepted number format. The result, however, is
	% then in the accepted number format.
	log e/.code=
		{\expandafter\def\csname pgfpmth\pgfplotsdeclarecoordmath@ log e\endcsname##1{#1}},%
	%
	% Similar, but the log basis can be set with 'set log basis'.
	% This allows \pgfplotscoordmath{x}{log}{} to use a different log
	% basis thatn \pgfplotscoordmath{y}{log}{} (with special handling)
	log/.code=
		{\expandafter\def\csname pgfpmth\pgfplotsdeclarecoordmath@ tmpl@log\endcsname##1{#1}},%
	% applies a *scale* from the actual log basis to the actual
	% *display* log basis. The display log basis is usually 10, unless
	% the log basis has been changed.
	log to display log/.code=
		{\expandafter\def\csname pgfpmth\pgfplotsdeclarecoordmath@ tmpl@log to display log\endcsname##1{#1}},%
	% applies a *scale* from the displau log basis to the actual
	% log basis (the inverse of `log to display log').
	log from display log/.code=
		{\expandafter\def\csname pgfpmth\pgfplotsdeclarecoordmath@ tmpl@log from display log\endcsname##1{#1}},%
	log to log 10/.code=
		{\expandafter\def\csname pgfpmth\pgfplotsdeclarecoordmath@ tmpl@log to log 10\endcsname##1{#1}},%
	% returns log(i) where i \in {1,2,3,...,basis-1}
	% currently, it is only invoked for log basis 10
	log unsigned int/.code=
		{\expandafter\def\csname pgfpmth\pgfplotsdeclarecoordmath@ tmpl@log unsigned int\endcsname##1{#1}},%
	% sets (changes) the actual log basis.
	set log basis/.code=
		{\expandafter\def\csname pgfpmth\pgfplotsdeclarecoordmath@ set log basis\endcsname##1{#1}},%
	%
	% The inverse to 'log e '. 
	exp e/.code=
		{\expandafter\def\csname pgfpmth\pgfplotsdeclarecoordmath@ exp e\endcsname##1{#1}},%
	%
	% The inverse to 'log'. It also uses the correct log basis.
	exp/.code=
		{\expandafter\def\csname pgfpmth\pgfplotsdeclarecoordmath@ tmpl@exp\endcsname##1{#1}},%
	%
	% A macro taking two parameters:
	% #1: the EXPONENT (as integer)
	% #2: the SHIFT (as fixed point number)
	%
	% After any change, \pgfplotscoordmathnotifydatascalesetfor{<id>} will be
	% invoked where <id> is the argument to
	% \pgfplotscoordmath{<id>}...
	datascaletrafo set params/.code=
		{\expandafter\def\csname pgfpmth\pgfplotsdeclarecoordmath@ datascaletrafo set params\endcsname##1##2{%
			#1\relax\pgfplotscoordmathnotifydatascalesetfor{\pgfplotscoordmathid}%
		 }},%
	datascaletrafo set shift/.code=
		{\expandafter\def\csname pgfpmth\pgfplotsdeclarecoordmath@ datascaletrafo set shift\endcsname##1{%
			#1\relax\pgfplotscoordmathnotifydatascalesetfor{\pgfplotscoordmathid}%
		 }},%
	% 
	% Defines \pgfmathresult to contain the two parameters required
	% for 'datascaletrafo set params'.
	datascaletrafo get params/.code=
		{\expandafter\def\csname pgfpmth\pgfplotsdeclarecoordmath@ datascaletrafo get params\endcsname{#1}},%
	datascaletrafo/.code=
		{\expandafter\def\csname pgfpmth\pgfplotsdeclarecoordmath@ datascaletrafo\endcsname##1{#1}},%
	datascaletrafo inverse/.code=
		{\expandafter\def\csname pgfpmth\pgfplotsdeclarecoordmath@ datascaletrafo inverse\endcsname##1{#1}},%
	datascaletrafo noshift inverse/.code=
		{\expandafter\def\csname pgfpmth\pgfplotsdeclarecoordmath@ datascaletrafo noshift inverse\endcsname##1{#1}},%
	datascaletrafo inverse to fixed/.code=
		{\expandafter\def\csname pgfpmth\pgfplotsdeclarecoordmath@ datascaletrafo inverse to fixed\endcsname##1{#1}},%
	datascaletrafo noshift inverse to fixed/.code=
		{\expandafter\def\csname pgfpmth\pgfplotsdeclarecoordmath@ datascaletrafo noshift inverse to fixed\endcsname##1{#1}},%
	datascaletrafo noshift/.code=
		{\expandafter\def\csname pgfpmth\pgfplotsdeclarecoordmath@ datascaletrafo noshift\endcsname##1{#1}},%
	datascaletrafo noshift/.code=
		{\expandafter\def\csname pgfpmth\pgfplotsdeclarecoordmath@ datascaletrafo noshift\endcsname##1{#1}},%
	datascaletrafo undo shift/.code=
		{\expandafter\def\csname pgfpmth\pgfplotsdeclarecoordmath@ datascaletrafo undo shift\endcsname##1{#1}},%
	datascaletrafo redo shift/.code=
		{\expandafter\def\csname pgfpmth\pgfplotsdeclarecoordmath@ datascaletrafo redo shift\endcsname##1{#1}},%
	%
	% defines a suffix such that
	% 	\csname pgfmath<suffix><op>@\endcsname
	% exists. Example: <suffix>=float  --> \pgfmathfloatmultiply@ for <op>=multiply
	suffix/.code=
		{\expandafter\edef\csname pgfpmth\pgfplotsdeclarecoordmath@ suffix\endcsname{#1}},%
}%

\def\pgfplotscoordmath@initialise@logs{%
	\edef\pgfplotsdeclarecoordmath@{@\pgfplotscoordmathclassfor{\pgfplotscoordmathid}@}%
	\pgfutil@ifundefined{pgfpmth\pgfplotsdeclarecoordmath@ @\pgfplotscoordmathid @log}{%
		\pgfplotsutilforeachcommasep{%
			exp,%
			log,%
			log to display log,%
			log from display log,%
			log to log 10,%
			log unsigned int}\as\pgfplots@loc@TMPa
		{%
			\pgfutil@namelet
				{pgfpmth\pgfplotsdeclarecoordmath@ @\pgfplotscoordmathid @\pgfplots@loc@TMPa}
				{pgfpmth\pgfplotsdeclarecoordmath@ tmpl@\pgfplots@loc@TMPa}%
		}%
	}{}%
}%

% shared implementation for 'set log basis' It works for every
% subclass.
\def\pgfplotscoordmath@log@set@basis#1#2{%
	\edef\pgfplotsdeclarecoordmath@{@#1@}%
	%
	\pgfplotscoordmath{\pgfplotscoordmathid}{log e}{#2}%
	\let\pgfplots@loc@TMPa=\pgfmathresult% TMPa = log_e(#2)
	\pgfplotscoordmath{\pgfplotscoordmathid}{op}{reciprocal}{{\pgfmathresult}}%
	\let\pgfplots@loc@TMPb=\pgfmathresult% TMPb = 1/log_e(#2)
	%
	\expandafter\edef\csname pgfpmth\pgfplotsdeclarecoordmath@ @\pgfplotscoordmathid @log\endcsname##1{%
		\noexpand\pgfplotscoordmath{\pgfplotscoordmathid}{log e}{##1}%
		\noexpand\ifx\noexpand\pgfmathresult\noexpand\pgfutil@empty
		\noexpand\else
			\noexpand\pgfplotscoordmath{\pgfplotscoordmathid}{op}{multiply}{%
				{\noexpand\pgfmathresult}%
				{\pgfplots@loc@TMPb}%
			}%
		\noexpand\fi
	}%
	\expandafter\edef\csname pgfpmth\pgfplotsdeclarecoordmath@ @\pgfplotscoordmathid @exp\endcsname##1{%
		\noexpand\edef\noexpand\pgfmathresult{##1}%
		\noexpand\ifx\noexpand\pgfmathresult\noexpand\pgfutil@empty
		\noexpand\else
			\noexpand\pgfplotscoordmath{\pgfplotscoordmathid}{op}{multiply}{%
				{\noexpand\pgfmathresult}%
				{\pgfplots@loc@TMPa}%
			}%
			\noexpand\pgfplotscoordmath{\pgfplotscoordmathid}{exp e}{\noexpand\pgfmathresult}%
		\noexpand\fi
	}%
	\expandafter\def\csname pgfpmth\pgfplotsdeclarecoordmath@ @\pgfplotscoordmathid @log to display log\endcsname##1{\edef\pgfmathresult{##1}}%
	\expandafter\def\csname pgfpmth\pgfplotsdeclarecoordmath@ @\pgfplotscoordmathid @log from display log\endcsname##1{\edef\pgfmathresult{##1}}%
	%
	% compute 'log unsigned int' for the new basis.
	%
	% Idea: re-scale the old implementation (of basis e for i = 1,...,9)
	% and re-compute i>=10 :
	\begingroup
		\expandafter\let\expandafter\logi\csname pgfpmth\pgfplotsdeclarecoordmath@ tmpl@log unsigned int\endcsname
		\let\logscale=\pgfplots@loc@TMPb
		%
		\logi{1}%
		\pgfplotscoordmath{\pgfplotscoordmathid}{op}{multiply}{{\pgfmathresult}{\logscale}}%
		\expandafter\let\csname logi@@1\endcsname=\pgfmathresult
		%
		\logi{2}%
		\pgfplotscoordmath{\pgfplotscoordmathid}{op}{multiply}{{\pgfmathresult}{\logscale}}%
		\expandafter\let\csname logi@@2\endcsname=\pgfmathresult
		%
		\logi{3}%
		\pgfplotscoordmath{\pgfplotscoordmathid}{op}{multiply}{{\pgfmathresult}{\logscale}}%
		\expandafter\let\csname logi@@3\endcsname=\pgfmathresult
		%
		\logi{4}%
		\pgfplotscoordmath{\pgfplotscoordmathid}{op}{multiply}{{\pgfmathresult}{\logscale}}%
		\expandafter\let\csname logi@@4\endcsname=\pgfmathresult
		%
		\logi{5}%
		\pgfplotscoordmath{\pgfplotscoordmathid}{op}{multiply}{{\pgfmathresult}{\logscale}}%
		\expandafter\let\csname logi@@5\endcsname=\pgfmathresult
		%
		\logi{6}%
		\pgfplotscoordmath{\pgfplotscoordmathid}{op}{multiply}{{\pgfmathresult}{\logscale}}%
		\expandafter\let\csname logi@@6\endcsname=\pgfmathresult
		%
		\logi{7}%
		\pgfplotscoordmath{\pgfplotscoordmathid}{op}{multiply}{{\pgfmathresult}{\logscale}}%
		\expandafter\let\csname logi@@7\endcsname=\pgfmathresult
		%
		\logi{8}%
		\pgfplotscoordmath{\pgfplotscoordmathid}{op}{multiply}{{\pgfmathresult}{\logscale}}%
		\expandafter\let\csname logi@@8\endcsname=\pgfmathresult
		%
		\logi{9}%
		\pgfplotscoordmath{\pgfplotscoordmathid}{op}{multiply}{{\pgfmathresult}{\logscale}}%
		\expandafter\let\csname logi@@9\endcsname=\pgfmathresult
		%
		\xdef\pgfplots@glob@TMPa##1{%
			\noexpand\ifcase##1
			\noexpand\def\noexpand\pgfmathresult{}%
			\noexpand\or\noexpand\def\noexpand\pgfmathresult{\csname logi@@1\endcsname}%
			\noexpand\or\noexpand\def\noexpand\pgfmathresult{\csname logi@@2\endcsname}%
			\noexpand\or\noexpand\def\noexpand\pgfmathresult{\csname logi@@3\endcsname}%
			\noexpand\or\noexpand\def\noexpand\pgfmathresult{\csname logi@@4\endcsname}%
			\noexpand\or\noexpand\def\noexpand\pgfmathresult{\csname logi@@5\endcsname}%
			\noexpand\or\noexpand\def\noexpand\pgfmathresult{\csname logi@@6\endcsname}%
			\noexpand\or\noexpand\def\noexpand\pgfmathresult{\csname logi@@7\endcsname}%
			\noexpand\or\noexpand\def\noexpand\pgfmathresult{\csname logi@@8\endcsname}%
			\noexpand\or\noexpand\def\noexpand\pgfmathresult{\csname logi@@9\endcsname}%
			\noexpand\else
				\noexpand\pgfplotscoordmath{\pgfplotscoordmathid}{log}{##1}%
			\noexpand\fi
		}%
	\endgroup
	\expandafter\let\csname pgfpmth\pgfplotsdeclarecoordmath@ @\pgfplotscoordmathid @log unsigned int\endcsname=\pgfplots@glob@TMPa
	\pgfplotscoordmath@def@log@to@log@ten{#1}\pgfplots@loc@TMPa{\pgfplotscoordmathid}%
	%
	\pgfutil@namelet
		{pgfpmth\pgfplotsdeclarecoordmath@ @\pgfplotscoordmathid @log to log 10}
		{pgfpmth\pgfplotsdeclarecoordmath@ tmpl@log to log 10}%
}%
% #1: the coord math class
% #2: either empty (basis e) or 1/ln(basis)
% #3: either 'tmpl' or '\pgfplotscoordmathid. It defines the target
% macro name (see the source code)
\def\pgfplotscoordmath@def@log@to@log@ten#1#2#3{%
	\csname pgfpmth@#1@parsenumber\endcsname{0.434294}%
	\edef\pgfplots@loc@TMPa{#2}%
	\ifx\pgfplots@loc@TMPa\pgfutil@empty
		% log basis e ---> log basis 10
		% log_10 x = log x / log(10)
	\else
		% log basis a ---> log basis 10
		%
		% log_a x = log x / log a 
		% log_10 x =  log_a x * log a / log(10) = log x / log(10) [OK]
		\csname pgfpmth@#1@op\endcsname{multiply}{{#2}{\pgfmathresult}}%
	\fi
	\expandafter\edef\csname pgfpmth@#1@#3@log to log 10\endcsname##1{%
		\noexpand\pgfplotscoordmath{\noexpand\pgfplotscoordmathid}{op}{multiply}{{##1}{\pgfmathresult}}%
	}%
}%

% Assumes that #2 is a macro, parses it as number with "coord math choice" #1, and overwrites it with the result.
\def\pgfplotscoordmathparsemacro#1#2{%
	\pgfplotscoordmath{#1}{parsenumber}{#2}\let#2=\pgfmathresult
}%


\pgfplotsdeclarecoordmath{pgfbasic}{%
	parsenumber=\pgfmathfloatparsenumber{#1}\pgfmathfloattofixed\pgfmathresult,
	suffix=@basic@,
	zero=\def\pgfmathresult{0},
	one=\def\pgfmathresult{1},
}
\pgfplotsdeclarecoordmath{float}{%
	initialise=
		\pgfutil@ifundefined{pgfplots@data@scale@trafo@EXPONENT@\pgfplotscoordmathid}{%
			\expandafter\edef\csname pgfplots@data@scale@trafo@EXPONENT@\pgfplotscoordmathid\endcsname{0}%
			\expandafter\edef\csname pgfplots@data@scale@trafo@SHIFT@\pgfplotscoordmathid\endcsname{0}%
		}{},
	parsenumber=\pgfmathfloatparsenumber{#1},
	parse=\begingroup \pgfkeys{/pgf/fpu}\pgfmathparse{#1}\pgfmath@smuggleone\pgfmathresult\endgroup,
	zero=\pgfmathfloatcreate{0}{0.0}{0},%
	one=\pgfmathfloatcreate{1}{1.0}{0},%
	tofixed=\pgfmathfloattofixed{#1},
	tostring=\pgfmathfloattosci{#1},
	max=\pgfplotsmathfloatmax{#1}{#2},%
	min=\pgfplotsmathfloatmin{#1}{#2},%
	max limit=\pgfmathfloatcreate{1}{1.0}{2147483645},%
	min limit=\pgfmathfloatcreate{2}{1.0}{2147483645},%
	log e=\pgfmathfloatparsenumber{#1}\pgfmathfloatln@{\pgfmathresult},%
	if less than=\pgfmathfloatlessthan@{#1}{#2}\ifpgfmathfloatcomparison #3\else #4\fi,
	if is bounded=%
		\expandafter\pgfmathfloatgetflagstomacro\expandafter{#1}\pgfplotsretval
		\ifnum\pgfplotsretval>2 #3\else #2\fi,
	if is=%
		\pgfmathfloatifflags{#1}{#2}{#3}{#4},
	log=\pgfmathlog@float{#1},%
	datascaletrafo set params={%
		\expandafter\edef\csname pgfplots@data@scale@trafo@EXPONENT@\pgfplotscoordmathid\endcsname{#1}%
		\expandafter\edef\csname pgfplots@data@scale@trafo@SHIFT@\pgfplotscoordmathid\endcsname{#2}%
	},%
	datascaletrafo set shift={%
		\expandafter\edef\csname pgfplots@data@scale@trafo@SHIFT@\pgfplotscoordmathid\endcsname{#1}%
	},%
	datascaletrafo get params={%
		\edef\pgfmathresult{%
			{\csname pgfplots@data@scale@trafo@EXPONENT@\pgfplotscoordmathid\endcsname}%
			{\csname pgfplots@data@scale@trafo@SHIFT@\pgfplotscoordmathid\endcsname}%
		}%
	},%
	datascaletrafo={%
		\edef\pgfmathresult{#1}%
		\pgfmathfloatshift@\pgfmathresult{\csname pgfplots@data@scale@trafo@EXPONENT@\pgfplotscoordmathid\endcsname}%
		\pgfmathfloattofixed\pgfmathresult
		\expandafter\pgfmath@basic@subtract@\expandafter{\pgfmathresult}{\csname pgfplots@data@scale@trafo@SHIFT@\pgfplotscoordmathid\endcsname}%
	},%
	datascaletrafo noshift={%
		\edef\pgfmathresult{#1}%
		\pgfmathfloatshift@\pgfmathresult{\csname pgfplots@data@scale@trafo@EXPONENT@\pgfplotscoordmathid\endcsname}%
		\pgfmathfloattofixed{\pgfmathresult}%
	},%
	datascaletrafo undo shift=
		\pgfmath@basic@subtract@{#1}{\csname pgfplots@data@scale@trafo@SHIFT@\pgfplotscoordmathid\endcsname},%
	datascaletrafo redo shift=\pgfmath@basic@add@{#1}{\csname pgfplots@data@scale@trafo@SHIFT@\pgfplotscoordmathid\endcsname},%
	datascaletrafo inverse={%
		\pgfplotscoordmath@float@datascaletrafo@inverse{#1}%
	},%
	datascaletrafo inverse to fixed={%
		\pgfplotscoordmath@float@datascaletrafo@inverse{#1}%
		\pgfmathfloattofixed\pgfmathresult
	},%
	datascaletrafo noshift inverse={%
		\pgfmathfloatparsenumber{#1}%
		\pgfmathfloatshift@{\pgfmathresult}{-\csname pgfplots@data@scale@trafo@EXPONENT@\pgfplotscoordmathid\endcsname}%
	},%
	datascaletrafo noshift inverse to fixed={%
		\pgfmathfloatparsenumber{#1}%
		\pgfmathfloatshift@{\pgfmathresult}{-\csname pgfplots@data@scale@trafo@EXPONENT@\pgfplotscoordmathid\endcsname}%
		\pgfmathfloattofixed\pgfmathresult
	},%
}

\def\pgfplotscoordmath@float@datascaletrafo@inverse#1{%
	\pgfmath@basic@add@{#1}{\csname pgfplots@data@scale@trafo@SHIFT@\pgfplotscoordmathid\endcsname}%
	\let\pgfplots@inverse@datascaletrafo@@shifted=\pgfmathresult
	\pgfmathapproxequalto@{\pgfplots@inverse@datascaletrafo@@shifted}{0.0}%
	\ifpgfmathcomparison
		\pgfmathfloatcreate{0}{0.0}{0}%
	\else
		\pgfmathfloatparsenumber{\pgfplots@inverse@datascaletrafo@@shifted}%
		\pgfmathfloatshift@{\pgfmathresult}{-\csname pgfplots@data@scale@trafo@EXPONENT@\pgfplotscoordmathid\endcsname}%
	\fi
}%

% Invokes a coordinate math routine.
%
% #1: the axis (x,y or z)
% #2: a method name declared by \pgfplotsdeclarecoordmath (one of
% 'op', 'parsenumber', 'tofixed' etc)
% #3-#9: any further arguments required to perform the call to '#2'.
%
% \pgfplotscoordmath {x}{op}{multiply}{{<a>}{<b>}}
% \pgfplotscoordmath {x}{parsenumber}{<a>}
\def\pgfplotscoordmath#1#2{%
	\edef\pgfplotscoordmathid{#1}%
	\csname pgfpmth@\csname pgfcrdmth@#1\endcsname @#2\endcsname}%

\def\pgfplotscoordmathclassfor#1{\csname pgfcrdmth@#1\endcsname}%

\def\pgfplotscoordmathnotifydatascalesetfor#1{}%

% Enables a particular coordinate math class for the label `#1'.
%
% #1 a label (usually x,y or z)
% #2 the coordinate math class (one prepare by
% \pgfplotsdeclarecoordmath)
%
% From this point on, any call to \pgfplotscoordmath{#1}{...}
% will use the selected math class.
\def\pgfplotssetcoordmathfor#1#2{%
	\pgfutil@ifundefined{pgfpmth@#2@initialise}{%
		\pgfplotsthrow{invalid argument}{\pgfplots@loc@TMPa}{Sorry, \string\pgfplotssetcoordmathfor{#1}{#2} failed since `#2' is unknown. Maybe you misspelled it?}\pgfeov%
	}{%
		\expandafter\edef\csname pgfcrdmth@#1\endcsname{#2}%
		\pgfplotscoordmath{#1}{initialise}%
	}%
}%

% Defines \pgfplotsretval to be the coordmath id for #1
\def\pgfplotsgetcoordmathfor#1{%
	\pgfutil@ifundefined{pgfcrdmth@#1}{%
		\pgfplotsthrow{invalid argument}{\pgfplots@loc@TMPa}{Sorry, \string\pgfplotsgetcoordmathfor{#1} failed since `#1' is unknown. Maybe you misspelled it?}\pgfeov%
	}{%
		\pgfutil@namelet{pgfplotsretval}{pgfcrdmth@#1}%
	}%
}%
\pgfplotssetcoordmathfor{pgfbasic}{pgfbasic}%
\pgfplotssetcoordmathfor{float}{float}%
\pgfplotssetcoordmathfor{meta}{float}%
\pgfplotssetcoordmathfor{default}{float}%



% ==================================================================================



% #1  the name of an input method for point meta. It must have been
% declared by \pgfplotsdeclarepointmetasource first.
% #2  any arguments supplied by the user (maybe empty).
\def\pgfplotssetpointmetainput#1#2{%
	\csname pgfpmeta@#1@initfor\endcsname{#2}%
	%
	\edef\pgfplotspointmetainputhandler{#1}%
}%

% Expands to the current value of 'point meta'.
\def\pgfplotspointmetainputhandler{}

\def\pgfplotsaxisifhaspointmeta#1#2{%
	\ifx\pgfplotspointmetainputhandler\pgfutil@empty #2\else #1\fi
}%

% Invokes '#1' if the axis contains the coordinate designated by
% \pgfplots@current@point@[xyz] and '#2' if not.
\def\pgfplotsaxisifcontainspoint#1#2{%
	\pgf@xa=\pgfplots@current@point@x pt % FIXME : SCOPE REGISTERS!?
	\pgf@ya=\pgfplots@current@point@y pt %
	\ifpgfplots@curplot@threedim
		\pgf@yb=\pgfplots@current@point@z pt %
	\fi
	\def\pgfplots@loc@TMPa{#2}%
	% 
	% I assume that \pgfplots@[xyz]min@reg and min@reg are registers
	% containing the limits.
	\ifdim\pgf@xa<\pgfplots@xmin@reg
	\else
		\ifdim\pgf@xa>\pgfplots@xmax@reg
		\else
			\ifdim\pgf@ya<\pgfplots@ymin@reg
			\else
				\ifdim\pgf@ya>\pgfplots@ymax@reg
				\else
					\ifpgfplots@curplot@threedim
						\ifdim\pgf@yb<\pgfplots@zmin@reg
						\else
							\ifdim\pgf@yb>\pgfplots@zmax@reg
							\else
								\def\pgfplots@loc@TMPa{#1}%
							\fi
						\fi
					\else
						\def\pgfplots@loc@TMPa{#1}%
					\fi
				\fi
			\fi
		\fi
	\fi
	\pgfplots@loc@TMPa%
}

% Declares a routine which can be used to get point meta input.
%
% Such a routine is invoked in a context where point coordinates are
% processed, i.e. during 'plot coordinates', 'plot table' or the like.
%
% The routine is called `#1'. It consists of several methods, which
% are described below, in the key definitions.
%
% #1: the name of the input routine.
% #2: a sequence of key-value pairs which can be used to overwrite
% 'assign', 'initfor' or the other components.
% 	See the definitions below for examples.
\def\pgfplotsdeclarepointmetasource#1#2{%
	\expandafter\def\csname pgfpmeta@#1@assign\endcsname{\let\pgfplots@current@point@meta=\pgfutil@empty}%
	\expandafter\def\csname pgfpmeta@#1@initfor\endcsname##1{}%
	\expandafter\def\csname pgfpmeta@#1@issymbolic\endcsname{0}%
	\expandafter\def\csname pgfpmeta@#1@explicitinput\endcsname{0}%
	\expandafter\def\csname pgfpmeta@#1@activate\endcsname{}%
	\edef\pgfplotsdeclarepointmetasource@{#1}%
	\pgfqkeys{/pgfplots/@declare point meta src}{#2}%
}%
\pgfqkeys{/pgfplots/@declare point meta src}{%
	%
	% 		a macro used to initialise the point meta source when it is
	% 		selected.
	% 		This macro body is invoked by pgfplots when someone types 
	%		'point meta=x' -> will invoke 'pgfpmeta@x@initfor{}'.
	%		The first argument to initfor can be supplied by the user.
	%		PRECONDITION for 'initfor':
	%			- it will be invoked just before
	%			'\pgfplotspointmetainputhandler' will be changed.
	%	Default is to do nothing.
	initfor/.code=
		{\expandafter\def\csname pgfpmeta@\pgfplotsdeclarepointmetasource@ @initfor\endcsname##1{#1}},%
	%
	% Called during the survey phase before the first 'assign' call.
	% It is usually empty.
	activate/.code=
		{\expandafter\def\csname pgfpmeta@\pgfplotsdeclarepointmetasource@ @activate\endcsname{#1}},%
	%
	% 	During the survey phase, this macro is expected to assign
	% 	\pgfplots@current@point@meta
	%	if it is a numeric input method, it should return a
	%	floating point number.
	%	It is allowed to return an empty string to say "there is no point
	%	meta".
	%	PRECONDITION for '@assign':
	%		- the coordinate input method has already assigned its
	%		'\pgfplots@current@point@meta' (probably as raw input string).
	%		- the other input coordinates are already read.
	%	POSTCONDITION for '@assign':
	%		- \pgfplots@current@point@meta is ready for use:
	%		- EITHER a parsed floating point number 
	%		- OR an empty string,
	%		- OR a symbolic string (if the issymbolic boolean is true)
	%	The default implementation is
	%	\let\pgfplots@current@point@meta=\pgfutil@empty
	%
	assign/.code=
		{\expandafter\def\csname pgfpmeta@\pgfplotsdeclarepointmetasource@ @assign\endcsname{#1}},%
	%
	%    expands to either '1' or '0'
	% 		A numeric source will be processed numerically in float
	% 		arithmetics. Thus, the output of the @assign routine should be
	% 		a macro \pgfplots@current@point@meta in float format.
	%
	%		The output of a numeric point meta source will result in meta
	%		limit updates and the final map to [0,1000] will be
	%		initialised automatically.
	%
	% 		A symbolic input routine won't be processed.
	% 	Default is '0'
	%
	issymbolic/.code=
		{\expandafter\def\csname pgfpmeta@\pgfplotsdeclarepointmetasource@ @issymbolic\endcsname{#1}},%
	%
	%   expands to either
	%   '1' or '0'. In case '1', it expects explicit input from the
	%   coordinate input routines. For example, 'plot file' will look for
	%   further input after the x,y,z coordinates.
	%   Default is '0'
	%
	explicitinput/.code=
		{\expandafter\def\csname pgfpmeta@\pgfplotsdeclarepointmetasource@ @explicitinput\endcsname{#1}},%
}%

% An empty one. This is simple to check with
% \ifx\pgfplotspointmetainputhandler\pgfutil@empty:
\pgfplotsdeclarepointmetasource{}{}
\pgfplotsdeclarepointmetasource{x}{assign={%
		\let\pgfplots@current@point@meta=\pgfplots@current@point@x
		\pgfplotscoordmath{meta}{parsenumber}{\pgfplots@current@point@meta}%
		\let\pgfplots@current@point@meta=\pgfmathresult
		}}
\pgfplotsdeclarepointmetasource{y}{assign={%
		\let\pgfplots@current@point@meta=\pgfplots@current@point@y
		\pgfplotscoordmath{meta}{parsenumber}{\pgfplots@current@point@meta}%
		\let\pgfplots@current@point@meta=\pgfmathresult
		}}
\pgfplotsdeclarepointmetasource{z}{assign={%
		\let\pgfplots@current@point@meta=\pgfplots@current@point@z
		\pgfplotscoordmath{meta}{parsenumber}{\pgfplots@current@point@meta}%
		\let\pgfplots@current@point@meta=\pgfmathresult
	}}

\pgfplotsdeclarepointmetasource{explicit}{%
	assign={%
		\ifx\pgfplots@current@point@meta\pgfutil@empty
		\else
			\pgfplotscoordmath{meta}{parsenumber}{\pgfplots@current@point@meta}%
			\let\pgfplots@current@point@meta=\pgfmathresult
		\fi
	},
	explicitinput=1%
}%
\pgfplotsdeclarepointmetasource{explicit symbolic}{%
	assign={},% no math, simply collect.
	explicitinput=1,%
	issymbolic=1%
}%

\pgfplotsdeclarepointmetasource{expr}{%
	assign={%
		\csname pgfpmeta@\pgfpmeta@expr@origchoice @assign\endcsname
		%
		\pgfkeysgetvalue{/pgfplots/point meta/expr}\pgfplots@loc@TMPa
		\ifx\pgfplots@loc@TMPa\pgfutil@empty
		\else
			\pgfmathparse{\pgfplots@loc@TMPa}%
			\pgfplotscoordmath{meta}{parsenumber}{\pgfmathresult}%
			\let\pgfplots@current@point@meta=\pgfmathresult
		\fi
	},%
	initfor={%
		\pgfkeyssetvalue{/pgfplots/point meta/expr}{#1}%
		\def\pgfplots@loc@TMPa{expr}%
		\ifx\pgfplots@loc@TMPa\pgfplotspointmetainputhandler
		\else
			\let\pgfpmeta@expr@origchoice\pgfplotspointmetainputhandler
		\fi
		\ifx\pgfpmeta@expr@origchoice\pgfplots@loc@TMPa
			\let\pgfpmeta@expr@origchoice\pgfutil@empty
		\fi
	},
}%
\pgfkeyssetvalue{/pgfplots/point meta/expr}{}%

\pgfplotsdeclarepointmetasource{f(x)}{%
	activate={%
		\ifpgfplots@curplot@threedim
			\def\pgfplotspointmetainputhandler{z}%
		\else
			\def\pgfplotspointmetainputhandler{y}%
		\fi
		\csname pgfpmeta@\pgfplotspointmetainputhandler @activate\endcsname
	},
}%

\pgfplotsdeclarepointmetasource{TeX code}{%
	assign={%
		\begingroup
		\let\pgfplotspointmeta=\pgfutil@empty
		\pgfplots@invoke@pgfkeyscode{/pgfplots/point meta/code/.@cmd}{}%
		\pgfplotscoordmath{meta}{parsenumber}{\pgfplotspointmeta}%
		\let\pgfplots@current@point@meta=\pgfmathresult
		\pgfmath@smuggleone\pgfplots@current@point@meta
		\endgroup
	},%
	initfor={%
		\pgfkeysdef{/pgfplots/point meta/code}{#1}%
	},
}%
\pgfplotsdeclarepointmetasource{TeX code symbolic}{%
	assign={%
		\begingroup
		\let\pgfplotspointmeta=\pgfutil@empty
		\pgfplots@invoke@pgfkeyscode{/pgfplots/point meta/code/.@cmd}{}%
		\let\pgfplots@current@point@meta=\pgfplotspointmeta
		\pgfmath@smuggleone\pgfplots@current@point@meta
		\endgroup
	},%
	initfor={%
		\pgfkeysdef{/pgfplots/point meta/code}{#1}%
	},
	issymbolic=1%
}%
\pgfkeysdef{/pgfplots/point meta/code}{}%

% Internal stream methods.
%
% Please overwrite 
% - \pgfplots@coord@stream@start@,
% - \pgfplots@coord@stream@end@ and 
% - \pgfplots@coord@stream@coord@
% if you implement streams.
%
% REMARK:
% 	- the stream methods automatically collect first and last
% 	coordinates.
% 	- I have experimented with global \addplot accumulation to reduce
% 	copy operations. That experiment was not successfull (it was not
% 	faster :-(  ). However, the streaming methods still assign their
% 	things globally...
\def\pgfplots@coord@stream@start{%
	\let\pgfplots@current@point@x=\pgfutil@empty
	\let\pgfplots@current@point@y=\pgfutil@empty
	\let\pgfplots@current@point@z=\pgfutil@empty
	\let\pgfplots@current@point@meta=\pgfutil@empty
	\let\pgfplots@current@point@x@error=\pgfutil@empty
	\let\pgfplots@current@point@y@error=\pgfutil@empty
	\let\pgfplots@current@point@z@error=\pgfutil@empty
	\pgfplots@coord@stream@start@}%
\def\pgfplots@coord@stream@end{\pgfplots@coord@stream@end@}

% Will be invoked for every point coordinate.
%
% It invokes \pgfplots@coord@stream@coord@.
%
% Arguments:
% \pgfplots@current@point@[xyz]
% \pgfplots@current@point@[xyz]@error (if in argument list)
% \pgfplots@current@point@meta
\def\pgfplots@coord@stream@coord{%
	\pgfplots@coord@stream@coord@%
}%
\def\pgfplotscoordstream@firstlast@init{%
	\global\let\pgfplots@currentplot@firstcoord@x=\pgfutil@empty
	\global\let\pgfplots@currentplot@firstcoord@y=\pgfutil@empty
	\global\let\pgfplots@currentplot@firstcoord@z=\pgfutil@empty
	\global\let\pgfplots@currentplot@lastcoord@x=\pgfutil@empty
	\global\let\pgfplots@currentplot@lastcoord@y=\pgfutil@empty
	\global\let\pgfplots@currentplot@lastcoord@z=\pgfutil@empty
}%
\def\pgfplotscoordstream@firstlast@update{%
	\ifx\pgfplots@current@point@x\pgfutil@empty
		% only one \if is enough as ONE empty coordinate results all
		% others to be reset as well.
	\else
		\ifx\pgfplots@currentplot@firstcoord@x\pgfutil@empty
			\global\let\pgfplots@currentplot@firstcoord@x=\pgfplots@current@point@x
			\global\let\pgfplots@currentplot@firstcoord@y=\pgfplots@current@point@y
			\global\let\pgfplots@currentplot@firstcoord@z=\pgfplots@current@point@z
		\fi
		\global\let\pgfplots@currentplot@lastcoord@x=\pgfplots@current@point@x
		\global\let\pgfplots@currentplot@lastcoord@y=\pgfplots@current@point@y
		\global\let\pgfplots@currentplot@lastcoord@z=\pgfplots@current@point@z
	\fi
}%

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Scanline management. The idea is to handle complete sequences of
% input coordinates, which are usually separated by a blank line.
%
% This allows a simple syntax to provide matrix input - by means of scanlines.
% Furthermore, 2d plots can use it to interrupt the display.
%
% An empty line in 'addplot coordinates {}' indicates the end of a
% scan line. Similarly, an empty line in 'addplot file' or 'table'
% also indicates the end of a scan line.
%
% The steps taken whenever a scan line is complete depend on the
% configuration of the /pgfplots/empty line choice key (queried in
% \pgfplotsscanlinelengthinitzero).
%
%
% The following methods constitute the scanline interface.
%
% Usage:
%
% \pgfplotsscanlinelengthinitzero
%
% \pgfplotsscanlinelengthincrease
% <process point>
% \pgfplotsscanlinelengthincrease
% <process point>
% \pgfplotsscanlinelengthincrease
% <process point>
% \pgfplotsscanlinecomplete
% \pgfplotsscanlinelengthincrease
% <process point>
% \pgfplotsscanlinelengthincrease
% <process point>
% \pgfplotsscanlinelengthincrease
% <process point>
% \pgfplotsscanlinecomplete
% \pgfplotsscanlinelengthincrease
% <process point>
% \pgfplotsscanlinelengthincrease
% <process point>
% \pgfplotsscanlinelengthincrease
% <process point>
% \pgfplotsscanlinecomplete
%
% \pgfplotsscanlinelengthcleanup
%
% In other words, the \pgfplotsscanlinelengthincrease routine is
% invoked *before* the point is processed. That's important.
%
% Now, \pgfplotsscanlinelength expands to either 
% a) a negative number in which case there is no 
%  unique scanline length.
%  	More precisely, -1 means "there was no end-of-scanline marker"
%  	-2 means "there where end-of-scanline markers, but the scanlines
%  	had different lengths.
% b) the scanline length.
\def\pgfplotsscanlinelengthinitzero{%
	\def\pgfplotsscanlinelength{-1}%
	\pgfkeysgetvalue{/pgfplots/empty line}\pgfplots@loc@TMPa%
	\edef\pgfplots@loc@TMPa{\pgfplots@loc@TMPa}%
	\def\pgfplots@loc@TMPb{auto}%
	\ifx\pgfplots@loc@TMPa\pgfplots@loc@TMPb
		\pgfplotsdetermineemptylinehandler
		\pgfkeysgetvalue{/pgfplots/empty line}\pgfplots@loc@TMPa%
	\fi
	\def\pgfplots@loc@TMPb{jump}%
	\ifx\pgfplots@loc@TMPa\pgfplots@loc@TMPb
		\def\pgfplots@loc@TMPa{nan}% alias for jump
	\fi
	\def\pgfplots@loc@TMPb{no op}%
	\ifx\pgfplots@loc@TMPa\pgfplots@loc@TMPb
		\def\pgfplots@loc@TMPa{none}% alias for no op
	\fi
	\pgfutil@ifundefined{pgfplotsscanlinelength@\pgfplots@loc@TMPa @initzero}{%
		\pgfplots@error{Sorry, the choice `empty line=\pgfkeysvalueof{/pgfplots/empty line}' is unknown. Maybe you misspelled it}%
	}{}%
	\expandafter\let\expandafter\pgfplotsscanlinelength@initzero	\csname pgfplotsscanlinelength@\pgfplots@loc@TMPa @initzero\endcsname
	\expandafter\let\expandafter\pgfplotsscanlinelengthincrease		\csname pgfplotsscanlinelength@\pgfplots@loc@TMPa @increase\endcsname
	\edef\pgfplotsscanlinecomplete{%
		\expandafter\noexpand\csname pgfplotsscanlinelength@\pgfplots@loc@TMPa @complete\endcsname
		\noexpand\pgfplotsplothandlernotifyscanlinecomplete
	}%
	\expandafter\let\expandafter\pgfplotsscanlinelengthcleanup		\csname pgfplotsscanlinelength@\pgfplots@loc@TMPa @cleanup\endcsname
	\pgfplotsscanlinelength@initzero
}%

\newif\ifpgfplots@emptyline@compat

% Invoked for 'empty line=auto'. 
%
% @POSTCONDITION: '/pgfplots/empty line' is set to something useful
% (not auto)
\def\pgfplotsdetermineemptylinehandler{%
	\if n\pgfplots@meshmode
		% no mesh/surf plot:
		\pgfkeyssetvalue{/pgfplots/empty line}{jump}%
		\ifpgfplots@emptyline@compat
			\pgfkeyssetvalue{/pgfplots/empty line}{none}% do nothing for backwards compatibility with 2D processing.
		\fi
	\else
		% it is a mesh or surf plot; use scanline:
		\pgfkeyssetvalue{/pgfplots/empty line}{scanline}%
	\fi
}%
\def\pgfplotsscanlinedisablechanges{%
	\let\pgfplotsscanlinecomplete=\relax
	\let\pgfplotsscanlinelengthincrease=\relax
	\let\pgfplotsscanlinelengthcleanup=\relax
	\let\pgfplotsscanlinelengthinitzero=\relax
	\let\pgfplotsscanlineendofinput=\relax
}%

% -------------------------------------------------------------------------------
% empty line=scanline
% class:
\def\pgfplotsscanlinelength@scanline@initzero{%
	\c@pgfplots@scanlineindex=0
	\def\pgfplots@scanlinelength{-1}%
}
\def\pgfplotsscanlinelength@scanline@increase{%
	\advance\c@pgfplots@scanlineindex by1
}
\def\pgfplotsscanlinelength@scanline@complete{%
	\ifnum\pgfplots@scanlinelength>0
		\ifnum\c@pgfplots@scanlineindex=0
			% 
			% \pgfplotsscanlinecomplete
			% \pgfplotsscanlinecomplete
			% \pgfplotsscanlinecomplete
			% should have the same effect as a single statement. Do
			% nothing here.
		\else
			\ifnum\pgfplots@scanlinelength=\c@pgfplots@scanlineindex\relax
			\else
%\message{Found inconsistent scan line length: \pgfplots@scanlinelength\space vs. \the\c@pgfplots@scanlineindex\space near line \pgfplotstablelineno.}%
				% special marker which means 'inconsistent scan line length found'
				\def\pgfplots@scanlinelength{-2}%
			\fi
		\fi
	\else
		\ifnum\pgfplots@scanlinelength=-2
		\else
			\edef\pgfplots@scanlinelength{\the\c@pgfplots@scanlineindex}%
		\fi
	\fi
	\c@pgfplots@scanlineindex=0
}
\def\pgfplotsscanlinelength@scanline@cleanup{%
	\ifnum\c@pgfplots@scanlineindex=0
		% I assume the last scan line is already complete.
	\else
		\pgfplotsscanlinecomplete
	\fi
	\let\pgfplotsscanlinelength=\pgfplots@scanlinelength
}
% -------------------------------------------------------------------------------
%
% empty line=none   class:
% 
\let\pgfplotsscanlinelength@none@initzero=\pgfutil@empty
\let\pgfplotsscanlinelength@none@increase=\relax
\let\pgfplotsscanlinelength@none@complete=\relax
\let\pgfplotsscanlinelength@none@cleanup=\relax
% -------------------------------------------------------------------------------
%
% empty line=nan   class:
\def\pgfplotsscanlinelength@nan@initzero{%
	\def\pgfplotsscanlinelength@nan@isfirst{1}%
	\let\pgfplotsscanlinelength@nan@pendingwork=\relax
	\pgfplotsifinaxis{}{\let\pgfplotsaxisserializedatapoint=\relax}%
}%
\def\pgfplotsscanlinelength@nan@increase{%
	\def\pgfplotsscanlinelength@nan@isfirst{0}%
	\pgfplotsscanlinelength@nan@pendingwork
}%
\def\pgfplotsscanlinelength@nan@complete{%
	\if1\pgfplotsscanlinelength@nan@isfirst
	\else
		\def\pgfplotsscanlinelength@nan@pendingwork{%
			% this will be executed when the next point has been
			% found.
			\def\pgfplots@current@point@x{}%
			\def\pgfplots@current@point@y{}%
			\def\pgfplots@current@point@z{}%
			% simply serialize an empty point. That works -- the
			% visualization phase checks if the coordinates are empty and
			% visualizes them as "jump"
			%
			% Note that \pgfplotsplothandlersurveypoint is not a good
			% choice here unless one employs its 'unbounded coords=jump'
			% feature
			\def\pgfplotsaxisplothasjumps{1}%
			\pgfplotsaxisserializedatapoint
			%
			\let\pgfplotsscanlinelength@nan@pendingwork=\relax
		}%
	\fi
	\def\pgfplotsscanlinelength@nan@isfirst{1}%
}%
\let\pgfplotsscanlinelength@nan@cleanup=\relax
% 
% -------------------------------------------------------------------------------


\def\pgfplotsaxisfilteredcoordsaway{0}%
\def\pgfplotsaxisplothasjumps{0}%
\newif\ifpgfplotsaxisparsecoordinateok

% Initialises 
% \pgfplots@coord@stream@start
% \pgfplots@coord@stream@coord
% \pgfplots@coord@stream@end
% such that a following coordinate stream is processed properly. The
% following coordinate stream may come from different input methods.
%
% This coordinate stream is the first time a coordinate will be
% reported and processed by pgfplots. The task of this first pass is
% to
% - compute and update any axis limits,
% - collect and prepare ranges for color data,
% - handle stacked plots and error bars,
% - store the complete state of the plot's preprocessing in an
%   internal datastructure for later completion.
%   This involves a serialization of all processed points (i.e. the
%   generation of a long coordinate list)
%
% Any \addplot command should issue \pgfplots@PREPARE@COORD@STREAM
% eventually.
%
% Arguments:
% #1:  any trailing path commands after the 'plot' command as such,
%      for example \addplot plot coordinates {...} -- (0,0);
%      would yield #1 =' -- (0,0)'
%
% PRECONDITION:
% 	- needs to be called inside of \addplot.
% 	- \pgfplots@addplot@survey@@optionlist contains the <options>
% 	provided to \addplot (all of them, including automatically
% 	determined ones)
%
% REMARK:
% 	The following code is permissable:
% 		\pgfplots@PREPARE@COORD@STREAM{...}
% 		\pgfplots@coord@stream@start
% 		...
% 		\pgfplots@coord@stream@coord
% 		..
%		\pgfplots@coord@stream@coord
%		..
% 		\pgfplots@coord@stream@end
% 	-> All need to be the SAME LEVEL OF SCOPING! The '@coord' commands
% 	may not be scoped deeper than 'begin' and 'end'!
% 	- I had a version which allowed that. it was actually slower!
% 	- For now, the following things are global / local:
% 		- point coordinate list: local
% 		- meta data limits: global,
% 		- recorded error bar commands: local,
% 		- what about stacked plot stuff: appears to be a combination
% 		of local/global.
% 		- all that will be serialized and written into
% 		\pgfplots@stored@plotlist in \pgfplots@coord@stream@end.
% 	This list is global, so, if I am not mistaken, the scoping
% 	level of the complete stream operation from setup to @end can
% 	be as deep as necessary - as long as all operations have the
% 	same level of scoping.
%
% @see the detailed documentation in pgfplotsplothandlers.code.tex
\long\def\pgfplots@PREPARE@COORD@STREAM#1{%
	\ifpgfplots@curplot@threedim
		\global\pgfplots@threedimtrue
	\fi
	\def\pgfplotsaxisfilteredcoordsaway{0}%
	\def\pgfplotsaxisplothasjumps{0}%
	%
	\ifpgfplots@curplot@threedim
		\let\pgfplotsaxisupdatelimitsforcoordinate=\pgfplotsaxisupdatelimitsforcoordinatethreedim
		\let\pgfplotsaxisparsecoordinate=\pgfplotsaxisparsecoordinatethreedim
	\else
		\let\pgfplotsaxisupdatelimitsforcoordinate=\pgfplotsaxisupdatelimitsforcoordinatetwodim
		\let\pgfplotsaxisparsecoordinate=\pgfplotsaxisparsecoordinatetwodim
	\fi
	\begingroup
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\let\E=\noexpand
	% 
%\message{Assembled update-limits \ifpgfplots@curplot@threedim 3D\else 2D\fi macro to {\meaning\pgfplotsaxisupdatelimitsforcoordinate}}%
	\ifpgfplots@bb@isactive
	\else
		% we are inside of 
		% \pgfplotsinterruptdatabb 
		% ..
		% \endpgfinterruptboundingbox
		% -> don't change data limits!
		\gdef\pgfplotsaxisupdatelimitsforcoordinate##1##2##3{}%
	\fi
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	%
	%
	% Takes a coordinate which is already parsed and applies steps
	% such that it becomes its final values.
	%
	% This implements the stacked plot feature currently.
	%
	% PRECONDITION:
	% 	\pgfplotsaxisparsecoordinate has already been called.
	%
	% POSTCONDITION:
	% 	the point has its final coordinates; the axis won't change it
	% 	anymore.
	\xdef\pgfplotsaxispreparecoordinate{%
		\E\ifpgfplotsaxisparsecoordinateok
			% All following routines (limit updating/stacking/error
			% bars) will use float numerics if necessary (controlled
			% by ifs).
			\E\pgfplotsaxistransformfromdatacs
			\ifpgfplots@stackedmode
				\E\pgfplots@stacked@preparepoint@inmacro%
			\fi
		\E\fi
	}%
	%
	% A macro which should be called once for every data point during the
	% survey phase.
	%
	% The caller is the plot handler's point survey routine.
	%
	% A data point might be a complicated thing which contains
	% multiple coordinates. You need to invoke
	% \pgfplotsaxisparsecoordinate and 
	% \pgfplotsaxispreparecoordinate for each of them. But
	% \pgfplotsaxisdatapointsurveyed is invoked once for the complete
	% set.
	% 
	% @PRECONDITION
	% 	- \pgfplots@current@point@[xyz] contain final coordinates
	% 	(i.e. output of \pgfplotsaxispreparecoordinate)
	%
	% @POSTCONDITION
	% 	- stacked plot things, 
	% 	- error bars,
	% 	- xtick=data
	% 	are all processed.
	%
	\xdef\pgfplotsaxisdatapointsurveyed{%
		\E\ifpgfplotsaxisparsecoordinateok
			% All following routines (limit updating/stacking/error
			% bars) will use float numerics if necessary (controlled
			% by ifs).
			%
			% Prepare \pgfplots@current@point@meta (see the preparation
			% routine above):
			\E\pgfplots@set@perpointmeta
			%
			\ifpgfplots@errorbars@enabled
				% This thing gets the 'current@point@...' context,
				% that means 
				% \pgfplots@current@point@[xy]
				% \pgfplots@current@point@[xy]@error
				% \pgfplots@current@point@[xy]@unfiltered
				\E\pgfplots@PREPARE@errorbar@process@x%
				\E\pgfplots@PREPARE@errorbar@process@y%
				\E\pgfplots@PREPARE@errorbar@process@z%
			\fi
			%
			\ifpgfplots@collect@firstplot@astick
				\ifnum\pgfplots@numplots=0
					\E\ifx\E\pgfplots@firstplot@coords@x\E\pgfutil@empty
						\E\t@pgfplots@tokc={}%
					\E\else
						\E\t@pgfplots@tokc=\E\expandafter{\E\pgfplots@firstplot@coords@x,}%
					\E\fi
					\E\xdef\E\pgfplots@firstplot@coords@x{\E\the\E\t@pgfplots@tokc\E\pgfplots@current@point@x}%
					\E\ifx\E\pgfplots@firstplot@coords@y\E\pgfutil@empty
						\E\t@pgfplots@tokc={}%
					\E\else
						\E\t@pgfplots@tokc=\E\expandafter{\E\pgfplots@firstplot@coords@y,}%
					\E\fi
					\E\xdef\E\pgfplots@firstplot@coords@y{\E\the\E\t@pgfplots@tokc\E\pgfplots@current@point@y}%
					%
					\ifpgfplots@curplot@threedim
						\E\ifx\E\pgfplots@firstplot@coords@z\E\pgfutil@empty
							\E\t@pgfplots@tokc={}%
						\E\else
							\E\t@pgfplots@tokc=\E\expandafter{\E\pgfplots@firstplot@coords@z,}%
						\E\fi
						\E\xdef\E\pgfplots@firstplot@coords@z{\E\the\E\t@pgfplots@tokc\E\pgfplots@current@point@z}%
					\fi
				\fi
			\fi
			\E\pgfplotscoordstream@firstlast@update
			\E\pgfplotsaxisserializedatapoint
		\E\else
			% COORDINATE HAS BEEN FILTERED AWAY:
			%
			% make ALL empty to simplify special case checking:
			\E\let\E\pgfplots@current@point@x=\E\pgfutil@empty
			\E\let\E\pgfplots@current@point@y=\E\pgfutil@empty
			\E\let\E\pgfplots@current@point@z=\E\pgfutil@empty
			% check whether we have UNBOUNDED or just unfiltered
			% coords:
			\if\pgfplots@unbounded@handler d% unbounded coords=discard
				\E\def\E\pgfplotsaxisfilteredcoordsaway{1}%
				\ifpgfplots@warn@for@filter@discards
					\E\pgfplots@message{%
						NOTE: coordinate (\E\pgfplots@current@point@x@unfiltered,\E\pgfplots@current@point@y@unfiltered\ifpgfplots@curplot@threedim,\E\pgfplots@current@point@z@unfiltered\fi)
						has been dropped because 
						\E\ifx\E\pgfplots@unbounded@dir\E\pgfutil@empty
							of a coordinate filter.
						\E\else
							it is unbounded (in \E\pgfplots@unbounded@dir).
						\E\fi
					}%
				\fi
			\else
				% unbounded coords=jump
				\E\ifx\E\pgfplots@unbounded@dir\E\pgfutil@empty
					\E\def\E\pgfplotsaxisfilteredcoordsaway{1}%
					\ifpgfplots@warn@for@filter@discards
						\E\pgfplots@message{%
							NOTE: coordinate (\E\pgfplots@current@point@x@unfiltered,\E\pgfplots@current@point@y@unfiltered\ifpgfplots@curplot@threedim,\E\pgfplots@current@point@z@unfiltered\fi)
							has been dropped because of a coordinate filter.
						}%
					\fi
				\E\else
					\E\def\E\pgfplotsaxisplothasjumps{1}%
					\E\pgfplotsaxisserializedatapoint
				\E\fi
			\fi
		\E\fi
		%
		% increase \pgfplots@current@point@coordindex:
		\E\advance\E\c@pgfplots@coordindex by1
	}%
	%
	%
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\endgroup
	%
	\def\pgfplotsaxissurveysetpointmeta{\pgfplots@set@perpointmeta}%
	%
%\message{Prepared macro \string\pgfplots@update@limits@for@one@point: {\meaning\pgfplotsaxisupdatelimitsforcoordinate}}%
%\message{Prepared macro \string\pgfplots@process@one@point: {\meaning\pgfplots@process@one@point}}%
	% 
	\let\pgfplots@coord@stream@start@=\pgfplots@PREPARE@COORD@STREAM@start@
	\def\pgfplots@coord@stream@coord@{%
		\def\pgfplots@set@perpointmeta@done{0}%
		\pgfplotsplothandlersurveypoint
	}%
	\def\pgfplots@coord@stream@end@{\pgfplots@PREPARE@COORD@STREAM@end@{#1}}%
}%

% The \pgfplots@coord@stream@start@ routine used inside of
% \pgfplots@PREPARE@COORD@STREAM.
%
% It prepares everything for the first pass through all input
% coordinates.
\def\pgfplots@PREPARE@COORD@STREAM@start@{%
	% The current implementation of pgfplots stores the preprocessed
	% coordinate stream into a long list of coordinates.
	% Since macro append is an expensive operation, it uses the highly
	% optimized 'applistXX' structure:
	\pgfplotsapplistXXnewempty
	%
	\csname pgfpmeta@\pgfplotspointmetainputhandler @activate\endcsname
	\pgfplotsplothandlersurveystart
	\pgfplotscoordstream@firstlast@init
	%
	\pgfkeyssetvalue{/data point/x}{\pgfplots@current@point@x}%
	\pgfkeyssetvalue{/data point/y}{\pgfplots@current@point@y}%
	\pgfkeyssetvalue{/data point/z}{\pgfplots@current@point@z}%
	\pgfkeyssetvalue{/data point/meta}{\pgfplots@current@point@meta}%
	%
	\pgfplots@prepare@visualization@dependencies
	%
	\ifpgfplots@errorbars@enabled
		% prepare error bar processing.
		%
		% The actual implementation stores every final drawing command
		% into a list. 
		%
		% Prepare that list:
		\pgfplots@streamerrorbar@recordto{\pgfplots@recordederrorbar}%
		\pgfplots@streamerrorbarstart
		%
		% Now, prepare the coordinate processing for errorbars:
		\pgfplots@PREPARE@errorbar@processing@in@dir x%
		\pgfplots@PREPARE@errorbar@processing@in@dir y%
		\ifpgfplots@curplot@threedim
			\pgfplots@PREPARE@errorbar@processing@in@dir z%
		\else
			\let\pgfplots@PREPARE@errorbar@process@z=\relax
		\fi
	\else
		\let\pgfplots@recordederrorbar=\pgfutil@empty
	\fi
	\ifpgfplots@stackedmode
		\pgfplots@stacked@beginplot
	\fi
	%
	% Inside of math expressions, 'x', 'y' and 'z' expand to the
	% current x,y and z coords respectively. Introduce these (and some
	% more) shortcuts:
	\pgfplotsmathdeclarepseudoconstant{x}{\let\pgfmathresult=\pgfplots@current@point@x}%
	\pgfplotsmathdeclarepseudoconstant{y}{\let\pgfmathresult=\pgfplots@current@point@y}%
	\pgfplotsmathdeclarepseudoconstant{z}{\let\pgfmathresult=\pgfplots@current@point@z}%
	\pgfplotsmathdeclarepseudoconstant{rawx}{\let\pgfmathresult=\pgfplots@current@point@x@unfiltered}%
	\pgfplotsmathdeclarepseudoconstant{rawy}{\let\pgfmathresult=\pgfplots@current@point@y@unfiltered}%
	\pgfplotsmathdeclarepseudoconstant{rawz}{\let\pgfmathresult=\pgfplots@current@point@z@unfiltered}%
	\pgfplotsmathdeclarepseudoconstant{meta}{%
		\let\pgfmathresult=\pgfplots@current@point@meta
		\ifx\pgfmathresult\pgfutil@empty
			\pgfplotscoordmath{meta}{parsenumber}{0}%
		\fi
	}%
	%
	% %%%%%%%%%%%%%%
	%
	% Define \pgfplots@set@perpointmeta properly:
	\def\pgfplots@set@perpointmeta{%
		\if0\pgfplots@set@perpointmeta@done
			\csname pgfpmeta@\pgfplotspointmetainputhandler @assign\endcsname
			\def\pgfplots@set@perpointmeta@done{1}%
			\pgfplots@set@perpointmeta@limits
		\fi
	}%
	% append limit updating to \pgfplots@set@perpointmeta :
	\if0\csname pgfpmeta@\pgfplotspointmetainputhandler @issymbolic\endcsname
		% We need to work with per point meta data.
		% So, also compute the data range on a per-plot basis!
		% These limits are important later.
		\pgfkeysgetvalue{/pgfplots/point meta min}\pgfplots@metamin
		\t@pgfplots@tokb={}%
		\ifx\pgfplots@metamin\pgfutil@empty
			\global\let\pgfplots@metamin=\pgfplots@invalidrange@metamin
			\t@pgfplots@tokb=\expandafter{\the\t@pgfplots@tokb
				\pgfplotscoordmath{meta}{min}{\pgfplots@metamin}{\pgfplots@current@point@meta}%
				\global\let\pgfplots@metamin=\pgfmathresult
			}%
		\else
			\pgfplotscoordmath{meta}{parsenumber}{\pgfplots@metamin}%
			\global\let\pgfplots@metamin=\pgfmathresult
		\fi
		\pgfkeysgetvalue{/pgfplots/point meta max}\pgfplots@metamax
		\ifx\pgfplots@metamax\pgfutil@empty
			\global\let\pgfplots@metamax=\pgfplots@invalidrange@metamax
			\t@pgfplots@tokb=\expandafter{\the\t@pgfplots@tokb
				\pgfplotscoordmath{meta}{max}{\pgfplots@metamax}{\pgfplots@current@point@meta}%
				\global\let\pgfplots@metamax=\pgfmathresult
			}%
		\else
			\pgfplotscoordmath{meta}{parsenumber}{\pgfplots@metamax}%
			\global\let\pgfplots@metamax=\pgfmathresult
		\fi
		%
		\edef\pgfplots@set@perpointmeta@limits{%
			\noexpand\ifx\noexpand\pgfplots@current@point@meta\noexpand\pgfutil@empty
			\noexpand\else
				\the\t@pgfplots@tokb
			\noexpand\fi
		}%
		\def\pgfplotsaxisupdatelimitsforpointmeta##1{%
			\begingroup
			\def\pgfplots@current@point@meta{##1}%
			\pgfplots@set@perpointmeta@limits
			\endgroup
		}%
	\else
		% there is no point meta:
		\global\let\pgfplots@metamin=\pgfutil@empty
		\global\let\pgfplots@metamax=\pgfutil@empty
		\let\pgfplots@set@perpointmeta@limits=\relax
		\def\pgfplotsaxisupdatelimitsforpointmeta##1{}%
	\fi
}%
% This is the \pgfplots@coord@stream@end@ routine which is invoked by
% \pgfplots@PREPARE@COORD@STREAM. 
%
% It finalizes the first pass through the input coordinates and
% remembers the preprocessed \addplot command.
%
% Technical note: The parameters provided to
% \pgfplots@PREPARE@COORD@STREAM
% are needed here. This doesn't fit directly into the framework of
% coordinate streams, see \pgfplots@PREPARE@COORD@STREAM how this
% invocation works.
%
% #1,#2: see \pgfplots@PREPARE@COORD@STREAM
\def\pgfplots@PREPARE@COORD@STREAM@end@#1{%
	\pgfkeysvalueof{/pgfplots/execute at end survey}%
	\pgfkeyssetvalue{/pgfplots/mesh/num points}{\pgfplots@current@point@coordindex}%
	\pgfplotsplothandlersurveyend
	\ifx\pgfplots@metamin\pgfutil@empty
	\else
		\if\pgfplots@axiswide@metamin@autocompute1%
			\pgfplotscoordmath{meta}{min}{\pgfplots@axiswide@metamin}{\pgfplots@metamin}%
			\global\let\pgfplots@axiswide@metamin=\pgfmathresult
		\fi
		\if\pgfplots@axiswide@metamax@autocompute1%
			\pgfplotscoordmath{meta}{max}{\pgfplots@axiswide@metamax}{\pgfplots@metamax}%
			\global\let\pgfplots@axiswide@metamax=\pgfmathresult
		\fi
	\fi
	\if1\pgfplots@colorbar@set@src% this 0|1 switch is set in \pgfplots@start@plot@with@behavioroptions
		\ifx\pgfplots@metamin\pgfutil@empty
			\pgfplotsthrow{no such element}{\pgfplots@loc@TMPa}{Sorry, `colorbar source' can't be processed: the current \string\addplot\space command doesn't have point meta. Ignoring it.}\pgfeov%
		\else
			\global\let\pgfplots@colorbar@src@metamin=\pgfplots@metamin
			\global\let\pgfplots@colorbar@src@metamax=\pgfplots@metamax
		\fi
	\fi
	\ifpgfplots@autocompute@all@limits
		\global\let\pgfplots@data@xmin=\pgfplots@xmin
		\global\let\pgfplots@data@xmax=\pgfplots@xmax
		\global\let\pgfplots@data@ymin=\pgfplots@ymin
		\global\let\pgfplots@data@ymax=\pgfplots@ymax
		\global\let\pgfplots@data@zmin=\pgfplots@zmin
		\global\let\pgfplots@data@zmax=\pgfplots@zmax
	\fi
	\ifpgfplots@errorbars@enabled
		\pgfplots@streamerrorbarend
	\fi
	\ifpgfplots@stackedmode
		\pgfplots@stacked@endplot
	\fi
	\ifx\pgfplots@currentplot@firstcoord@x\pgfutil@empty
		\pgfplots@warning{the current plot has no coordinates (or all have been filtered away)}%
	\else
		% Idea: use
		%   \scope[plot specification]
		%   <any paths for error bars>
		%   \endscope
		%   \draw plot coordinates {...};
		% to share plot specifications between error bars and plot
		% coordinates. Unfortunately, it is NOT sufficient to use
		% \tikzset
		\pgfplotspreparemeshkeydefaults%
		\pgfplots@PREPARE@COORD@STREAM@end@determinecoordsorting x%
		\pgfplots@PREPARE@COORD@STREAM@end@determinecoordsorting y%
		\t@pgfplots@tokc=\expandafter{\pgfplots@addplot@survey@@optionlist,%
			/pgfplots/.cd,/pgfplots/every axis plot post}%
		\edef\pgfplots@addplot@survey@@optionlist{\the\t@pgfplots@tokc}%
		\ifpgfplots@curplot@isirrelevant
			% for \label commands:
			\expandafter\pgfplots@rememberplotspec@for@label\expandafter{\pgfplots@addplot@survey@@optionlist}%
		\else
			\expandafter\pgfplots@rememberplotspec\expandafter{\pgfplots@addplot@survey@@optionlist}%
		\fi
		% warning: rememberplotspec calls list macros which
		% overwrite \t@pgfplots@toka
		\t@pgfplots@toka=\expandafter{\pgfplots@addplot@survey@@optionlist}%
		% ATTENTION: do NOT call list macros from here on!
		%
		\pgfplotsplothandlerserializestateto\pgfplots@loc@TMPa
		\t@pgfplots@tokb=\expandafter{\pgfplots@loc@TMPa}%
		% SERIALIZE RESULT:
		%
		% everything which has been accumulated so far (including the
		% preprocessed coordinates) will be serialized into the
		% structure \pgfplots@stored@plotlist (globally).
		%
		% assemble a \pgfplots@addplot@enqueue@coords command ...
		% BEGIN HERE ...
		% vvvvvvvvvv
		\xdef\pgfplots@glob@TMPa{%
			\noexpand\pgfplots@addplot@enqueue@coords
			{% precommand(s):
				\expandafter\noexpand\csname pgfplots@curplot@threedim\ifpgfplots@curplot@threedim true\else false\fi\endcsname
				\noexpand\def\noexpand\plotnum{\the\pgfplots@numplots}%
				%
				% store \plotnumofactualtype
				\noexpand\def\noexpand\plotnumofactualtype{\numplotsofactualtype}%
				% ... and make sure that it 
				% remains the same type even if some plot handler uses
				% other plot handlers internally:
				\noexpand\def\noexpand\pgfplotsplothandlername@actual{\pgfplotsplothandlername@actual}%
				\noexpand\let\noexpand\numplotsofactualtype\noexpand\pgfplots@numplotsofactualtype@duringplot
				%
				\noexpand\def\noexpand\numcoords{\pgfplots@current@point@coordindex}%
				% \pgfplots@current@point@coordindex will always contain the current index.
				% Maybe overwritten if not provided using \c@pgfplots@coordindex.
				\noexpand\def\noexpand\pgfplots@current@point@coordindex{\noexpand\the\noexpand\c@pgfplots@coordindex}%
				\noexpand\def\noexpand\coordindex{\noexpand\pgfplots@current@point@coordindex}% valid inside of \addplot
				%
				% save the possibly prepare/adjusted plot
				% variables [FIXME: move after \pgfplots@define@currentplotstyle@as ?]:
				\noexpand\pgfkeyssetvalue{/pgfplots/samples}{\pgfplots@plot@samples}%
				\noexpand\pgfkeyssetvalue{/pgfplots/domain}{\pgfplots@plot@domain}%
				\noexpand\pgfkeyssetvalue{/pgfplots/samples at}{\pgfplots@plot@samples@at}%
				\noexpand\pgfkeyssetvalue{/pgfplots/mesh/rows}{\pgfkeysvalueof{/pgfplots/mesh/rows}}%
				\noexpand\pgfkeyssetvalue{/pgfplots/mesh/cols}{\pgfkeysvalueof{/pgfplots/mesh/cols}}%
				\noexpand\pgfkeyssetvalue{/pgfplots/mesh/num points}{\pgfkeysvalueof{/pgfplots/mesh/num points}}%
				% either '+' or '-' :
				\noexpand\pgfkeyssetvalue{/pgfplots/x coord sorting}{\pgfkeysvalueof{/pgfplots/x coord sorting}}%
				\noexpand\pgfkeyssetvalue{/pgfplots/y coord sorting}{\pgfkeysvalueof{/pgfplots/y coord sorting}}%
				%
				\noexpand\pgfplots@initzerolevelhandler
				\noexpand\pgfplots@define@currentplotstyle@as{\the\t@pgfplots@toka}% remember 'current plot style'
				% per-point meta data ranges which apply only to
				% this plot:
				\noexpand\xdef\noexpand\pgfplots@metamin{\pgfplots@metamin}%
				\noexpand\xdef\noexpand\pgfplots@metamax{\pgfplots@metamax}%
				\noexpand\def\noexpand\pgfplotspointmetainputhandler{\pgfplotspointmetainputhandler}%
				\noexpand\def\noexpand\pgfplots@serialized@state@plothandler{\the\t@pgfplots@tokb}%
				\noexpand\def\noexpand\pgfplotsaxisfilteredcoordsaway{\pgfplotsaxisfilteredcoordsaway}%
				\noexpand\def\noexpand\pgfplotsaxisplothasjumps{\pgfplotsaxisplothasjumps}%
			}%
			{% draw command:
				\noexpand\path%
			}%
		}%
		\pgfplotsapplistXXlet\pgfplots@coord@stream@recorded
		\pgfplotsapplistXXclear
		\t@pgfplots@tokc=\expandafter{\pgfplots@coord@stream@recorded}%
		\t@pgfplots@tokb={#1;}%
		\t@pgfplots@toka=\expandafter{\pgfplots@glob@TMPa}%
		\xdef\pgfplots@glob@TMPa{%
			\the\t@pgfplots@toka
			{% coordinates which need to be processed in \endaxis.
			% See
			% \pgfplots@coord@stream@finalize@storedcoords@START
				normalized coordinates {\the\t@pgfplots@tokc}\the\t@pgfplots@tokb
			}%
		}%
		%
		% Ok, now assemble the POST COMMANDS. Error bar
		% commands will be append here (if any)
		\ifx\pgfplots@recordederrorbar\pgfutil@empty
			\pgfplots@glob@TMPa
				{%
					% Post commands are empty here.
				}%
		\else
			\t@pgfplots@toka=\expandafter{\pgfplots@glob@TMPa}%
			\t@pgfplots@tokb=\expandafter{\pgfplots@recordederrorbar}%
			\def\pgfplots@loc@TMPb{%
				\noexpand\pgfplots@errorbars@finishwithstyleoptions[current plot style]{\the\t@pgfplots@tokb}%
			}%
			\xdef\pgfplots@glob@TMPa{
				\the\t@pgfplots@toka
				{
					% Post commands: append error bar commands.
					\pgfplots@loc@TMPb
				}%
			}%
			\pgfplots@glob@TMPa
		\fi
		%^^^^^^^^^^^^ ... END of \pgfplots@addplot@enqueue@coords HERE
	\fi
	\pgfplots@end@plot
}%


% A routine which transforms the current set of
% \pgfplots@current@point@[xyz] values to the coordinate system
% accepted by the actual axis.
\def\pgfplotsaxistransformfromdatacs{%
	\pgfkeyslet{/data point/x}\pgfplots@current@point@x
	\pgfkeyslet{/data point/y}\pgfplots@current@point@y
	\pgfkeyslet{/data point/z}\pgfplots@current@point@z
	\pgfplotsaxistransformcs
		{\pgfkeysvalueof{/pgfplots/data cs}}
		{\pgfkeysvalueof{/pgfplots/@expected axis cs}}%
	\pgfkeysgetvalue{/data point/x}\pgfplots@current@point@x
	\pgfkeysgetvalue{/data point/y}\pgfplots@current@point@y
	\pgfkeysgetvalue{/data point/z}\pgfplots@current@point@z
}%

% Changes '/data point/[xyz]' to the new coordinate system
% (cs) designated by '#2'.
%
% #1: the actual coordinate system's name
% #2: the desired coordinate system's name
%
% PRECONDITION: '/data point/[xyz]' contain the current
% point's coordinates in the '#1' system. The z coordinate is ignored for 2d plots (or
% for coordinate systems which are inherently two-dimensional).
%
% POSTCONDITION: 'data point/[xyz]' contain same point as
% before, but represented in the '#2' system.
%
% The coordinate system transformations must be defined,
% see \pgfplotsdefinecstransform.
%
% Example:
% \pgfkeyssetvalue{/data point/x}{90}
% \pgfkeyssetvalue{/data point/y}{1}
% \pgfplotsaxistransformcs{polar}{cart}
% -->
%  \pgfkeysvalueof{/data point/x}= 0
%  \pgfkeysvalueof{/data point/y}= 1
\def\pgfplotsaxistransformcs#1#2{%
	\edef\pgfplots@loc@TMPa{#1}%
	\edef\pgfplots@loc@TMPb{#2}%
	\ifx\pgfplots@loc@TMPa\pgfplots@loc@TMPb
		% nothing to do
	\else
		\pgfutil@ifundefined{pgfp@transform@\pgfplots@loc@TMPa @to@\pgfplots@loc@TMPb}{%
			\pgfutil@ifundefined{pgfp@transform@\pgfplots@loc@TMPa @to@cart}{%
				\pgfplotsaxistransformcs@error
			}{%
				\pgfplotsaxistransformcs{#1}{cart}%
				\pgfplotsaxistransformcs{cart}{#2}%
			}%
		}{%
			\csname pgfp@transform@\pgfplots@loc@TMPa @to@\pgfplots@loc@TMPb\endcsname
		}%
	\fi
}%

% Defines a new coordinate transformation for use in
% \pgfplotsaxistransformcs.
% #1: the source coordinate system
% #2: the target coordinate system
% #3: the transformation code. 
%
% @see \pgfplotsaxistransformcs for what #3 should do.
%
% This does also declare a coordinate system for use in 'data cs'.
% The minimal requirements are to define the transformations from and
% to "cart" (cartesian coordinates).
% 
\def\pgfplotsdefinecstransform#1#2#3{%
	\expandafter\def\csname pgfp@transform@#1@to@#2\endcsname{#3}%
}%

\pgfplotsdefinecstransform{polar}{cart}{%
	\pgfplotscoordmath{default}{parsenumber}{\pgfkeysvalueof{/data point/x}}%
	\let\pgfplots@current@point@x=\pgfmathresult
	\pgfplotscoordmath{default}{parsenumber}{\pgfkeysvalueof{/data point/y}}%
	\let\pgfplots@current@point@y=\pgfmathresult
	\pgfplotsmathpoltocart\pgfplots@current@point@x\pgfplots@current@point@y\pgfplots@current@point@x@\pgfplots@current@point@y@
	\pgfplotscoordmath{x}{parsenumber}{\pgfplots@current@point@x@}%
	\pgfkeyslet{/data point/x}\pgfmathresult
	\pgfplotscoordmath{y}{parsenumber}{\pgfplots@current@point@y@}%
	\pgfkeyslet{/data point/y}\pgfmathresult
}%
\pgfplotsdefinecstransform{cart}{polar}{%
	\pgfplotscoordmath{default}{parsenumber}{\pgfkeysvalueof{/data point/x}}%
	\let\pgfplots@current@point@x=\pgfmathresult
	\pgfplotscoordmath{default}{parsenumber}{\pgfkeysvalueof{/data point/y}}%
	\let\pgfplots@current@point@y=\pgfmathresult
	\pgfplotsmathcarttopol\pgfplots@current@point@x\pgfplots@current@point@y\pgfplots@current@point@x@\pgfplots@current@point@y@
	\pgfplotscoordmath{x}{parsenumber}{\pgfplots@current@point@x@}%
	\pgfkeyslet{/data point/x}\pgfmathresult
	\pgfplotscoordmath{y}{parsenumber}{\pgfplots@current@point@y@}%
	\pgfkeyslet{/data point/y}\pgfmathresult
}%

\pgfplotsdefinecstransform{polarrad}{polar}{%
	\pgfplotsgetcoordmathfor{default}\let\pgfplots@coordmath@id=\pgfplotsretval
	\pgfutil@ifundefined{pgfp@polarradscale@\pgfplots@coordmath@id}{%
		\pgfplotscoordmath{default}{parsenumber}{57.2957795130823}%
		\expandafter\global\expandafter\let\csname pgfp@polarradscale@\pgfplots@coordmath@id\endcsname=\pgfmathresult
	}{}%
	%
	\pgfplotscoordmath{default}{parsenumber}{\pgfkeysvalueof{/data point/x}}%
	\pgfplotscoordmath{default}{op}{multiply}{{\pgfmathresult}{\csname pgfp@polarradscale@\pgfplots@coordmath@id\endcsname}}%
	\pgfkeyslet{/data point/x}\pgfmathresult
}%
\pgfplotsdefinecstransform{polar}{polarrad}{%
	\pgfplotsgetcoordmathfor{default}\let\pgfplots@coordmath@id=\pgfplotsretval
	\pgfutil@ifundefined{pgfp@polarradiscale@\pgfplots@coordmath@id}{%
		\pgfplotscoordmath{default}{parsenumber}{0.0174532925199433}%
		\expandafter\global\expandafter\let\csname pgfp@polarradiscale@\pgfplots@coordmath@id\endcsname=\pgfmathresult
	}{}%
	%
	\pgfplotscoordmath{default}{parsenumber}{\pgfkeysvalueof{/data point/x}}%
	\pgfplotscoordmath{default}{op}{multiply}{{\pgfmathresult}{\csname pgfp@polarradiscale@\pgfplots@coordmath@id\endcsname}}%
}%
\pgfplotsdefinecstransform{polarrad}{cart}{%
	\pgfplotsaxistransformcs{polarrad}{polar}%
	\pgfplotsaxistransformcs{polar}{cart}%
}%
\pgfplotsdefinecstransform{cart}{polarrad}{%
	\pgfplotsaxistransformcs{cart}{polar}%
	\pgfplotsaxistransformcs{polar}{polarrad}%
}%

\def\pgfplotsaxistransformcs@error{%
	\pgfplotsthrow{invalid argument}{\pgfplots@loc@TMPa}{Sorry, I do not know how to transform the coordinate system '\pgfplots@loc@TMPa' to '\pgfplots@loc@TMPb'. Maybe you misspelled the 'data cs'? Or perhaps the feature is not yet implemented?}\pgfeov%
}%

\def\pgfplotsaxisserializedatapoint{%
	\pgfplotsplothandlerserializepointto\pgfplotsaxisserializedatapoint@val
	\pgfplotsaxisserializedatapoint@private
	\t@pgfplots@toka=\expandafter{\pgfplotsaxisserializedatapoint@val}%
	\t@pgfplots@tokb=\expandafter{\pgfplotsretval}%
	\edef\pgfplots@loc@TMPa{{\the\t@pgfplots@tokb;\the\t@pgfplots@toka}}%
	\expandafter\pgfplotsapplistXXpushback\expandafter{\pgfplots@loc@TMPa}%
}%
\def\pgfplotsaxisserializedatapoint@private{%
	\let\pgfplotsretval=\pgfplots@current@point@meta
}%
\def\pgfplotsaxisdeserializedatapointfrom@private#1{%
	\def\pgfplots@current@point@meta{#1}%
}%
% Restores the variables serialized in '#1'.
%
% As a side--effect, the macro
% \pgfplotsaxisdeserializedatapointfrom@private@lastvalue will contain
% the serialized part which is specific to pgfplots (i.e. the private
% parts which can be read with
% \pgfplotsaxisdeserializedatapointfrom@private)
\def\pgfplotsaxisdeserializedatapointfrom#1{%
	\expandafter\pgfplotsaxisdeserializedatapointfrom@#1\pgfplots@EOI
}%
\def\pgfplotsaxisdeserializedatapointfrom@#1;#2\pgfplots@EOI{%
	\def\pgfplotsaxisdeserializedatapointfrom@private@lastvalue{#1}%
	\pgfplotsaxisdeserializedatapointfrom@private{#1}%
	\pgfplotsplothandlerdeserializepointfrom{#2}%
}%

% Handle User-defined parts which should be serialized as well.
% This preparation tool should be called at the start of both, survey
% and visualization phase.
% 
% @PRECONDITION
% 	- the macros 
% 	\pgfplotsaxisserializedatapoint@private
% 	\pgfplotsaxisdeserializedatapointfrom@private
% 	are known and valid.
% 	- '/pgfplots/visualization depends on' contains its correct value.
%
% @POSTCONDITION
% 	Both,
% 	\pgfplotsaxisserializedatapoint@private
% 	and
% 	\pgfplotsaxisdeserializedatapointfrom@private
% 	have been patched to incorporate the '/pgfplots/visualization
% 	depends on' feature.
% 	
\def\pgfplots@prepare@visualization@dependencies{%
	\pgfkeysgetvalue{/pgfplots/visualization depends on/list}\pgfplots@loc@TMPa
	\ifx\pgfplots@loc@TMPa\pgfutil@empty
	\else
		% SERIALIZATION format:
		% visualization depends on={{value1}\as \macro1, {<value2>}\as \macro2,...}
		% ->
		% {<original private data>}<\macro1>{<value1>}<\macro2>{<value2>}...<\macroN>{<valueN>}
		%
		% prepare
		% \t@pgfplots@tokb={<\macro1>{<value1>}<\macro2>{<value2>}...<\macroN>{<valueN>}}
		\t@pgfplots@tokb={}%
		%
		% prepare
		% \t@pgfplots@tokc={<\macro1><\macro2><\macro3>...}
		\t@pgfplots@tokc={}% 
		\expandafter\pgfplotsutilforeachcommasep\expandafter{\pgfplots@loc@TMPa}\as\pgfplots@loc@TMPa{%
			\ifx\pgfplots@loc@TMPa\pgfutil@empty
			\else
				\expandafter\pgfplots@prepare@visualization@depends@on\pgfplots@loc@TMPa\pgfplots@EOI%
			\fi
		}%
		% Step 1: modify the SERIALIZATION method:
		\t@pgfplots@toka=\expandafter{\pgfplotsaxisserializedatapoint@private}%
		\edef\pgfplotsaxisserializedatapoint@private{%
			\the\t@pgfplots@tokc
			\the\t@pgfplots@toka
			% nothing is expanded here, only \t@pgfplots@tokb
			\noexpand\t@pgfplots@toka=\noexpand\expandafter{\noexpand\pgfplotsretval}%
			\noexpand\edef\noexpand\pgfplotsretval{{\noexpand\the\t@pgfplots@toka},\the\t@pgfplots@tokb}%
		}%
		% Step 2: modify the DESERIALIZATION method:
		\let\pgfplotsaxisdeserializedatapointfrom@private@orig=\pgfplotsaxisdeserializedatapointfrom@private
		\let\pgfplotsaxisdeserializedatapointfrom@private=\pgfplotsaxisdeserializedatapointfrom@private@withdeplist
	\fi
	%
	\pgfkeysgetvalue{/pgfplots/execute for finished point}\pgfplots@loc@TMPa
	\ifx\pgfplots@loc@TMPa\pgfplots@empty@command@key
	\else
		\expandafter\def\expandafter\pgfplotsaxisserializedatapoint@private\expandafter{%
			\pgfplotsaxisserializedatapoint@private
			\pgfkeysvalueof{/pgfplots/execute for finished point}%
		}%
	\fi
}%
\def\pgfplots@prepare@visualization@depends@on#1\pgfplots@EOI{%
	\pgfutil@in@\as{#1}%
	\ifpgfutil@in@
		% ok, we have the '<content>\as<\macro>' syntax:
		\pgfplots@prepare@visualization@depends@on@#1\pgfplots@EOI
	\else
		\pgfplots@prepare@visualization@depends@on@preparetype@checkvalue#1value\pgfplots@EOI
		\ifpgfutil@in@
			% ok, then it should be 'value <\macro>'.
			% extract the <\macro>:
			\def\pgfplots@loc@TMPa value{\pgfplots@loc@TMPb}%
			\def\pgfplots@loc@TMPb##1{\pgfplots@loc@TMPc ##1}% this step should remove leading white spaces
			\def\pgfplots@loc@TMPc##1\pgfplots@EOI{%
				% sanitize: check if ##1 is a defined macro:
				\begingroup
					\escapechar=-1
					\xdef\pgfplots@glob@TMPa{\string##1}%
				\endgroup
				\pgfutil@ifundefined{\pgfplots@glob@TMPa}{%	
					\begingroup
					\t@pgfplots@toka={##1}%
					\pgfplotsthrow{invalid argument}
						{\pgfplots@loc@TMPa}%
						{Sorry, `visualization depends on=value <\string\macro>' expected a defined control sequence name instead of `\the\t@pgfplots@toka'. Please make sure `\the\t@pgfplots@toka' is a properly defined macro or use the `visualization depends on=value <content> \string\as <\string\macro>' syntax instead}%
						\pgfeov
					\endgroup
				}{%
					\def\pgfplots@loc@TMPa{%
						\pgfplots@prepare@visualization@depends@on@ value}%
					\expandafter\pgfplots@loc@TMPa##1\as##1\pgfplots@EOI
				}%
			}%
			\pgfplots@loc@TMPa#1\pgfplots@EOI
		\else
			% then, I expect '<\macro>'.
			% sanitize: check if #1 is a defined macro:
			\begingroup
				\escapechar=-1
				\xdef\pgfplots@glob@TMPa{\string#1}%
			\endgroup
			\pgfutil@ifundefined{\pgfplots@glob@TMPa}{%	
				\begingroup
				\t@pgfplots@toka={#1}%
				\pgfplotsthrow{invalid argument}
					{\pgfplots@loc@TMPa}%
					{Sorry, `visualization depends on' expected a defined control sequence name instead of `\the\t@pgfplots@toka'. Please make sure `\the\t@pgfplots@toka' is a properly defined macro or use the `visualization depends on=<expression> \string\as <\string\macro>' syntax instead}%
					\pgfeov
				\endgroup
			}{%
				\expandafter\pgfplots@prepare@visualization@depends@on@#1\as#1\pgfplots@EOI
			}%
		\fi
	\fi
}%
\def\pgfplots@prepare@visualization@depends@on@#1\as#2\pgfplots@EOI{%
	\pgfplots@prepare@visualization@depends@on@preparetype{#1}\as{#2}%
	% prepare the serialization:
	\t@pgfplots@tokb=\expandafter{\the\t@pgfplots@tokb\noexpand#2{\csname\string#2@value\endcsname}}%
	\t@pgfplots@tokc=\expandafter{\the\t@pgfplots@tokc#2}%
}%
\def\pgfplots@prepare@visualization@depends@on@preparetype#1\as#2{%
	\pgfplots@prepare@visualization@depends@on@preparetype@checkvalue#1value\pgfplots@EOI
	\ifpgfutil@in@
		\pgfplots@prepare@visualization@depends@on@preparetype@value#1\as{#2}% no braces here.
	\else
		\pgfplots@prepare@visualization@depends@on@preparetype@expr{#1}\as{#2}%
	\fi
}%
\def\pgfplots@prepare@visualization@depends@on@preparetype@expr#1\as#2{%
	\pgflibraryfpuifactive{%
		\def#2{%
			\pgfmathparse{#1}%
			\pgfmathfloattofixed{\pgfmathresult}%
			\expandafter\let\csname \string#2@value\endcsname=\pgfmathresult
		}%
	}{%
		\def#2{%
			\pgfmathparse{#1}%
			\expandafter\let\csname \string#2@value\endcsname=\pgfmathresult
		}%
	}%
}
\def\pgfplots@prepare@visualization@depends@on@preparetype@checkvalue#1value#2\pgfplots@EOI{%
	\def\pgfplots@loc@TMPa{#1}%
	\ifx\pgfplots@loc@TMPa\pgfutil@empty
		\pgfutil@in@true
	\else
		\pgfutil@in@false
	\fi
}%
\def\pgfplots@prepare@visualization@depends@on@preparetype@value value#1\as#2{%
	\begingroup
	% remove spaces from #1:
	\pgfkeys@spdef\pgfplots@loc@TMPa{#1}%
	\t@pgfplots@toka=\expandafter{\pgfplots@loc@TMPa}%
	\t@pgfplots@tokb=\expandafter{\csname\string#2@value\endcsname}%
	\xdef\pgfplots@glob@TMPa{%
		\noexpand\def\the\t@pgfplots@tokb{\the\t@pgfplots@toka}%
	}%
	\endgroup
	\let#2=\pgfplots@glob@TMPa
}

\def\pgfplotsaxisdeserializedatapointfrom@private@withdeplist#1{%
	\pgfplotsaxisdeserializedatapointfrom@private@withdeplist@#1\pgfplots@EOI
}%
\def\pgfplotsaxisdeserializedatapointfrom@private@withdeplist@#1,{%
	\pgfplotsaxisdeserializedatapointfrom@private@orig{#1}%
	\pgfplotsaxisdeserializedatapointfrom@private@withdeplist@@
}%
\def\pgfplotsaxisdeserializedatapointfrom@private@withdeplist@@#1{%
	\def\pgfplots@loc@TMPa{#1}%
	\ifx\pgfplots@loc@TMPa\pgfplots@EOI
	\else
		\afterassignment\pgfplotsaxisdeserializedatapointfrom@private@withdeplist@@
		\expandafter\def\expandafter#1%
	\fi
}%

% PRECONDITION: must be called inside of
% \pgfplots@PREPARE@COORD@STREAM@end@.
%
% POSTCONDITION:
% 	assigns '/pgfplots/#1 coord sorting=[+-]' 
% 	i.e. whether #1 (x or y or z) coordinates are in ascending (+) ordering or in
% 	descending order (-).
\def\pgfplots@PREPARE@COORD@STREAM@end@determinecoordsorting#1{%
	\pgfplotscoordmath{#1}{if less than}
			{\csname pgfplots@currentplot@firstcoord@#1\endcsname}%
			{\csname pgfplots@currentplot@lastcoord@#1\endcsname}%
			{\pgfkeyssetvalue{/pgfplots/#1 coord sorting}{+}}%
			{\pgfkeyssetvalue{/pgfplots/#1 coord sorting}{-}}%
}%

% Prepares a macro \pgfplots@PREPARE@process@errorbar@for@dir##1
% which can then be used to process error bars. The macro will be
% \relax if error bars are disabled for #1.
%
% #1: either x, y or z.
%
% POSTCONDITION:
%   the macro \pgfplots@PREPARE@errorbar@process@#1 will be defined.
%   It is supposed to be used inside of the pgfplots streaming methods
%   and depends on the arguments
% 		\pgfplots@current@point@[xyz]
%		\pgfplots@current@point@[xyz]@unfiltered
%		\pgfplots@current@point@[xyz]@error
%	The '@unfilterered' arguments are needed for log plots. I do not
%	want to compute exp(current@point@[xyz]) again.
\def\pgfplots@PREPARE@errorbar@processing@in@dir#1{%
	\if0\csname pgfplots@errorbars@#1direction\endcsname
		% no error bars. Ok. Do nothing here.
		\expandafter\let\csname pgfplots@PREPARE@errorbar@process@#1\endcsname=\relax
	\else
		%
		% Prepare a macro which invokes
		% \pgfplots@streamerrorbarcoords.
		%
		% This involves to assign point coordinates in the correct
		% ordering; prepare that:
		\if x#1%
			\ifpgfplots@curplot@threedim
				\t@pgfplots@toka={%
						{(\pgfplots@current@point@x,\pgfplots@current@point@y,\pgfplots@current@point@z)}%
						{(\pgfplots@error@coord,\pgfplots@current@point@y,\pgfplots@current@point@z)}
				}%
			\else
				\t@pgfplots@toka={%
						{(\pgfplots@current@point@x,\pgfplots@current@point@y)}%
						{(\pgfplots@error@coord,\pgfplots@current@point@y)}
				}%
			\fi
		\else
			\if y#1%
				\ifpgfplots@curplot@threedim
					\t@pgfplots@toka={%
							{(\pgfplots@current@point@x,\pgfplots@current@point@y,\pgfplots@current@point@z)}%
							{(\pgfplots@current@point@x,\pgfplots@error@coord,\pgfplots@current@point@z)}
					}%
				\else
					\t@pgfplots@toka={%
							{(\pgfplots@current@point@x,\pgfplots@current@point@y)}%
							{(\pgfplots@current@point@x,\pgfplots@error@coord)}
					}%
				\fi
			\else
				\t@pgfplots@toka={%
						{(\pgfplots@current@point@x,\pgfplots@current@point@y,\pgfplots@current@point@z)}%
						{(\pgfplots@current@point@x,\pgfplots@current@point@y,\pgfplots@error@coord)}
				}%
			\fi
		\fi
		\begingroup
		% no, assemble the macro which will invoke
		% \pgfplots@streamerrorbarcoords:
		\let\E=\noexpand
		\expandafter\xdef\csname pgfplots@PREPARE@errorbar@stream@it@#1\endcsname{%
			\E\ifx\E\pgfplots@error@coord\E\pgfutil@empty
			\E\else
				\E\let\E\pgfplots@current@point@@old\expandafter\E\csname pgfplots@current@point@#1\endcsname
				\E\let\expandafter\E\csname pgfplots@current@point@#1\endcsname=\E\pgfplots@error@coord
				\E\pgfplotsaxisupdatelimitsforcoordinate\E\pgfplots@current@point@x\E\pgfplots@current@point@y\E\pgfplots@current@point@z
				\E\let\expandafter\E\csname pgfplots@current@point@#1\endcsname=\E\pgfplots@current@point@@old
				\E\edef\E\pgfplots@loc@TMPa{\the\t@pgfplots@toka}%
				\E\expandafter\E\pgfplots@streamerrorbarcoords\E\pgfplots@loc@TMPa
			\E\fi
		}%
		\endgroup
		%
		% The routine which is invoked for every reported input
		% coordinate is \pgfplots@process@errorbar@for.
		%
		% This here prepares its helper macros for direction '#1':
		\pgfplots@if{pgfplots@#1islinear}{%
			\ifcase\csname pgfplots@errorbars@#1mode\endcsname\relax
				% fixed absolute error.
				\pgfplotscoordmath{#1}{parsenumber}{\csname pgfplots@errorbars@#1fixed\endcsname}%
				\expandafter\let\csname pgfplots@error@coord@#1\endcsname=\pgfmathresult
				\expandafter\def\csname pgfplots@PREPARE@errorbar@process@#1@\endcsname##1{%
					\if +##1%
						\def\pgfplots@loc@TMPb{add}%
					\else
						\def\pgfplots@loc@TMPb{subtract}%
					\fi
					\pgfplotscoordmath{#1}{op}{\pgfplots@loc@TMPb}{%
						{\csname pgfplots@current@point@#1\endcsname}%
						{\csname pgfplots@error@coord@#1\endcsname}%
					}%
					\let\pgfplots@error@coord=\pgfmathresult
					\csname pgfplots@PREPARE@errorbar@stream@it@#1\endcsname
				}%
			\or% fixed relative error:
				\pgfplotscoordmath{#1}{parsenumber}{\csname pgfplots@errorbars@#1rel\endcsname}%
				\let\pgfplots@loc@TMPb=\pgfmathresult
				%
				% +1:
				\pgfplotscoordmath{#1}{parsenumber}{1}%
				\let\pgfplots@loc@TMPa=\pgfmathresult
				%
				% Prepare '1 + err':
				\pgfplotscoordmath{#1}{op}{add}{%
					{\pgfplots@loc@TMPa}%
					{\pgfplots@loc@TMPb}%
				}%
				\expandafter\let\csname pgfplots@error@coord@#1@+\endcsname=\pgfmathresult
				%
				% Prepare '1 - err':
				\pgfplotscoordmath{#1}{op}{subtract}{%
					{\pgfplots@loc@TMPa}%
					{\pgfplots@loc@TMPb}%
				}%
				\expandafter\let\csname pgfplots@error@coord@#1@-\endcsname=\pgfmathresult
				%
				\expandafter\def\csname pgfplots@PREPARE@errorbar@process@#1@\endcsname##1{%
					\pgfplotscoordmath{#1}{op}{multiply}{%
						{\csname pgfplots@current@point@#1\endcsname}
						{\csname pgfplots@error@coord@#1@##1\endcsname}%
					}%
					\let\pgfplots@error@coord=\pgfmathresult
					\csname pgfplots@PREPARE@errorbar@stream@it@#1\endcsname
				}%
			\or% explicit absolute:
				\expandafter\def\csname pgfplots@PREPARE@errorbar@process@#1@\endcsname##1{%
					\edef\pgfplots@error@coord{\csname pgfplots@current@point@#1@error\endcsname}%
					\ifx\pgfplots@error@coord\pgfutil@empty
					\else
						\pgfplotscoordmath{#1}{parsenumber}{\pgfplots@error@coord}%
						\let\pgfplots@error@coord=\pgfmathresult
						% remember result here - will be used in case
						% of '+' AND '-' error bars:
						\expandafter\let\csname pgfplots@current@point@#1@error\endcsname=\pgfmathresult
						\if +##1%
							\def\pgfplots@loc@TMPb{add}%
						\else
							\def\pgfplots@loc@TMPb{subtract}%
						\fi
						\pgfplotscoordmath{#1}{op}{\pgfplots@loc@TMPb}{%
							{\csname pgfplots@current@point@#1\endcsname}%
							{\pgfplots@error@coord}%
						}%
						\let\pgfplots@error@coord=\pgfmathresult
						\csname pgfplots@PREPARE@errorbar@stream@it@#1\endcsname
					\fi
				}%
			\or% explicit relative:
				\expandafter\def\csname pgfplots@PREPARE@errorbar@process@#1@\endcsname##1{%
					\edef\pgfplots@error@coord{\csname pgfplots@current@point@#1@error\endcsname}%
					\ifx\pgfplots@error@coord\pgfutil@empty
					\else
						\pgfmathparse{1##1\pgfplots@error@coord}%
						\let\pgfplots@error@coord=\pgfmathresult
						\pgfplotscoordmath{#1}{multiply}{%
							{\csname pgfplots@current@point@#1\endcsname}
							{\pgfplots@error@coord}%
						}%
						\let\pgfplots@error@coord=\pgfmathresult
						\csname pgfplots@PREPARE@errorbar@stream@it@#1\endcsname
					\fi
				}%
			\fi
		}{%
			% LOGARITHMIC scaling. All errors are interpreted as 
			%   log(x +- e_x)
			% or
			%   log( x*(1+-e_x) )
			%
			% That means any input argument is
			% given in log base e and in fixed point.
			% Furthermore, we expect the '@unfiltered' keys to be
			% present (I don't want to apply 'exp' again!).
			%
			\ifcase\csname pgfplots@errorbars@#1mode\endcsname
				% fixed absolute, log( x +- e_x )
				%
				\pgfplotscoordmath{default}{parsenumber}{\csname pgfplots@errorbars@#1fixed\endcsname}%
				\expandafter\let\csname pgfplots@error@coord@#1\endcsname=\pgfmathresult
				\expandafter\def\csname pgfplots@PREPARE@errorbar@process@#1@\endcsname##1{%
					\pgfplotscoordmath{default}{parsenumber}{\csname pgfplots@current@point@#1@unfiltered\endcsname}%
					\let\pgfplots@loc@TMPa=\pgfmathresult
					\if +##1%
						\def\pgfplots@loc@op{add}%
					\else
						\def\pgfplots@loc@op{subtract}%
					\fi
					\pgfplotscoordmath{default}{op}{\pgfplots@loc@op}{%
						{\pgfplots@loc@TMPa}%
						{\csname pgfplots@error@coord@#1\endcsname}%
					}%
					\pgfplotscoordmath{default}{tostring}{\pgfmathresult}%
					\pgfplotscoordmath{#1}{log}{\pgfmathresult}%
					\let\pgfplots@error@coord=\pgfmathresult
					\csname pgfplots@PREPARE@errorbar@stream@it@#1\endcsname
				}%
			\or% fixed relative, log( x ( 1+-e_x ) ) = log(x) + log(1+-e_x)
				\pgfplotscoordmath{default}{parsenumber}{\csname pgfplots@errorbars@#1rel\endcsname}%
				\let\pgfplots@loc@TMPb=\pgfmathresult
				%
				% +1:
				\pgfplotscoordmath{default}{one}%
				\let\pgfplots@loc@TMPa=\pgfmathresult
				%
				% Prepare '1 + err':
				\pgfplotscoordmath{default}{op}{add}{{\pgfplots@loc@TMPa}{\pgfplots@loc@TMPb}}%
				\pgfplotscoordmath{default}{tostring}{\pgfmathresult}%
				\pgfplotscoordmath{#1}{log}{\pgfmathresult}%
				\pgfplotscoordmath{#1}{if is bounded}{\pgfmathresult}{%
				}{%
					% 1 + err <= 0  and log(1+err) is undefined:
					\pgfplotscoordmath{default}{tostring}{\pgfplots@loc@TMPb}%
					\pgfplots@error{Sorry, log(1 + \pgfmathresult) is undefined. Please provide a different argument for '/pgfplots/error bar/#1 fixed relative'.}%
					\let\pgfmathresult=\pgfutil@empty
				}%
				\expandafter\let\csname pgfplots@error@coord@#1@+\endcsname=\pgfmathresult
				%
				% Prepare '1 - err':
				\pgfplotscoordmath{default}{op}{subtract}{{\pgfplots@loc@TMPa}{\pgfplots@loc@TMPb}}%
				\pgfplotscoordmath{default}{tostring}{\pgfmathresult}%
				\pgfplotscoordmath{#1}{log}{\pgfmathresult}%
				\pgfplotscoordmath{#1}{if is bounded}{\pgfmathresult}{%
				}{%
					% 1 - err <= 0  and log(1+err) is undefined:
					\pgfplotscoordmath{default}{tostring}{\pgfplots@loc@TMPb}%
					\pgfplots@error{Sorry, log(1 - \pgfmathresult) (\pgfplots@loc@TMPa - \pgfplots@loc@TMPb) is undefined. Please provide a different argument for '/pgfplots/error bar/#1 fixed relative'.}%
					\let\pgfmathresult=\pgfutil@empty
				}%
				\expandafter\let\csname pgfplots@error@coord@#1@-\endcsname=\pgfmathresult
				%
				\expandafter\def\csname pgfplots@PREPARE@errorbar@process@#1@\endcsname##1{%
					\expandafter\ifx\csname pgfplots@current@point@#1@##1\endcsname\pgfutil@empty
					\else
						\pgfmath@basic@add@
							{\csname pgfplots@current@point@#1\endcsname}
							{\csname pgfplots@error@coord@#1@##1\endcsname}%
						\let\pgfplots@error@coord=\pgfmathresult
						\csname pgfplots@PREPARE@errorbar@stream@it@#1\endcsname
					\fi
				}%
			\or% explicit absolute
				% log( x +- e_x )
				\expandafter\def\csname pgfplots@PREPARE@errorbar@process@#1@\endcsname##1{%
					\edef\pgfplots@error@coord{\csname pgfplots@current@point@#1@error\endcsname}%
					\ifx\pgfplots@error@coord\pgfutil@empty
					\else
						\pgfplotscoordmath{default}{parsenumber}{\pgfplots@error@coord}%
						\let\pgfplots@error@coord=\pgfmathresult
						% remember result here - will be used in case
						% of '+' AND '-' error bars:
						\expandafter\let\csname pgfplots@current@point@#1@error\endcsname=\pgfmathresult
						\pgfplotscoordmath{default}{parsenumber}{\csname pgfplots@current@point@#1@unfiltered\endcsname}%
						\let\pgfplots@loc@TMPa=\pgfmathresult
						\if +##1%
							\def\pgfplots@loc@op{add}%
						\else
							\def\pgfplots@loc@op{subtract}%
						\fi
						\pgfplotscoordmath{default}{op}{\pgfplots@loc@op}{%
							{\pgfplots@loc@TMPa}%
							{\pgfplots@error@coord}%
						}%
						\pgfplotscoordmath{default}{tostring}{\pgfmathresult}%
						\pgfplotscoordmath{#1}{log}{\pgfmathresult}%
						\let\pgfplots@error@coord=\pgfmathresult
						\csname pgfplots@PREPARE@errorbar@stream@it@#1\endcsname
					\fi
				}%
				%
			\or% explicit relative:
				% log( x ( 1+-e_x ) ) = log(x) + log(1+-e_x)
				\expandafter\def\csname pgfplots@PREPARE@errorbar@process@#1@\endcsname##1{%
					\edef\pgfplots@error@coord{\csname pgfplots@current@point@#1@error\endcsname}%
					\ifx\pgfplots@error@coord\pgfutil@empty
					\else
						\pgfplotscoordmath{default}{parsenumber}{\pgfplots@error@coord}%
						\let\pgfplots@error@coord=\pgfmathresult
						% remember result here - will be used in case
						% of '+' AND '-' error bars:
						\expandafter\let\csname pgfplots@current@point@#1@error\endcsname=\pgfmathresult
						%
						\pgfplotscoordmath{default}{one}%
						\let\pgfplots@loc@TMPa=\pgfmathresult
						\if +##1%
							\def\pgfplots@loc@op{add}%
						\else
							\def\pgfplots@loc@op{subtract}%
						\fi
						\pgfplotscoordmath{default}{op}{\pgfplots@loc@op}{%
							{\pgfplots@loc@TMPa}%
							{\pgfplots@error@coord}%
						}%
						\pgfplotscoordmath{default}{tostring}{\pgfmathresult}%
						\pgfplotscoordmath{#1}{log}{\pgfmathresult}%
						\let\pgfplots@error@coord=\pgfmathresult
						\pgfplotscoordmath{#1}{if is bounded}{\pgfmathresult}{%
							\pgfplotscoordmath{#1}{op}{add}{%
								{\csname pgfplots@current@point@#1\endcsname}
								{\pgfplots@error@coord}%
							}%
							\let\pgfplots@error@coord=\pgfmathresult
							\csname pgfplots@PREPARE@errorbar@stream@it@#1\endcsname
						}{%
							% -> log( <= 0 ) -> do nothing.
						}%
					\fi
				}%
				%
			\fi
		}%
		\ifcase\csname pgfplots@errorbars@#1direction\endcsname
			% none
		\or
			% plus
			\expandafter\edef\csname pgfplots@PREPARE@errorbar@process@#1\endcsname{%
				\expandafter\noexpand\csname pgfplots@PREPARE@errorbar@process@#1@\endcsname+%
			}%
		\or
			% minus
			\expandafter\edef\csname pgfplots@PREPARE@errorbar@process@#1\endcsname{%
				\expandafter\noexpand\csname pgfplots@PREPARE@errorbar@process@#1@\endcsname-%
			}%
		\or
			% both
			\expandafter\edef\csname pgfplots@PREPARE@errorbar@process@#1\endcsname{%
				\expandafter\noexpand\csname pgfplots@PREPARE@errorbar@process@#1@\endcsname+%
				\expandafter\noexpand\csname pgfplots@PREPARE@errorbar@process@#1@\endcsname-%
			}%
		\fi
	\fi
}

% Defines the linear transformation macro \pgfplots@perpointmeta@trafo,
%
% phi : [meta_min,meta,max] -> [0,10^k]
%
% which operates on the per-point meta data (if any).
% The trafo will be skipped if there is no such data.
%
% The trafo is expected to prepare meta information before it is used
% as input to \pgfplotscolormapaccess (or
% \pgfplotscolormapdefinemappedcolor). Thus, the 10^k is chosen to be 
% the same as \pgfplotscolormaprange (which is 1000 per default).
%
% If there is no data range (for example because meta information is
% not available or is not of numeric type), the trafo will simply
% copy the input argument symbolically.
%
% Note: it does not hurt to call it multiple times. It checks automatically whether it already is up-to-date.
\def\pgfplots@perpointmeta@preparetrafo{%
	\def\pgfplotspointmetarangeexponent{1}% pre-fill
	\pgfutil@ifundefined{pgfplots@perpointmeta@trafo}{%
		\let\pgfplots@current@point@meta=\pgfutil@empty
		\pgfutil@ifundefined{pgfplots@metamax}{\let\pgfplots@metamax=\pgfutil@empty}{}
		\ifpgfplots@warn@for@filter@discards
			\global\let\pgfplots@perpointmeta@unboundedwarning@stop=\relax
			\def\pgfplots@perpointmeta@unboundedwarning##1{%
				\ifx\pgfplots@perpointmeta@unboundedwarning@stop\relax
					\begingroup
						\pgfplotscoordmath{meta}{tostring}{##1}%
						\pgfplots@warning{The per point meta data `\pgfmathresult' (##1) (and probably others as well) is unbounded - using the minimum value instead.}%
					\endgroup
					\gdef\pgfplots@perpointmeta@unboundedwarning@stop{1}%
				\fi
			}%
		\else
			\def\pgfplots@perpointmeta@unboundedwarning##1{}%
		\fi
		\if m\pgfplots@colormap@access
			% colormap access=map
			\ifx\pgfplots@metamax\pgfutil@empty
				\def\pgfplots@perpointmeta@trafo##1{%
					\pgfplotscoordmath{meta}{if is}{##1}{u}
					{%
						\def\pgfmathresult{0}%
						\pgfplots@perpointmeta@unboundedwarning{##1}%
					}{%
						\pgfplotscoordmath{meta}{tofixed}{##1}%
					}%
				}%
				\def\pgfplots@perpointmeta@traforange{0:1000}%
				\edef\pgfplotspointmetarange{0:1000}%
			\else
				% The transformation is
				%
				% phi(m) = ( m- meta_min) * 1000/ (meta_max-meta_min).
				%
				% -> precompute the scaling factor!
				\edef\pgfplots@loc@TMPa{\pgfplotscolormaprange}%
				\ifnum\pgfplots@loc@TMPa=1000
				\else
					\pgfplots@error{LOGIC ERROR: sorry, I have hard-coded the assumption \string\pgfplotscolormaprange = 1000, but now it is \pgfplots@loc@TMPa.}%
				\fi
				\if\pgfplots@perpointmeta@rel@choice0%
					% point meta rel=axis wide:
					\pgfplots@perpointmeta@preparetrafo@initfrom{pgfplots@axiswide@}%
				\else
					\pgfplots@perpointmeta@preparetrafo@initfrom{pgfplots@}%
				\fi
			\fi
		\else
			% colormap access=direct
			\def\pgfplots@perpointmeta@trafo##1{%
				\pgfplotscoordmath{meta}{if is}{##1}{u}{%
					\def\pgfmathresult{0}%
					\pgfplots@perpointmeta@unboundedwarning{##1}%
				}{%
					\pgfplotscoordmath{meta}{tofixed}{##1}%
				}%
			}%
			\def\pgfplots@perpointmeta@traforange{0:0}%
			\edef\pgfplotspointmetarange{\pgfplots@metamin:\pgfplots@metamax}%
		\fi
		\edef\pgfplotspointmetatransformedrange{\pgfplots@perpointmeta@traforange}%
	}{}%
}%

% Employs \csname #1metamin\endcsname and its metamax counterpart to
% initialize the trafo.
%
% This unifies the approaches for \pgfplots@axiswide@metamax and
% \pgfplots@metamax.
\def\pgfplots@perpointmeta@preparetrafo@initfrom#1{%
	\edef\pgfplotspointmetarange{\csname #1metamin\endcsname:\csname #1max\endcsname}%
	% Now, prepare the trafo as such.
	% It assigns \pgfmathresult (in fixed point).
	\def\pgfplots@perpointmeta@trafo##1{%
		\pgfplotscoordmath{meta}{if is}{##1}{u}{%
			\def\pgfmathresult{0}%
			\pgfplots@perpointmeta@unboundedwarning{##1}%
		}{%
			\pgfplotscoordmath{meta}{op}{subtract}{{##1}{\csname #1metamin\endcsname}}%
			\pgfplotscoordmath{meta}{op}{multiply}{{\pgfmathresult}{\pgfplots@perpointmeta@trafo@factor}}%
			\pgfplotscoordmath{meta}{tofixed}{\pgfmathresult}%
		}%
	}%
	\pgfplotscoordmath{meta}{op}{subtract}{{\csname #1metamax\endcsname}{\csname #1metamin\endcsname}}%
	\let\pgfplots@loc@TMPa=\pgfmathresult
	\pgfplotscoordmath{meta}{parsenumber}{1000}%
	\pgfplotscoordmath{meta}{op}{divide}{{\pgfmathresult}{\pgfplots@loc@TMPa}}%
	\let\pgfplots@perpointmeta@trafo@factor=\pgfmathresult
	%
	% Expands to the transformation range as 'a:b':
	\def\pgfplots@perpointmeta@traforange{0:1000}%
	%
	\expandafter\let\expandafter\pgfplots@loc@TMPa\csname #1metamax\endcsname
	\pgfplotscoordmath{meta}{tostring}{\pgfplots@loc@TMPa}%
	\pgfmathfloatparsenumber\pgfmathresult
	\pgfmathfloatgetexponent\pgfmathresult\c@pgf@countd
	\edef\pgfplotspointmetarangeexponent{\the\c@pgf@countd}%
}

% A command which is readily available during the visualization phase of each plot.
% 
% It takes existing point meta data and transforms it, i.e. it defines
% \pgfplotspointmetatransformed.
%
% The command won't be invoked automatically, it is task of a plot
% handler to decide if it is needed. It's application is relatively
% fast, however.
%
% PRECONDITION:
% 	- point meta has been set up during the survey phase (i.e. the
% 	/pgfplots/point meta!=none),
% 	- there *is* point meta data for the current data point.
%
% POSTCONDITION:
% 	- the macros \pgfplotspointmeta and \pgfplotspointmetatransformed
% 	are defined.
%
% @see also \pgfplotsaxisifhaspointmeta
\def\pgfplotsaxisvisphasetransformpointmeta{%
	\ifx\pgfplots@current@point@meta\pgfutil@empty%
		\pgfplots@error{could not access the 'point meta' (used for example by scatter plots and color maps). Maybe you need to add '\string\addplot[point meta=y]' or something like that?}%
		\pgfplotscoordmath{meta}{one}%
		\let\pgfplotspointmeta=\pgfmathresult
		\def\pgfplotspointmetatransformed{1.0}%
	\else
		% prepare arguments:
		\if1\csname pgfpmeta@\pgfplotspointmetainputhandler @issymbolic\endcsname
			\let\pgfplotspointmeta=\pgfplots@current@point@meta
			\let\pgfplotspointmetatransformed=\pgfplotspointmeta
		\else
			\let\pgfplotspointmeta=\pgfplots@current@point@meta
			\pgfplots@perpointmeta@trafo{\pgfplotspointmeta}%
			\let\pgfplotspointmetatransformed=\pgfmathresult
		\fi
	\fi
}%

% A looping method which applies
% \pgfplots@coord@stream@start
% for each coordinate '(x,y)'  or '(x,y) +- (ex,ey)',
%    assign \pgfplots@current@point@[xyz]
%    assign \pgfplots@current@point@[xyz]@error (if in argument list)
%    assign \pgfplots@current@point@meta
%    call \pgfplots@coord@stream@coord
% \pgfplots@coord@stream@end
%
% #1 a sequence of coordinates of the form 
%   '(x,y)' or '(x,y,z)'
%   or
%   '(x,y[,z]) +- (ex,ey)'
%   or
%   '(x,y) [meta]'
%   or
%   '(x,y) +- (ex,ey) [meta]'
%   separated by white-space.
%
% The per-point meta is not implemented yet.
\long\def\pgfplots@coord@stream@foreach#1{%
	\pgfplots@coord@stream@start
	\pgfplotsscanlinelengthinitzero
	\pgfplots@foreach@plot@coord@ITERATE#1\pgfplots@EOI%
	\pgfplotsscanlinelengthcleanup
	\pgfplots@coord@stream@end
}%

% A looping command to loop through plot coordinates.
% For every point, #1{X}{Y} will be invoked.
%
% No scoping is used during this operation, so you can access outer
% variables.
\def\pgfplots@foreach@plot@coord@ITERATE{%
	\pgfutil@ifnextchar\pgfplots@EOI{%
		\pgfplots@foreach@plot@coord@FINISH%
	}{%
		\pgfutil@ifnextchar\par{%
			\pgfplotsscanlinecomplete
			\pgfplots@foreach@plot@coord@ITERATE@gobbleone
		}{%
			\pgfutil@ifnextchar({%
				\pgfplotsscanlinelengthincrease
				\pgfplots@foreach@plot@coord@NEXT%
			}{%
				\pgfplots@foreach@plot@coord@error
			}%
		}%
	}%
}
\long\def\pgfplots@foreach@plot@coord@error#1\pgfplots@EOI{%
	\pgfplots@error{Sorry, I could not read the plot coordinates near '#1'. Please check for format mistakes.}%
}%
\long\def\pgfplots@foreach@plot@coord@ITERATE@gobbleone#1{\pgfplots@foreach@plot@coord@ITERATE}%
\def\pgfplots@foreach@plot@coord@NEXT(#1){%
	\edef\pgfmathresult{#1}%
	\expandafter\pgfplots@foreach@plot@coord@NEXT@\expandafter(\pgfmathresult)%
}
\def\pgfplots@foreach@plot@coord@NEXT@(#1,#2){%
	\ifpgfplots@plot@coords@mathparser
		\pgfmathparse{#1}\let\pgfplots@current@point@x=\pgfmathresult
		\pgfmathparse{#2}\let\pgfplots@current@point@y=\pgfmathresult
	\else
		\def\pgfplots@current@point@x{#1}%
		\def\pgfplots@current@point@y{#2}%
	\fi
	\pgfutil@ifnextchar+{%
		\pgfplots@foreach@plot@coord@NEXT@WITH@ERRORRANGE%
	}{%
		\let\pgfplots@current@point@x@error=\pgfutil@empty
		\let\pgfplots@current@point@y@error=\pgfutil@empty
		\pgfutil@ifnextchar[{%
			\pgfplots@foreach@plot@coord@NEXT@meta
		}{%
			\let\pgfplots@current@point@meta=\pgfutil@empty
			\pgfplots@coord@stream@coord
			\pgfplots@foreach@plot@coord@ITERATE
		}%
	}%
}
\def\pgfplots@foreach@plot@coord@NEXT@meta[#1]{%
	\def\pgfplots@current@point@meta{#1}%
	\pgfplots@coord@stream@coord
	\pgfplots@foreach@plot@coord@ITERATE
}%
% processing something like '(x,y) +- (error_x,error_y)'
\def\pgfplots@foreach@plot@coord@NEXT@WITH@ERRORRANGE+-#1({%
	\pgfplots@foreach@plot@coord@NEXT@WITH@ERRORRANGE@%
}
\def\pgfplots@foreach@plot@coord@NEXT@WITH@ERRORRANGE@#1,#2){%
	\ifpgfplots@plot@coords@mathparser
		\pgfmathparse{#1}\let\pgfplots@current@point@x@error=\pgfmathresult
		\pgfmathparse{#2}\let\pgfplots@current@point@y@error=\pgfmathresult
	\else
		\def\pgfplots@current@point@x@error{#1}%
		\def\pgfplots@current@point@y@error{#2}%
	\fi
	\pgfutil@ifnextchar[{%
		\pgfplots@foreach@plot@coord@NEXT@meta
	}{%
		\let\pgfplots@current@point@meta=\pgfutil@empty
		\pgfplots@coord@stream@coord
		\pgfplots@foreach@plot@coord@ITERATE
	}%
}
\def\pgfplots@foreach@plot@coord@FINISH\pgfplots@EOI{}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5
% The same for three dim coords:
\long\def\pgfplots@coord@stream@foreach@threedim#1{%
	\pgfplots@coord@stream@start
	\pgfplotsscanlinelengthinitzero
	\pgfplots@foreach@plot@coord@threedim@ITERATE#1\pgfplots@EOI%
	\pgfplotsscanlinelengthcleanup
	\pgfplots@coord@stream@end
}%
\def\pgfplots@foreach@plot@coord@threedim@ITERATE{%
	\pgfutil@ifnextchar\pgfplots@EOI{%
		\pgfplots@foreach@plot@coord@FINISH%
	}{%
		\pgfutil@ifnextchar\par{%
			\pgfplotsscanlinecomplete
			\pgfplots@foreach@plot@coord@threedim@ITERATE@gobbleone
		}{%
			\pgfutil@ifnextchar({%
				\pgfplotsscanlinelengthincrease
				\pgfplots@foreach@plot@coord@threedim@NEXT%
			}{%
				\pgfplots@foreach@plot@coord@error
			}%
		}%
	}%
}
\long\def\pgfplots@foreach@plot@coord@threedim@ITERATE@gobbleone#1{\pgfplots@foreach@plot@coord@threedim@ITERATE}%
\def\pgfplots@foreach@plot@coord@threedim@NEXT(#1){%
	\edef\pgfmathresult{#1}%
	\expandafter\pgfplots@foreach@plot@coord@threedim@NEXT@\expandafter(\pgfmathresult)%
}
\def\pgfplots@foreach@plot@coord@threedim@NEXT@(#1,#2,#3){%
	\ifpgfplots@plot@coords@mathparser
		\pgfmathparse{#1}\let\pgfplots@current@point@x=\pgfmathresult
		\pgfmathparse{#2}\let\pgfplots@current@point@y=\pgfmathresult
		\pgfmathparse{#3}\let\pgfplots@current@point@z=\pgfmathresult
	\else
		\def\pgfplots@current@point@x{#1}%
		\def\pgfplots@current@point@y{#2}%
		\def\pgfplots@current@point@z{#3}%
	\fi
	\pgfutil@ifnextchar+{%
		\pgfplots@foreach@plot@coord@threedim@NEXT@WITH@ERRORRANGE%
	}{%
		\let\pgfplots@current@point@x@error=\pgfutil@empty
		\let\pgfplots@current@point@y@error=\pgfutil@empty
		\let\pgfplots@current@point@z@error=\pgfutil@empty
		\pgfutil@ifnextchar[{%
			\pgfplots@foreach@plot@coord@threedim@NEXT@meta
		}{%
			\let\pgfplots@current@point@meta=\pgfutil@empty
			\pgfplots@coord@stream@coord
			\pgfplots@foreach@plot@coord@threedim@ITERATE
		}%
	}%
}
\def\pgfplots@foreach@plot@coord@threedim@NEXT@meta[#1]{%
	\def\pgfplots@current@point@meta{#1}%
	\pgfplots@coord@stream@coord
	\pgfplots@foreach@plot@coord@threedim@ITERATE
}%
% processing something like '(x,y) +- (error_x,error_y)'
\def\pgfplots@foreach@plot@coord@threedim@NEXT@WITH@ERRORRANGE+-#1({%
	\pgfplots@foreach@plot@coord@threedim@NEXT@WITH@ERRORRANGE@%
}
\def\pgfplots@foreach@plot@coord@threedim@NEXT@WITH@ERRORRANGE@#1,#2,#3){%
	\ifpgfplots@plot@coords@mathparser
		\pgfmathparse{#1}\let\pgfplots@current@point@x@error=\pgfmathresult
		\pgfmathparse{#2}\let\pgfplots@current@point@y@error=\pgfmathresult
		\pgfmathparse{#3}\let\pgfplots@current@point@z@error=\pgfmathresult
	\else
		\def\pgfplots@current@point@x@error{#1}%
		\def\pgfplots@current@point@y@error{#2}%
		\def\pgfplots@current@point@z@error{#3}%
	\fi
	\pgfutil@ifnextchar[{%
		\pgfplots@foreach@plot@coord@threedim@NEXT@meta
	}{%
		\let\pgfplots@current@point@meta=\pgfutil@empty
		\pgfplots@coord@stream@coord
		\pgfplots@foreach@plot@coord@threedim@ITERATE
	}%
}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%5
%
% A coordinate stream which works like this:
% 
% -------------
% \pgfplots@coord@stream@start
%
% foreach encoded coordinate:
%   \def\pgfplots@coord@stream@foreach@NORMALIZED@curencoded{<encoded data>}%
%   \def\pgfplots@coord@stream@foreach@NORMALIZED@curencoded@braced{{<encoded data>}}% note the extra braces.
%   \pgfplotsaxisdeserializedatapointfrom{<encoded data>}
% 	\pgfplots@coord@stream@coord
%
% \pgfplots@coord@stream@end
% -------------
%
% The format of #1 is
%  {<datapoint>}{<datapoint>}...{<datapoint>}
% Each data point is decoded with
% \pgfplotsaxisserializedatapoint
% and then, \pgfplots@coord@stream@coord will be called.
\long\def\pgfplots@coord@stream@foreach@NORMALIZED#1{%
	\pgfplots@coord@stream@start
	\pgfplotscoordstream@firstlast@init
	\pgfplots@foreach@plot@coord@NORMALIZED@ITERATE#1\pgfplots@EOI%
	\pgfplots@coord@stream@end
}%
% No scoping is used during this operation, so you can access outer
% variables.
\def\pgfplots@foreach@plot@coord@NORMALIZED@ITERATE#1{%
	\def\pgfplots@coord@stream@foreach@NORMALIZED@curencoded{#1}%
	\ifx\pgfplots@coord@stream@foreach@NORMALIZED@curencoded\pgfplots@EOI
	\else
		\def\pgfplots@coord@stream@foreach@NORMALIZED@curencoded@braced{{#1}}%
		\pgfplotsaxisdeserializedatapointfrom{#1}%
		\pgfplots@coord@stream@coord
		\pgfplotscoordstream@firstlast@update
		\expandafter\pgfplots@foreach@plot@coord@NORMALIZED@ITERATE
	\fi
}


% A common routine which resets internal data structures for the
% survey phase, i.e. it is the shared implementation for all \addplot
% variations.
% 
% It takes all options which are provided to \addplot, sets them (at
% least partially) and remembers them for the command serialization.
%
% #1:  arguments to \addplot plot[#1]
%   -> these are called 'behavior' options in the manual; they are set
%   immediately.
%
% PRECONDITION:
%	\pgfplots@addplotimpl@plot@withoptions has already been invoked
%
% POSTCONDITION:
% 	- internal datastructures are initialised (coordinate indexing, fpu)
% 	- all keys which are required for the current plot are determined
% 	(and set if necessary).
% 	They are stored into 
% 	\pgfplots@addplot@survey@@optionlist.
%    
\def\pgfplots@start@plot@with@behavioroptions#1{%
	%\begingroup%<-- has been moved to \pgfplots@addplotimpl@plot@withoptions
	\c@pgfplots@coordindex=0
	\def\pgfplots@current@point@coordindex{\the\c@pgfplots@coordindex}% can be used inside of coordinate filters.
	\def\coordindex{\pgfplots@current@point@coordindex}% valid inside of \addplot
	\def\pgfplots@addplot@running{1}%
	%
	\def\pgfplots@colorbar@set@src{0}%
	\pgfkeysdef{/pgfplots/colorbar source}{%
		\pgfplotsutilifstringequal{##1}{true}{%
			\def\pgfplots@colorbar@set@src{1}%
		}{%
			\pgfplotsutilifstringequal{##1}{false}{%
				\def\pgfplots@colorbar@set@src{0}%
			}{%
				\pgfplots@error{Sorry, I don't know the value `colorbar source={##1}' and I am going to ignore it. Maybe you misspelled it?}%
			}%
		}%
	}%
	%
	% these styles may contain behavior options (error bars,
	% samples,... ) activate them!
	%
	% As of february 20, 2009,  #1 will contain BOTH, /pgfplots
	% and /tikz options. The /tikz ones are primarily for drawing
	% and are UNIMPORTANT at this stage of processing.
	% In  fact, transparency etc. will only confuse everything.
	%
	% So: ignore them and set only /pgfplots keys here:
	% This may actually redefine styles, for example
	% \addplot[every mark/.append style={}] will use
	% /pgfplots/every mark/.append style.
	% But that doesn't hurt here.
	%
	% there are some exceptions like /tikz/id etc. These
	% exceptions need special styles in the /pgfplots root - or I
	% need to change the .unknown handler. See the available
	% compatibility styles!
	%
%	\pgfkeysdef{/pgfplots/.unknown}{%
%\message{In \string\addplot[#1]: I am silently ignoring key `\pgfkeyscurrentkeyRAW' during the preparation phase.}%
%	}%
	% ATTENTION:
	% as of january 30, 2010, I will set /tikz keys as well. This won't hurt
	% too much, I hope... there are no graphics operations anyway. But it *is*
	% necessary since I *need* the plot handler for the new version. And the plot
	% handler is, most likely, a /tikz key.
	%
	% it is possible that '#1' contains 'forget plot'. So, we need to
	% set the options before checking \ifpgfplots@curplot@isirrelevant:
	\pgfplotsset{/pgfplots/every axis plot,#1}%
	%
	\ifpgfplots@curplot@isirrelevant
		\def\pgfplots@addplot@survey@@optionlist{/pgfplots/every axis plot,/pgfplots/every forget plot}%
		\pgfplotsset{/pgfplots/every forget plot,/pgfplots/every axis plot post}%
	\else
		\edef\pgfplots@addplot@survey@@optionlist{/pgfplots/every axis plot,/pgfplots/every axis plot no \the\pgfplots@numplots/.try}%
		\pgfplotsset{/pgfplots/every axis plot no \the\pgfplots@numplots/.try,/pgfplots/every axis plot post}%
	\fi
	%
	% enable FPU after any \pgfplotsset operations. Otherwise things like
	% linewidth=... which use the math parser might fail.
	\ifpgfplots@usefpu
		\pgfkeys{/pgf/fpu=true}%
	\fi
	%
	% make sure it is reset, just in case it is not supported by the
	% input method. 
	\pgfplotsscanlinelengthinitzero
	%
	\pgfplots@getcurrent@plothandler\pgfplots@basiclevel@plothandler
	\pgfplotsresetplothandler
	\pgfplots@basiclevel@plothandler
	%
	\pgfplots@countplots@init
	%
	% hooks:
	\pgfkeysvalueof{/pgfplots/execute at begin plot@@}%
	\pgfkeysvalueof{/pgfplots/execute at begin plot}%
	%
	\if1\pgfplots@colorbar@set@src
		\expandafter\def\expandafter\pgfplots@addplot@survey@@optionlist\expandafter{\pgfplots@addplot@survey@@optionlist,%
			/pgfplots/point meta rel=per plot}%
	\fi
	%
	\t@pgfplots@tokc=\expandafter{\pgfplots@addplot@survey@@optionlist,#1}% this allows '#' inside of '#1'
	\edef\pgfplots@addplot@survey@@optionlist{\the\t@pgfplots@tokc}%
	%
	%
	\pgfplots@validate@plot@domain@arguments
}

\long\def\pgfplotsplothandlersurveyaddoptions#1{%
	\pgfplotsset{/pgfplots/execute at end survey/.add={}{%
			\t@pgfplots@tokc=\expandafter{\pgfplots@addplot@survey@@optionlist,#1}% this allows '#' inside of '#1'
			\edef\pgfplots@addplot@survey@@optionlist{\the\t@pgfplots@tokc}%
		},%
		#1%
	}%
}%


% The main interface to draw a plot into an axis.
%
% Usage:
% \addplot 
% 	plot coordinates {
% 		(0,0)
% 		(1,1)
% 	};
% 
% or
%
% \addplot[color=blue,mark=*]
% 	plot coordinates {
% 		(0,0)
% 		(1,1)
% 	};
%
% or one of the other input types.
% 
% The first syntax will use the next plot specification in the list
% \autoplotspeclist
% and the first will use blue color and * markers. 
%
% \addplot [<style options>]  plot[<behavior options>]  <input type and args> <post plot path> ;
% \addplot3[<style options>]  plot[<behavior options>]  <input type and args> <post plot path> ;
% 
% The complete accumulation is done GLOBALLY. It should be safe to put
% '\addplot' into local groups.
%
%
% The linespec. will be used in the legend.
%
% Low-level implementation:
%
% \pgfplots@addplot 
% \pgfplots@addplotimpl
% \pgfplots@start@plot@with@behavioroptions <--- \begingroup
% ...
% ... remember options GLOBALLY
% ... update limits GLOBALLY
% ... \pgfplots@addplot@enqueue@coords GLOBALLY
% ...
% \pgfplots@end@plot <--- \endgroup
\def\pgfplots@addplot{%
	\pgfutil@ifnextchar3{%
		\pgfplots@curplot@threedimtrue
		\pgfplots@addplot@three
	}{%
		\pgfplots@curplot@threedimfalse
		\pgfplots@addplot@
	}%
}
\def\pgfplots@addplot@three3{\pgfplots@addplot@}%
\def\pgfplots@addplot@{%
	\pgfutil@ifnextchar+{%
		\pgfplots@getautoplotspec into\nextplotspec
		\pgfplots@addplotimplAPPEND
	}{%
		\pgfutil@ifnextchar[{%
			\pgfplots@addplotimpl%
		}{%
			\pgfplots@getautoplotspec into\nextplotspec
			% the space after ']' is required here:
			% FIXME: 
			% - \addplot[]plot coordinates is NOT allowed!?
			\expandafter\pgfplots@addplotimpl\expandafter[\nextplotspec]%
		}%
	}%
}

\def\pgfplots@addplotimplAPPEND+{\pgfutil@ifnextchar[{\pgfplots@addplotimplAPPEND@}{\pgfplots@addplotimplAPPEND@[]}}% this allows to gobble spaces and to skip the '[]'
\def\pgfplots@addplotimplAPPEND@[{%
	\expandafter\pgfplots@addplotimpl\expandafter[\nextplotspec,%
}

\long\def\pgfplots@addplotimpl[#1]{%
	\pgfplotsutil@ifnextchar p{%
		\pgfplots@addplotimpl@plot{#1}%
	}{%
		\pgfplots@addplotimpl@plot{#1}plot
	}%
}

\long\def\pgfplots@addplotimpl@plot#1plot{%
	\pgfplotsutil@ifnextchar[{%
		\pgfplots@addplotimpl@plot@withoptions{#1}%
	}{%
		\pgfplots@addplotimpl@plot@withoptions{#1}[]%
	}%
}

\long\def\pgfplots@addplotimpl@plot@withoptions#1[#2]{
	\begingroup% <-- This groups ends in \pgfplots@end@plot
	%
	\pgfplotsutil@ifnextchar c{%
		\pgfplots@addplotimpl@coordinates{#1}{#2}plot 
	}{%
		\pgfplotsutil@ifnextchar f{%
			\pgfplots@addplotimpl@f{#1}{#2}%
		}{%
			\pgfplotsutil@ifnextchar t{%
				\def\pgfplotssurveyphaseinputclass{table}%
				\pgfplots@start@plot@with@behavioroptions{#1,/pgfplots/.cd,#2}%
				\pgfplots@addplotimpl@table{#1,#2}%
			}{%
				\pgfplotsutil@ifnextchar ({%
					\pgfplots@addplotimpl@expression{#1}{#2}%
				}{%
					\pgfplotsutil@ifnextchar\bgroup{%
						\pgfplots@addplotimpl@expression@curly{#1}{#2}%
					}{%
						\pgfplotsutil@ifnextchar e{%
							\pgfplots@addplotimpl@expression@e{#1}{#2}%
						}{%
							\pgfplotsutil@ifnextchar g{%
								\pgfplots@addplotimpl@g{#1}{#2}%
							}{%
								\pgfplotsutil@ifnextchar s{%
									\pgfplots@addplotimpl@shell{#1}{#2}%
								}{%

									\pgfplots@error{Sorry, the supplied plot command is unknown or unsupported by pgfplots! Ignoring it.}%
									\pgfplots@gobble@until@semicolon
								}%
							}%
						}%
					}%
				}%
			}%
		}%
	}%
}
\long\def\pgfplots@addplotimpl@f#1#2f{%
	\pgfplotsutil@ifnextchar i{%
		\pgfplots@addplotimpl@file{#1}{#2}%
	}{%
		\pgfplots@addplotimpl@function{#1}{#2}%
	}%
}%

\def\pgfplots@gobble@until@semicolon#1;{}

% PRECONDITION:
% 	the key-value sets have all been set in the current scope.
% 
% POSTCONDITION:
% 	1. the following macros are initialised and sanitized:
% 	\pgfplots@plot@domain
% 	\pgfplots@plot@ydomain (will be set to \pgfplots@plot@domain if empty)
% 	\pgfplots@plot@samples@at
% 	\pgfplots@plot@samples@y (will be set to the x variant if empty)
% 	\tikz@plot@var (will become a macro like '\x')
% 	\pgfplots@plot@var@nonmacro (the same as \tikz@plot@var, but without backslash)
% 	\pgfplots@plot@var@y (like \tikz@plot@var, but for y)
% 	\pgfplots@plot@var@y@nonmacro (like \pgfplots@plot@var@nonmacro, but for y)
% 	2. the following key-value things are set:
% 		/pgfplots/mesh/rows
% 		/pgfplots/mesh/cols
% 		/pgfplots/samples y (will contain a value )
% 	3. the macro 
% 		\b@pgfplots@should@sample@LINE 
% 		will be 
% 		\def\b@pgfplots@should@sample@LINE{1}
% 		if the expression plotter should sample a line
% 		and
% 		\def\b@pgfplots@should@sample@LINE{0}
% 		if it should sample a mesh.
\def\pgfplots@plot@expression@preparekeys{%
	\pgfkeysgetvalue{/pgfplots/domain}\pgfplots@plot@domain
	\pgfkeysgetvalue{/pgfplots/samples y}\pgfplots@plot@samples@y
	\pgfkeysgetvalue{/pgfplots/samples at}\pgfplots@plot@samples@at
	\pgfkeysgetvalue{/pgfplots/variable y}\pgfplots@plot@var@y
	% 
	% \tikz@plot@var is '\x' be default:
	\pgfplots@gettikzinternal@keyval{variable}{tikz@plot@var}{\x}%
	%
	{%
		\escapechar=-1
		\xdef\pgfplots@glob@TMPa{\expandafter\string\tikz@plot@var}%
		\xdef\pgfplots@glob@TMPb{\expandafter\string\pgfplots@plot@var@y}%
	}%
	% \pgfplots@plot@var@nonmacro is the value '\tikz@plot@var'
	% without the '\', i.e. 'x' by default:
	\let\pgfplots@plot@var@nonmacro=\pgfplots@glob@TMPa
	\let\pgfplots@plot@var@y@nonmacro=\pgfplots@glob@TMPb
	%
	% make sure the 'plot vars' have a backslash (as it was in tikz
	% plot expression):
	\ifx\pgfplots@plot@var@nonmacro\tikz@plot@var
		\edef\tikz@plot@var{\expandafter\noexpand\csname \tikz@plot@var\endcsname}%
	\fi
	\ifx\pgfplots@plot@var@y@nonmacro\pgfplots@plot@var@y
		\edef\pgfplots@plot@var@y{\expandafter\noexpand\csname \pgfplots@plot@var@y\endcsname}%
	\fi
	%
	% Check if we have to sample a line or a matrix.
	% 
	\pgfkeysgetvalue{/pgfplots/sample dim}\pgfplots@loc@TMPa
	\def\pgfplots@loc@TMPb{auto}%
	\ifx\pgfplots@loc@TMPa\pgfplots@loc@TMPb
		\ifpgfplots@curplot@threedim
			\def\b@pgfplots@should@sample@LINE{0}%
		\else
			\def\b@pgfplots@should@sample@LINE{1}%
		\fi
	\else
		\ifcase\pgfplots@loc@TMPa\relax
			% sample dim=0 not useful!?
			\def\b@pgfplots@should@sample@LINE{1}%
		\or
			\def\b@pgfplots@should@sample@LINE{1}%
		\or
			\def\b@pgfplots@should@sample@LINE{0}%
		\else
			\pgfplots@error{Sorry, sample dim=\pgfplots@loc@TMPa\space is unsupported (use either 1 or 2)}%
		\fi
	\fi
	%
	\if0\b@pgfplots@should@sample@LINE
		% sample a matrix. Check the keys; if they are one
		% dimensional, switch back to line sampling:
		\pgfkeysgetvalue{/pgfplots/y domain}{\pgfplots@plot@ydomain}%
		\edef\pgfplots@plot@ydomain{\pgfplots@plot@ydomain}%
		\def\pgfplots@loc@TMPa{0:0}%
		\ifx\pgfplots@plot@ydomain\pgfplots@loc@TMPa
			\def\b@pgfplots@should@sample@LINE{1}%
		\fi
		\ifx\pgfplots@plot@ydomain\pgfutil@empty
			\let\pgfplots@plot@ydomain=\pgfplots@plot@domain
			\pgfkeyssetvalue{/pgfplots/y domain}{\pgfkeysvalueof{/pgfplots/domain}}%
		\fi
		\ifx\pgfplots@plot@samples@y\pgfutil@empty
		\else
			\ifnum\pgfplots@plot@samples@y<2
				\def\b@pgfplots@should@sample@LINE{1}%
			\fi
		\fi
	\else
		\def\b@pgfplots@should@sample@LINE{1}%
	\fi
	\ifx\pgfplots@plot@samples@y\pgfutil@empty
		\pgfkeyssetvalue{/pgfplots/samples y}{\pgfkeysvalueof{/pgfplots/samples}}%
		\pgfkeysgetvalue{/pgfplots/samples y}\pgfplots@plot@samples@y
	\fi
	%
	\iftikz@plot@raw@gnuplot
		% FIXME : verify this case
	\else
		\pgfkeyssetvalue{/pgfplots/mesh/rows}{\pgfkeysvalueof{/pgfplots/samples y}}%
		\pgfkeyssetvalue{/pgfplots/mesh/cols}{\pgfkeysvalueof{/pgfplots/samples}}%
	\fi
	\if1\b@pgfplots@should@sample@LINE
		\pgfkeyssetvalue{/pgfplots/sample dim}{1}%
		\pgfkeyssetvalue{/pgfplots/mesh/cols}{1}%
	\else
		\pgfkeyssetvalue{/pgfplots/sample dim}{2}%
	\fi
	%
}%

% Plot expression. It invokes the pgf math parser and a customized
% pgfplots point sampling routine. Combined with the 'fixed point
% library' of pgf, it results in highly accurate plots.
%
%
\long\def\pgfplots@addplotimpl@expression#1#2(#3,#4)#5;{\pgfplots@addplotimpl@expression@{#1}{#2}{#3}{#4}{#5}}%
% \addplot[#1] [#2] (#3,#4) #5;
\long\def\pgfplots@addplotimpl@expression@#1#2#3#4#5{%
	\def\pgfplotssurveyphaseinputclass{expression}%
	\pgfplots@start@plot@with@behavioroptions{#1,/pgfplots/.cd,#2,/pgfplots/mesh input=lattice,/pgfplots/mesh/ordering/x varies}%
	\pgfplots@plot@expression@preparekeys
	%
	\pgfplots@PREPARE@COORD@STREAM{#5}%
	%
	% Determine whether the x range is parameterized or uniform and
	% prepare a macro which assigns \pgfplots@current@point@x:
	\def\pgfplots@addplotimpl@expression@prepare@x{%
		\pgfmathparse{#3}%
		\let\pgfplots@current@point@x=\pgfmathresult
	}%
	\def\pgfplots@addplotimpl@expression@hasuniform@x{0}%
	\def\pgfplots@loc@TMPa{#3}%
	% do we have '\x' as x coordinate?
	\expandafter\def\expandafter\pgfplots@loc@TMPb\expandafter{\tikz@plot@var}%
	\ifx\pgfplots@loc@TMPa\pgfplots@loc@TMPb
		\def\pgfplots@addplotimpl@expression@hasuniform@x{1}%
	\else
		\def\pgfplots@loc@TMPb{x}%
		% do we have 'x' as x coordinate?
		\ifx\pgfplots@loc@TMPa\pgfplots@loc@TMPb
			\def\pgfplots@addplotimpl@expression@hasuniform@x{1}%
		\fi
	\fi
	\if\pgfplots@addplotimpl@expression@hasuniform@x1%
		% if '#3' is '\x' or 'x', we don't need the math parser -
		% we can simply take \tikz@plot@var.
		\def\pgfplots@addplotimpl@expression@prepare@x{%
			\edef\pgfplots@current@point@x{\tikz@plot@var}%
		}%
	\fi
	%
	%
	% Now, prepare the loops.
	%
	% I am using \pgfplotsforeachungrouped in favor of
	% \foreach because \foreach does NOT allow extended
	% precision. Besides, \pgfplotsforeachungrouped avoids
	% scoping problems.
	%
	\ifpgfplots@curplot@threedim
		\def\pgfplots@addplotimpl@expression@split@yz##1,##2\pgfplots@EOI{%
			\def\pgfplots@addplotimpl@expression@yEXPR{##1}%
			\def\pgfplots@addplotimpl@expression@zEXPR{##2}%
		}%
		\pgfplots@addplotimpl@expression@split@yz#4\pgfplots@EOI%
		%
		% we don't have 'samples at' for 3D plots -> use domain!
		\expandafter\pgfplots@domain@to@foreach\pgfplots@plot@domain\relax{\pgfplots@plot@samples}%
		\let\pgfplots@expression@xdomain=\pgfplotsretval
		%
		\if0\b@pgfplots@should@sample@LINE
			% Samples twodimensionally (a lattice):
			\expandafter\pgfplots@domain@to@foreach\pgfplots@plot@ydomain\relax{\pgfplots@plot@samples@y}%
			\let\pgfplots@expression@ydomain=\pgfplotsretval
			%
			% Assemble a 
			% \pgfplots@plot@data##1 -> 
			% 	\foreach \y in {-5,-4.6,...,5} {##1}; 
			% 		\foreach \x in {-5,-4.6,...,5} 
			%  macro:
			\edef\pgfplots@plot@data##1{%
				\noexpand\pgfplotsforeachungrouped\expandafter\noexpand\pgfplots@plot@var@y in {\pgfplots@expression@ydomain} 
					{%
						\noexpand\pgfplotsforeachungrouped\expandafter\noexpand\tikz@plot@var in {\pgfplots@expression@xdomain} {##1}%
						\noexpand\pgfplotsplothandlernotifyscanlinecomplete
					}%
				}%
		\else
			% sample a line:
			\def\pgfplots@plot@ydomain{0:0}%
			\edef\pgfplots@plot@data##1{%
				\noexpand\pgfplotsforeachungrouped\expandafter\noexpand\tikz@plot@var in {\pgfplots@expression@xdomain} {##1}}%
			%
			% If we have (\x,\y,f(x)), use (\x,0,f(x)) instead and
			% suppress the error message which would occur for \y.
			\expandafter\pgfplotsutilifstringequal\expandafter{\pgfplots@addplotimpl@expression@yEXPR}{\pgfplots@plot@var@y}{%
				\def\pgfplots@addplotimpl@expression@yEXPR{0}%
			}{%
				\expandafter\edef\pgfplots@plot@var@y{\pgfplots@plot@var@y@nonmacro}% this provides an error message, see above.
			}%
		\fi
	\else
		% Assemble a 
		% \pgfplots@plot@data##1 -> \foreach \x in {-5,-4.6,...,5} {##1} macro:
		%
		%
		% if( 	
		% 	x is logarithmic && 
		% 	#3 == '\x' && 
		% 	the 'samples at' key has not been used )
		%  -> sample logarithmically!
		\def\pgfplots@samples@logarithmically{0}%
		\ifpgfplots@xislinear
		\else
			\if\pgfplots@addplotimpl@expression@hasuniform@x1%
				\ifx\pgfplots@plot@samples@at\pgfutil@empty
					% we don't have 'samples at' -> use domain!
					\def\pgfplots@samples@logarithmically{1}%
				\fi
			\fi
		\fi
		\if\pgfplots@samples@logarithmically1%
			\def\pgfplotsforeachlogarithmicmathid{x}% use \pgfplotscoordmath{x}
			% sample logarithmically:
			\edef\pgfplots@plot@data##1{%
				\noexpand\pgfplotsforeachlogarithmicungrouped[\pgfplots@plot@samples]
				\expandafter\noexpand\tikz@plot@var/\noexpand\pgfplots@current@point@x@log 
					in {\pgfplots@plot@domain} {##1}}%
			%  we have a logarithmic sampling sequence,
			% \pgfplots@current@point@x@log is already available
			% logarithmic! We can safe time and accuracy for the x
			% coordinate by using that one instead of computing
			% log(exp(\x)) numerically:
			\pgfplots@disablelogfilter@xtrue
			\def\pgfplots@addplotimpl@expression@prepare@x{%
				\let\pgfplots@current@point@x=\pgfplots@current@point@x@log
			}%
			\pgflibraryfpuifactive
				{\relax}
				{%
					% ok, if the FPU is NOT active, we should return
					% results as fixed points.
					% We need to configure that for
					% \pgfplotsforeachlogarithmicungrouped manually:
					\pgfplotsforeachlogarithmicformatresultwith{%
						\pgfmathfloattofixed{\pgfmathresult}%
					}%
				}%
		\else
			\ifx\pgfplots@plot@samples@at\pgfutil@empty
				% we don't have 'samples at' -> use domain!
				\expandafter\pgfplots@domain@to@foreach\pgfplots@plot@domain\relax{\pgfplots@plot@samples}%
				\let\pgfplots@loc@TMPa=\pgfplotsretval
			\else
				% use 'samples at':
				\let\pgfplots@loc@TMPa=\pgfplots@plot@samples@at
			\fi
			\edef\pgfplots@plot@data##1{
				\noexpand\pgfplotsforeachungrouped\expandafter\noexpand\tikz@plot@var in {\pgfplots@loc@TMPa} {##1}}%
		\fi
		\expandafter\def\pgfplots@plot@var@y{0}%
		\def\pgfplots@addplotimpl@expression@yEXPR{#4}%
		\def\pgfplots@current@point@z{}%
	\fi
	%
	% START:
	%  (NOTE: this does also define 'x', 'y', and 'z' math
	%  expressions!)
	\pgfplots@coord@stream@start
	%
	% create a backup of the 'x' and 'y' math expressions which 
	% have been defined in \pgfplots@coord@stream@start:
	\let\pgfplots@addplotimpl@expression@pseudoconst@old@x=\pgfmathx@
	\let\pgfplots@addplotimpl@expression@pseudoconst@old@y=\pgfmathy@
	%
	% Prepare 'x' and 'y' as pseudo constants in expressions:
	\gdef\pgfplots@noy@error{%
		\pgfplots@error{Sorry, you can't use 'y' in this context. PGFPlots expected to sample a line, not a mesh. Please use the [mesh] option combined with [samples y>0] and [domain y!=0:0] to indicate a twodimensional input domain}%
		\global\let\pgfplots@noy@error=\relax
	}%
	% Define a "function" x which sets \pgfmathresult := \x :
	\pgfplotsmathdeclarepseudoconstant{\pgfplots@plot@var@nonmacro}{\edef\pgfmathresult{\tikz@plot@var}}%
	\if0\b@pgfplots@should@sample@LINE
		% surface:
		\pgfplotsmathdeclarepseudoconstant{\pgfplots@plot@var@y@nonmacro}{\edef\pgfmathresult{\pgfplots@plot@var@y}}%
	\else
		\pgfplotsmathdeclarepseudoconstant{\pgfplots@plot@var@y@nonmacro}{\pgfplots@noy@error\def\pgfmathresult{0.0}}%
	\fi
	% remember them here:
	\let\pgfplots@addplotimpl@expression@pseudoconst@x=\pgfmathx@
	\let\pgfplots@addplotimpl@expression@pseudoconst@y=\pgfmathy@
	%
	%
	% Warning for use fpu=false: evaluation '\x^3' might be different from 'x^3' for
	% negative arguments:
	% \x^3 ---> -0.2^3  but x^3 = (-0.2)^3 .
	% This does not happen for use fpu=true.
	% 
	\pgfplots@plot@data{%
		\let\pgfmathx@=\pgfplots@addplotimpl@expression@pseudoconst@x
		\let\pgfmathy@=\pgfplots@addplotimpl@expression@pseudoconst@y
		% eval expressions:
		\pgfplots@addplotimpl@expression@prepare@x%
		\pgfmathparse{\pgfplots@addplotimpl@expression@yEXPR}%
		\let\pgfplots@current@point@y=\pgfmathresult
		\ifpgfplots@curplot@threedim
			\pgfmathparse{\pgfplots@addplotimpl@expression@zEXPR}%
			\let\pgfplots@current@point@z=\pgfmathresult
		\fi
		% restore 'x' and 'y':
		\let\pgfmathx@=\pgfplots@addplotimpl@expression@pseudoconst@old@x
		\let\pgfmathy@=\pgfplots@addplotimpl@expression@pseudoconst@old@y
		%
		% process coords as usual:
		\pgfplots@coord@stream@coord
	}%
	\pgfplots@coord@stream@end
}%
% \addplot[#1] [#2] {#3} #4;
\long\def\pgfplots@addplotimpl@expression@curly#1#2#3#4;{\pgfplots@addplotimpl@expression@curly@{#1}{#2}{#3}{#4}}%
\long\def\pgfplots@addplotimpl@expression@curly@#1#2#3#4{%
	\pgfplots@gettikzinternal@keyval{variable}{tikz@plot@var}{\x}%
	\ifpgfplots@curplot@threedim
		\t@pgfplots@toka={,#3}%
		\def\pgfplots@loc@TMPa{\pgfplots@addplotimpl@expression@{#1}{#2}}%
		% the \pgfplots@plot@var@y will expand to the current value of
		% '/pgfplots/variable y'.
		% Keep it this way, \pgfplots@addplotimpl@expression@ checks
		% for that special string.
		\edef\pgfplots@loc@TMPb{%
			{\expandafter\noexpand\tikz@plot@var}%
			{\noexpand\pgfplots@plot@var@y\the\t@pgfplots@toka}%
		}%
		\expandafter\pgfplots@loc@TMPa\pgfplots@loc@TMPb{#4}%
	\else
		\t@pgfplots@tokc={\pgfplots@addplotimpl@expression@{#1}{#2}}%
		\def\pgfplots@loc@TMPa{\the\t@pgfplots@tokc}% this construction allows '#' in either '#1' or '#2'
		\expandafter\pgfplots@loc@TMPa\expandafter{\tikz@plot@var}{#3}{#4}%
	\fi
}%
% \addplot[#1] [#2] expression[#3] {#4} #5;
\def\pgfplots@addplotimpl@expression@e#1#2expression{%
	\pgfplotsutil@ifnextchar[{%
		\pgfplots@addplotimpl@expression@e@{#1}{#2}%
	}{%
		\pgfplots@addplotimpl@expression@e@{#1}{#2}[]%
	}%
}%
\def\pgfplots@addplotimpl@expression@e@#1#2[#3]{%
	\pgfplots@addplotimpl@expression@curly{#1}{#2,#3}%
}%


\let\pgfplots@backupof@pgfplotxyfile=\pgfplotxyfile

% the following code 
% results finally in
%
% set format "%.7e";; set samples <...>; plot ...
%
% The windows port of gnuplot doesn't run without the second semicolon
% - for whatever reason.
{
  \catcode`\%=12
  \catcode`\"=12
  \catcode`\;=12
  \xdef\pgfplots@gnuplot@format{set format "%.7e";}
}
\def\pgfplots@addplotimpl@g#1#2g{%
	\pgfplotsutil@ifnextchar r{%
		\pgfplots@addplotimpl@graphics{#1}{#2}%
	}{%
		\pgfplots@addplotimpl@gnuplot{#1}{#2}%
	}%
}%

% |\addplot gnuplot| is an alias to |\addplot function|
\def\pgfplots@addplotimpl@gnuplot#1#2nuplot{\pgfplots@addplotimpl@function{#1}{#2}unction}%

% \addplot[#1] plot[#2] function[#3] {#4} #5;
\def\pgfplots@addplotimpl@function#1#2unction{%
	\pgfplotsutil@ifnextchar[{%
		\pgfplots@addplotimpl@function@opt{#1}{#2}%
	}{%
		\pgfplots@addplotimpl@function@opt{#1}{#2}[]%
	}%
}%
\def\pgfplots@addplotimpl@function@opt#1#2[#3]#4#5;{\pgfplots@addplotimpl@function@opt@{#1}{#2}{#3}{#4}{#5}}%
% \addplot[#1] [#2] function[#3] {#4} #5;
\def\pgfplots@addplotimpl@function@opt@#1#2#3#4#5{%
	% FIXME : what about the key search paths if the user changes
	% them!?
	\def\pgfplotssurveyphaseinputclass{gnuplot}%
	\pgfplots@start@plot@with@behavioroptions{#1,/pgfplots/.cd,#2,/pgfplots/.cd,#3,/pgfplots/mesh/ordering/x varies}%
	%
	\pgfplots@gettikzinternal@keyval{prefix}{tikz@plot@prefix}{\jobname.}%
	\pgfplots@gettikzinternal@keyval{id}{tikz@plot@id}{pgf-plot}%
	\pgfplots@gettikzinternal@keyval{raw gnuplot}{iftikz@plot@raw@gnuplot}{\iffalse}%
	\pgfplots@gettikzinternal@keyval{parametric}{iftikz@plot@parametric}{\iffalse}%
	%
	% determine dummy variables:
	\iftikz@plot@parametric
		\ifpgfplots@curplot@threedim
			\pgfkeysgetvalue{/pgfplots/parametric/var 2d}\pgfplots@gnuplot@dummy%
		\else
			\pgfkeysgetvalue{/pgfplots/parametric/var 1d}\pgfplots@gnuplot@dummy%
		\fi
		\ifx\pgfplots@gnuplot@dummy\pgfutil@empty
		\else
			\expandafter\pgfutil@in@\expandafter,\expandafter{\pgfplots@gnuplot@dummy}%
			\ifpgfutil@in@	
				\def\pgfplots@loc@TMPa##1,##2\pgfeov{\pgfplotsset{variable={##1},variable y={##2}}}%
			\else
				\def\pgfplots@loc@TMPa##1\pgfeov{\pgfplotsset{variable={##1}}}%
			\fi
			\expandafter\pgfplots@loc@TMPa\pgfplots@gnuplot@dummy\pgfeov
		\fi
	\fi
	%
	% prepare domain and samples, normalize dummy variables:
	\pgfplots@plot@expression@preparekeys
	%
	% FIXME: what with 'samples at'!?
	\edef\pgfplots@plot@filename{\tikz@plot@prefix\tikz@plot@id}%
	%
	\def\pgfplots@addplotimpl@gnuplotresult@isthreedim@withtwocoords{0}%
	%
	\edef\pgfplots@gnuplotcode{#4}%
	\ifpgfplots@translategnuplot
		\def\pgfplots@loc@TMPa{\pgfplotsutilstrreplace{^}{**}}%
		\expandafter\pgfplots@loc@TMPa\expandafter{\pgfplots@gnuplotcode}%
		\let\pgfplots@gnuplotcode=\pgfplotsretval
	\fi
	%
	%
	\iftikz@plot@raw@gnuplot%
		\def\pgfplots@plot@data{\pgfplotgnuplot[\pgfplots@plot@filename]{\pgfplots@gnuplot@format;\pgfplots@gnuplotcode}}%
	\else%
		% collect logs:
		\def\pgfplots@gnuplot@logdirs{}%
		\ifpgfplots@xislinear
		\else
			\pgfplots@identify@gnuplot@logbehavior x%
			\expandafter\def\expandafter\pgfplots@gnuplot@logdirs\expandafter{\pgfplots@gnuplot@logdirs x}%
		\fi
		\ifpgfplots@yislinear
		\else
			\pgfplots@identify@gnuplot@logbehavior y%
			\expandafter\def\expandafter\pgfplots@gnuplot@logdirs\expandafter{\pgfplots@gnuplot@logdirs y}%
		\fi
		\ifpgfplots@curplot@threedim
			\ifpgfplots@zislinear
			\else
				\pgfplots@identify@gnuplot@logbehavior z%
				\expandafter\def\expandafter\pgfplots@gnuplot@logdirs\expandafter{\pgfplots@gnuplot@logdirs z}%
			\fi
		\fi
		%
		\ifpgfplots@curplot@threedim
			\if1\b@pgfplots@should@sample@LINE
				\pgfplots@error{Sorry, I do not know how to sample 3D LINE plots with gnuplot... I only know 2D line and 3D mesh. You may want to help the author of pgfplots to improve this feature.}%
			\fi
		\fi
		\def\pgfplots@gnuplot@x{\pgfplots@plot@var@nonmacro}%
		\def\pgfplots@gnuplot@y{\pgfplots@plot@var@y@nonmacro}%
		\def\pgfplots@plot@data{\pgfplotgnuplot[\pgfplots@plot@filename]{%
			\pgfplots@gnuplot@format;
			set samples \pgfkeysvalueof{/pgfplots/samples}\if0\b@pgfplots@should@sample@LINE, \pgfkeysvalueof{/pgfplots/samples y}\fi;
			set dummy \pgfplots@gnuplot@x,\pgfplots@gnuplot@y;
			\ifx\pgfplots@gnuplot@logdirs\pgfutil@empty
			\else
				set logscale \pgfplots@gnuplot@logdirs\space 2.71828182845905; 
			\fi
			\iftikz@plot@parametric	set parametric;\fi
			\ifpgfplots@curplot@threedim 
				\if0\b@pgfplots@should@sample@LINE
					% Samples twodimensionally (a lattice):
					% and the isosamples thing confuses me.
					set isosamples \pgfkeysvalueof{/pgfplots/samples}\if0\b@pgfplots@should@sample@LINE, \pgfkeysvalueof{/pgfplots/samples y}\fi;
					splot [\pgfplots@gnuplot@x=\pgfplots@plot@domain] [\pgfplots@gnuplot@y=\pgfplots@plot@ydomain] \pgfplots@gnuplotcode;%
				\else
					% *should* sample a line, but I don't know how.
					splot [\pgfplots@gnuplot@x=\pgfplots@plot@domain] \pgfplots@gnuplotcode;%
				\fi
			\else
				plot [\pgfplots@gnuplot@x=\pgfplots@plot@domain] \pgfplots@gnuplotcode;%
			\fi
			}}%
	\fi%
	\def\pgfplotxyfile{\pgfplots@addplotimpl@gnuplotresult{#5}}%
	\pgfplots@plot@data
	\let\pgfplotxyfile=\pgfplots@backupof@pgfplotxyfile
}%

\def\pgfplots@identify@gnuplot@logbehavior#1{%
	\pgfutil@ifundefined{pgfplots@gnuplot@logscale@writes@log}{%
		\pgfplots@identify@gnuplot@logbehavior@checkversion%
	}{}%
	\if1\pgfplots@gnuplot@logscale@writes@log
		\csname pgfplots@disablelogfilter@#1true\endcsname
	\fi
}%
\def\pgfplots@identify@gnuplot@logbehavior@checkversion{%
	\begingroup
	\immediate\write18{gnuplot -V >\pgfplots@plot@filename.vrs}%
	\openin\r@pgfplots@reada=\pgfplots@plot@filename.vrs\relax
	\ifeof\r@pgfplots@reada
		\pgfplots@warning{Sorry, I could not determine 'gnuplot -V' to check whether gnuplot and logscale writes results in log() or not. Please set `/pgfplots/gnuplot writes logscale=true|false' manually.}%
		\gdef\pgfplots@gnuplot@logscale@writes@log{1}% something doesn't work. set it somehow.
	\else
		\read\r@pgfplots@reada to\pgfplots@loc@TMPa
		\gdef\pgfplots@gnuplot@logscale@writes@log{1}%
		\t@pgfplots@toka=\expandafter{\pgfplots@loc@TMPa}%
		\immediate\write-1{Package pgfplots: checking gnuplot -V : `\the\t@pgfplots@toka' (if this fails, set `/pgfplots/gnuplot writes logscale=true|false')}%
		\expandafter\pgfplots@identify@gnuplot@logbehavior@checkversion@\pgfplots@loc@TMPa 0 0.0 0\relax
		\if0\pgfplots@gnuplot@logscale@writes@log
			\immediate\write-1{Package pgfplots: I found gnuplot version >= 4.4. This one doesn't write log() coordinates. I will apply log() manually.}%
		\else
			\immediate\write-1{Package pgfplots: I found gnuplot version < 4.4. This one writes log() coordinates. I'll handle it accordingly.}%
		\fi
		\closein\r@pgfplots@reada
	\fi
	\endgroup
}%
\long\def\pgfplots@identify@gnuplot@logbehavior@checkversion@{%
	\pgfutil@ifnextchar\par{%
		\pgfplots@warning{Sorry, I can't reliably check which version of gnuplot is available. I guess it is gnuplot < 4.4. Please set `/pgfplots/gnuplot writes logscale=true|false' manually if anything fails.}%
		\gdef\pgfplots@gnuplot@logscale@writes@log{1}%
		\pgfplots@identify@gnuplot@logbehavior@checkversion@@@
	}{%
		\pgfplots@identify@gnuplot@logbehavior@checkversion@@
	}%
}%
\long\def\pgfplots@identify@gnuplot@logbehavior@checkversion@@@#1\relax{%
}%
\long\def\pgfplots@identify@gnuplot@logbehavior@checkversion@@#1 #2.#3 #4\relax{%
	% starting with gnuplot 4.4, output files are no longer in
	% logarithmic scale for log plots.
	\ifnum#2<4
		% version 3.X
		\gdef\pgfplots@gnuplot@logscale@writes@log{1}%
	\else
		\ifnum#2>4
			% version 5.X
			\gdef\pgfplots@gnuplot@logscale@writes@log{0}%
		\else
			\ifnum#3<4
				% version 4.2 :
				\gdef\pgfplots@gnuplot@logscale@writes@log{1}%
			\else
				% version 4.4 or later :
				\gdef\pgfplots@gnuplot@logscale@writes@log{0}%
			\fi
		\fi
	\fi
}%

\def\pgfplots@addplotimpl@gnuplotresult#1#2{%
	\begingroup
	\openin\r@pgfplots@reada=#2
	\ifeof\r@pgfplots@reada
		\pgfplots@error{Sorry, the gnuplot-result file '#2' could not be found. Maybe you need to enable the shell-escape feature? For pdflatex, this is '>> pdflatex -shell-escape'. You can also invoke '>> gnuplot <file>.gnuplot' manually on the respective gnuplot file.}%
		\aftergroup\pgfplots@loop@CONTINUEfalse
	\else
		\aftergroup\pgfplots@loop@CONTINUEtrue
	\fi
	\closein\r@pgfplots@reada
	\endgroup
	\ifpgfplots@loop@CONTINUE
		 % Now, invoke 'plot file'.
		 %
		 % I invoke the private '@opt@' method because the semicolon ';' 
		 % character may cause problems due to catcode mismatches.
		 % *sigh*.
		\pgfplots@addplotimpl@file@opt@@{}{}{#2}{#1}% this does not invoke the \pgfplots@start@plot@with@behavioroptions method.
	\else
		\expandafter\pgfplots@end@plot
	\fi
}

% \addplot[#1] plot[#2] shell[#3] {#4} #5;
\def\pgfplots@addplotimpl@shell#1#2shell{%
	\pgfplotsutil@ifnextchar[{%
		\pgfplots@addplotimpl@shell@opt{#1}{#2}%
	}{%
		\pgfplots@addplotimpl@shell@opt{#1}{#2}[]%
	}%
}%
\def\pgfplots@addplotimpl@shell@opt#1#2[#3]#4#5;{\pgfplots@addplotimpl@shell@opt@{#1}{#2}{#3}{#4}{#5}}%
% \addplot[#1] [#2] shell[#3] {#4} #5;
\def\pgfplots@addplotimpl@shell@opt@#1#2#3#4#5{%
	\def\pgfplotssurveyphaseinputclass{shell}%
	\pgfplots@start@plot@with@behavioroptions{#1,/pgfplots/.cd,#2,/pgfplots/.cd,#3}%
	\pgfplots@gettikzinternal@keyval{prefix}{tikz@plot@prefix}{\jobname.}%
	\pgfplots@gettikzinternal@keyval{id}{tikz@plot@id}{pgf-shell}%
	%
	\def\pgfplots@plot@filename{\tikz@plot@prefix\tikz@plot@id}%  
	\def\pgfplots@plot@data{\pgfshell[\pgfplots@plot@filename]{#4}\pgfplotxyfile{\pgfplots@plot@filename.out}}%
	\def\pgfplotxyfile{\pgfplots@addplotimpl@shellresult{#5}}%
	\pgfplots@plot@data
	\let\pgfplotxyfile=\pgfplots@backupof@pgfplotxyfile
}%

\def\pgfplots@addplotimpl@shellresult#1#2{%
	\begingroup
	\openin\r@pgfplots@reada=#2
	\ifeof\r@pgfplots@reada
		\pgfplots@error{Sorry, the shell-result file '#2' could not be found. Maybe you need to enable the shell-escape feature? For pdflatex, this is '>> pdflatex -shell-escape'. You can also invoke '>> sh <file>.sh > <file>.out' manually on the respective shell file.}%
		\aftergroup\pgfplots@loop@CONTINUEfalse
	\else
		\aftergroup\pgfplots@loop@CONTINUEtrue
	\fi
	\closein\r@pgfplots@reada
	\endgroup
	\ifpgfplots@loop@CONTINUE
		 % Now, invoke 'plot file'.
		 %
		 % I invoke the private '@opt@' method because the semicolon ';' 
		 % character may cause problems due to catcode mismatches.
		 % *sigh*.
		\pgfplots@addplotimpl@file@opt@@{}{}{#2}{#1}%
	\else
		\expandafter\pgfplots@end@plot
	\fi
}

% \addplot[#1] [#2] file{#3} #4;
\def\pgfplots@addplotimpl@file#1#2ile{%
	\pgfplotsutil@ifnextchar[{%
		\pgfplots@addplotimpl@file@opt{#1}{#2}%
	}{%
		\pgfplots@addplotimpl@file@opt{#1}{#2}[]%
	}%
}

% \addplot[#1] [#2] file[#3] {#4} #5;
\def\pgfplots@addplotimpl@file@opt#1#2[#3]#4#5;{\pgfplots@addplotimpl@file@opt@{#1}{#2}{#3}{#4}{#5}}%
\def\pgfplots@addplotimpl@file@opt@#1#2#3#4#5{%
	% invoke this here - allows to share the 'plot file' impl with
	% 'plot gnuplot'.
	\def\pgfplotssurveyphaseinputclass{file}%
	\pgfplots@start@plot@with@behavioroptions{#1,/pgfplots/.cd,#2}%
	\pgfplots@addplotimpl@file@opt@@{#1,#2}{#3}{#4}{#5}%
}
\def\pgfplots@addplotimpl@file@opt@@#1#2#3#4{%
	\begingroup
	\def\pgfplots@loc@TMPa{#2}%
	\ifx\pgfplots@loc@TMPa\pgfutil@empty
	\else
		\pgfqkeys{/pgfplots/plot file}{#2}%
	\fi
	\pgfplots@PREPARE@COORD@STREAM{#4}%
	\pgfplots@addplotimpl@file@streamit{#3}%
	\endgroup
}%
% #1: the file name
\def\pgfplots@addplotimpl@file@streamit#1{%
	\pgfplots@coord@stream@start
	\pgfplotsscanlinelengthinitzero
	\openin\r@pgfplots@reada=#1
	\ifeof\r@pgfplots@reada
		\pgfplots@error{sorry, plot file{#1} could not be opened}%
	\else
		\pgfplots@logfileopen{#1}%
		\let\pgfplots@current@point@x@error=\pgfutil@empty
		\let\pgfplots@current@point@y@error=\pgfutil@empty
		\let\pgfplots@current@point@z@error=\pgfutil@empty
		\let\pgfplots@current@point@meta=\pgfutil@empty
		\ifpgfplots@curplot@threedim
			\let\pgfplots@addplotimpl@file@parsesingle=\pgfplots@addplotimpl@file@parsesingle@threedim
			\if1\csname pgfpmeta@\pgfplotspointmetainputhandler @explicitinput\endcsname
				\let\pgfplots@addplotimpl@file@parsesingle=\pgfplots@addplotimpl@file@parsesingle@threedim@andmeta
			\fi
		\else
			\let\pgfplots@addplotimpl@file@parsesingle=\pgfplots@addplotimpl@file@parsesingle@twodim
			\if1\csname pgfpmeta@\pgfplotspointmetainputhandler @explicitinput\endcsname
				\let\pgfplots@addplotimpl@file@parsesingle=\pgfplots@addplotimpl@file@parsesingle@twodim@andmeta
			\fi
		\fi
		\pgfplotstableinstallignorechars%
		\pgfplots@addplotimpl@file@readall
	\fi
	\pgfplotsscanlinelengthcleanup
	\pgfplots@coord@stream@end
}%
\def\pgfplots@addplotimpl@file@readall{%
	\read\r@pgfplots@reada to\pgfplots@file@LINE
	\expandafter\pgfplotstableread@checkspecial@line\pgfplots@file@LINE\pgfplotstable@EOI
	\ifpgfplotstableread@skipline
	\else
		\ifpgfplots@plot@file@skipfirst
			% Silently skip first data row, assuming it is a header.
			\pgfplots@plot@file@skipfirstfalse
		\else
			\pgfplotsscanlinelengthincrease
			\expandafter\pgfplots@addplotimpl@file@parsesingle\pgfplots@file@LINE 0 0 0 0 0\pgfplots@EOI
		\fi
	\fi
	\ifeof\r@pgfplots@reada
	\else
		\expandafter
		\pgfplots@addplotimpl@file@readall
	\fi
}%

\def\pgfplots@addplotimpl@file@parsesingle@threedim#1 #2 #3 #4\pgfplots@EOI{%
	\def\pgfplots@current@point@x{#1}%
	\def\pgfplots@current@point@y{#2}%
	\def\pgfplots@current@point@z{#3}%
	\pgfplots@coord@stream@coord%
}%
\def\pgfplots@addplotimpl@file@parsesingle@twodim#1 #2 #3\pgfplots@EOI{%
	\def\pgfplots@current@point@x{#1}%
	\def\pgfplots@current@point@y{#2}%
	\pgfplots@coord@stream@coord%
}%
\def\pgfplots@addplotimpl@file@parsesingle@threedim@andmeta#1 #2 #3 #4 #5\pgfplots@EOI{%
	\def\pgfplots@current@point@x{#1}%
	\def\pgfplots@current@point@y{#2}%
	\def\pgfplots@current@point@z{#3}%
	\def\pgfplots@current@point@meta{#4}%
	\pgfplots@coord@stream@coord%
}%
\def\pgfplots@addplotimpl@file@parsesingle@twodim@andmeta#1 #2 #3 #4\pgfplots@EOI{%
	\def\pgfplots@current@point@x{#1}%
	\def\pgfplots@current@point@y{#2}%
	\def\pgfplots@current@point@meta{#3}%
	\pgfplots@coord@stream@coord%
}%


\def\pgfplots@addplotimpl@graphics#1#2raphics{%
	\pgfplotsutil@ifnextchar[{%
		\pgfplots@addplotimpl@graphics@{#1}{#2}%
	}{%
		\pgfplots@addplotimpl@graphics@{#1}{#2}[]%
	}%
}%
% \addplot[#1] plot[#2] graphics[#3] {#4} #5;
\long\def\pgfplots@addplotimpl@graphics@#1#2[#3]#4#5;{\pgfplots@addplotimpl@graphics@@{#1}{#2}{#3}{#4}{#5}}%
\long\def\pgfplots@addplotimpl@graphics@@#1#2#3#4#5{%
	\def\pgfplotssurveyphaseinputclass{graphics}%
	\pgfplots@start@plot@with@behavioroptions{%
		/pgfplots/filter discard warning=false,
		/pgfplots/mesh/rows=2,% allow \addplot[surf] graphics ... --> yields a good legend.
		/pgfplots/mesh/cols=2,
		/pgfplots/mesh/check=false,
		#1,/pgfplots/.cd,#2,%
		/pgfplots/plot graphics/@prepare legend,
		/pgfplots/plot graphics,%
		/pgfplots/plot graphics/.cd,%
		#3,%
		/pgfplots/plot graphics/src={#4},%
		/tikz/mark=}%
	\pgfplots@PREPARE@COORD@STREAM{#5}%
	\pgfplots@coord@stream@start
	%
	\pgfkeysgetvalue{/pgfplots/plot graphics/points}{\pgfplots@current@point@points}%
	\ifx\pgfplots@current@point@points\pgfutil@empty
	\else
		\let\pgfplotsplothandlergraphicspointmappoint=\pgfplotsplothandlergraphics@survey@pointmappoint
		\expandafter\pgfplots@plot@handler@graphics@parsepointmap\expandafter{\pgfplots@current@point@points}%
		\ifpgfplots@plot@graphics@autoadjustaxis
			\pgfplotsplothandlergraphicspointmapcomputerequiredview
			\ifx\pgfplotsretval\pgfutil@empty
			\else
				\expandafter\pgfplotssetlateoptions\expandafter{\pgfplotsretval}%
			\fi
		\fi
		%
		\def\pgfplots@addplotimpl@graphics@@error##1{}%
	\fi
	%
	\pgfkeysgetvalue{/pgfplots/plot graphics/xmin}{\pgfplots@current@point@x}%
	\pgfkeysgetvalue{/pgfplots/plot graphics/ymin}{\pgfplots@current@point@y}%
	%
	% these sanity checks do nothing of the 'plot graphics/points' feature has been used:
	\ifx\pgfplots@current@point@x\pgfutil@empty\pgfplots@addplotimpl@graphics@@error{xmin}\fi
	\ifx\pgfplots@current@point@y\pgfutil@empty\pgfplots@addplotimpl@graphics@@error{ymin}\fi
	\ifpgfplots@curplot@threedim
		\pgfkeysgetvalue{/pgfplots/plot graphics/zmin}{\pgfplots@current@point@z}%
	\ifx\pgfplots@current@point@z\pgfutil@empty\pgfplots@addplotimpl@graphics@@error{zmin}\fi
	\fi
	\pgfplots@coord@stream@coord
	%
	\pgfkeysgetvalue{/pgfplots/plot graphics/xmax}{\pgfplots@current@point@x}%
	\pgfkeysgetvalue{/pgfplots/plot graphics/ymax}{\pgfplots@current@point@y}%
	\ifx\pgfplots@current@point@x\pgfutil@empty\pgfplots@addplotimpl@graphics@@error{xmax}\fi
	\ifx\pgfplots@current@point@y\pgfutil@empty\pgfplots@addplotimpl@graphics@@error{ymax}\fi
	\ifpgfplots@curplot@threedim
		\pgfkeysgetvalue{/pgfplots/plot graphics/zmax}{\pgfplots@current@point@z}%
		\ifx\pgfplots@current@point@z\pgfutil@empty\pgfplots@addplotimpl@graphics@@error{zmax}\fi
	\fi
	\pgfplots@coord@stream@coord
	%
	\pgfplots@coord@stream@end
}%
\def\pgfplots@addplotimpl@graphics@@error#1{%
	\begingroup
	\pgfplots@error{Sorry, but 'plot graphics' can't determine where to place the graphics file - (at least) the key '#1' is missing. Please verify that you provided all required limits, for example 'plot graphics[xmin=0,xmax=1,ymin=0,ymax=1] {<graphics>}'.}%
	\endgroup
}%




% \addplot[#1] table[#2] [from] {<\macro>} #4;
% or
% \addplot[#1] table[#2] {<filename>} #4;
%
% The distinction between <\macro> and <filename> is done
% automatically.
%
% Input options can be provided in '#2' using
% - column names, 
%   	for example '/pgfplots/table/x=firstcol' or just 'x=firstcol'
%
% - column indices,
%   	for example '/pgfplots/table/x index=3' or just 'x index=3'
%
% - expressions involving any of the table's data cells in the
%   currently processed cell,
%   	for example '/pgfplots/table/x expr={\columnx * \columny + \thisrow{columnxxx}/2}'
%   During expr, the following (non-exhaustive) list of macros is
%   available:
%   	- \columnx, \columny, \columnz, \columnmeta, \columnerrorx,
%   	\columnerrory, \columnerrorz
%   	Provide access to the cell content which would be used without
%   	'expr'.
%   	The first three access the input coordinate columns, \meta the meta column 
%   	(if any) and the last three the error data (if any). 
%
%		That means it is allowed to provide both, 'x' and 'x expr': 
%		'x expr' can use the (old) value stored in 'x'. the final x
%		coordinate will be that returned of 'x expr'.
%
%   	- \coordindex 
%
%   	- \lineno (physical line numbers including comments etc)
%
%   	- \thisrow{<colname>}
%   		allows access to any columns.
%
%   	- \getthisrow{<colname>}{<\macro>}
%   		this is a fragile command! Don't use it directly inside of
%   		a math expression, prefer \thisrow.
%
%   The FPU will be used to evaluate any expressions.
%
% @REMARKS the implementation for '* expr' differs for the '<\macro>'
% and '<filename>' input types:
% - for '{<filename>}', only the current row is available.
% - for '{<\macro>}', the `create on use' framework of the table
%   package is used - with all its features, including comfortable
%   access to the previous and next row and accumulation features.
\def\pgfplots@addplotimpl@table#1table{%
	\pgfplotsutil@ifnextchar[{%
		\pgfplots@addplotimpl@table@getopts{#1}%
	}{%
		\pgfplots@addplotimpl@table@getopts{#1}[]%
	}%
}%

\def\pgfplots@addplotimpl@table@getopts#1[#2]{%
	% set options outside of the following group.
	% They may contain behavior options.
	\pgfplots@addplotimpl@table@installkeypath
	\pgfplotstableset{#2}%
	%
	\pgfplotsutil@ifnextchar s{%
		\pgfplots@addplotimpl@table@fromshell{#1}{#2}%
	}{%
		\pgfplotsutil@ifnextchar f{%
			\pgfplots@addplotimpl@table@fromstructure@gobble@space{#1}{#2}%
		}{%
			\pgfplots@addplotimpl@table@fromfile@gobble@space{#1}{#2}%
		}%
	}%
}

% this macro simply invokes the "correct" table processing routine.
% The distinction between 'table from {<\macro>}' and 'table
% {<filename>}' is deprecated; it is done automatically now.
%
% \addplot[#1] table[#2] [from] {#3} #4;
\def\pgfplots@addplotimpl@table@startprocessing#1#2#3#4{%
	\pgfplotstable@isloadedtable{#3}{%
		\pgfplots@addplotimpl@table@fromstructure@{#1}{#2}{#3}{#4}%
	}{%
		\pgfplots@addplotimpl@table@fromfile@{#1}{#2}{#3}{#4}%
	}%
}%

% \addplot[#1] table[#2] from {#3} #4;
%
% #1: arguments to \addplot[...]
% #2: arguments to table[...] (already processed!)
% #3: the argument of plot table{...}
% #4: trailing path arguments after plot table{...}#4;
\long\def\pgfplots@addplotimpl@table@fromstructure@gobble@space#1#2from{%
	\pgfplotstablecollectoneargwithpreparecatcodes{%
		\pgfplots@addplotimpl@table@fromstructure{#1}{#2}from%
	}%
}%

\def\pgfplots@addplot@table@fromstructure@preparecolname#1#2#3#4{%
	\pgfkeysgetvalue{/pgfplots/table/#1}{\pgfplots@loc@TMPa}%
	%
	\ifx\pgfplots@loc@TMPa\pgfutil@empty
		\pgfkeysgetvalue{/pgfplots/table/#1 index}{\pgfplots@loc@TMPa}%
		\ifx\pgfplots@loc@TMPa\pgfutil@empty
		\else
			\pgfplotstablegetcolumnnamebyindex\pgfplots@loc@TMPa\of#2\to\pgfplots@loc@TMPa
		\fi
	\fi
	\let#3=\pgfplots@loc@TMPa
	%
	% modify \pgfplots@plot@tbl@{x,y,z,meta} if there are
	% corresponding '#1 expr' statements:
	\pgfplots@addplotimpl@table@fromstructure@prepareexpr@for{#1}{#3}{#4}%
}

% Invokes `#1' if the command is invoked within 
%   \addplot table {<\macro>};
% and `#2' if not.
\def\pgfplotsifinaddplottablestruct#1#2{%
	\pgfutil@ifundefined{pgfplots@plot@tbl@meta}{#2}{#1}%
}%

\long\def\pgfplots@addplotimpl@table@fromstructure#1#2from#3#4;{\pgfplots@addplotimpl@table@startprocessing{#1}{#2}{#3}{#4}}%
% \addplot[#1] table[#2] from {#3} #4 ;
\long\def\pgfplots@addplotimpl@table@fromstructure@#1#2#3#4{%
	\begingroup
	\def\pgfplotstablename{#3}% store the name of the currently processed table.
	\pgfplotstablegetscanlinelength{#3}{\pgfplotsscanlinelength}%
	% FIXME : this thing here has runtime O(N^2) !
	% I fear it is faster to simply reload the data .... !?
	%
	% well, for a lot of columns which are used in different contexts
	% and few rows, this here IS more efficient.
	%
	\pgfplots@addplot@table@fromstructure@preparecolname{x}{#3}\pgfplots@plot@tbl@x\columnx
	\pgfplots@addplot@table@fromstructure@preparecolname{y}{#3}\pgfplots@plot@tbl@y\columny
	\ifpgfplots@curplot@threedim
	\pgfplots@addplot@table@fromstructure@preparecolname{z}{#3}\pgfplots@plot@tbl@z\columnz
	\fi
	\pgfplots@addplot@table@fromstructure@preparecolname{meta}{#3}\pgfplots@plot@tbl@meta\columnmeta
	%
	%
	% high level user interface functions:
	\let\pgfplotstable@coordindex@old=\coordindex
	\def\coordindex{\pgfplotstablerow}%
	\def\lineno{\coordindex}% is the same here
	% These macros are-unfortunately- not accessable here. And the
	% worst is: error messages are impossible either because they are
	% not executed... try to provide useful hints:
	\def\thisrow##1{thisrow_unavailable_load_table_directly}%
	\def\thisrowno##1{thisrowno_unavailable_load_table_directly}%
	% this should work.
	\def\getthisrow##1##2{\pgfplotstablegetelem{\coordindex}{##1}\of{#3}{##2}}%
	\def\getthisrowno##1##2{\pgfplotstablegetelem{\coordindex}{[index]##1}\of{#3}{##2}}%
	%
	\expandafter\pgfplotstablegetcolumnbyname\expandafter{\pgfplots@plot@tbl@x}\of#3\to\addplot@tbl@x
	\expandafter\pgfplotstablegetcolumnbyname\expandafter{\pgfplots@plot@tbl@y}\of#3\to\addplot@tbl@y
	\ifpgfplots@curplot@threedim
		\expandafter\pgfplotstablegetcolumnbyname\expandafter{\pgfplots@plot@tbl@z}\of#3\to\addplot@tbl@z
	\fi
	%
	\let\addplot@tbl@meta=\pgfutil@empty
	\ifx\pgfplots@plot@tbl@meta\pgfutil@empty
	\else
		\expandafter\pgfplotstablegetcolumnbyname\expandafter{\pgfplots@plot@tbl@meta}\of#3\to\addplot@tbl@meta
	\fi
	%
	%
	\let\addplot@tbl@error@x=\pgfutil@empty
	\let\addplot@tbl@error@y=\pgfutil@empty
	\let\addplot@tbl@error@z=\pgfutil@empty
	\ifpgfplots@errorbars@enabled
		\pgfplots@addplot@table@fromstructure@preparecolname{x error}{#3}\pgfplots@plot@tbl@error@x\columnerrorx
		\pgfplots@addplot@table@fromstructure@preparecolname{y error}{#3}\pgfplots@plot@tbl@error@y\columnerrory
		\ifpgfplots@curplot@threedim
			\pgfplots@addplot@table@fromstructure@preparecolname{z error}{#3}\pgfplots@plot@tbl@error@z\columnerrorz
		\else
			\let\pgfplots@plot@tbl@error@z=\pgfutil@empty
		\fi
		%
		% now: load the columns:
		\ifx\pgfplots@plot@tbl@error@x\pgfutil@empty
		\else
			\expandafter\pgfplotstablegetcolumnbyname\expandafter{\pgfplots@plot@tbl@error@x}\of#3\to\addplot@tbl@error@x
		\fi
		\ifx\pgfplots@plot@tbl@error@y\pgfutil@empty
		\else
			\expandafter\pgfplotstablegetcolumnbyname\expandafter{\pgfplots@plot@tbl@error@y}\of#3\to\addplot@tbl@error@y
		\fi
		\ifx\pgfplots@plot@tbl@error@z\pgfutil@empty
		\else
			\expandafter\pgfplotstablegetcolumnbyname\expandafter{\pgfplots@plot@tbl@error@z}\of#3\to\addplot@tbl@error@z
		\fi
		%
	\else
		\let\pgfplots@current@point@x@error=\pgfutil@empty
		\let\pgfplots@current@point@y@error=\pgfutil@empty
		\let\pgfplots@current@point@z@error=\pgfutil@empty
	\fi
	%
	\let\coordindex=\pgfplotstable@coordindex@old
	%
	\pgfplots@PREPARE@COORD@STREAM{#4}%
	\pgfplots@coord@stream@start
	\pgfutil@loop
	\pgfplotslistcheckempty\addplot@tbl@x
	\ifpgfplotslistempty
		\pgfplots@loop@CONTINUEfalse
	\else
		% This here is just for sanity checking: if the 'y' column is 
		% - for whatever reasons - invalid; provide good error
		%   recovery.
		\pgfplotslistcheckempty\addplot@tbl@y
		\ifpgfplotslistempty
			\pgfplots@loop@CONTINUEfalse
		\else
			\pgfplots@loop@CONTINUEtrue
		\fi
	\fi
	\ifpgfplots@loop@CONTINUE
		\pgfplotslistpopfront\addplot@tbl@x\to\pgfplots@current@point@x
		\pgfplotslistpopfront\addplot@tbl@y\to\pgfplots@current@point@y
		\ifpgfplots@curplot@threedim
			\pgfplotslistpopfront\addplot@tbl@z\to\pgfplots@current@point@z
		\fi
		\ifx\addplot@tbl@meta\pgfutil@empty
		\else
			\pgfplotslistpopfront\addplot@tbl@meta\to\pgfplots@current@point@meta
		\fi
		\ifpgfplots@errorbars@enabled
			\ifx\addplot@tbl@error@x\pgfutil@empty
				\let\pgfplots@current@point@x@error=\pgfutil@empty
			\else
				\pgfplotslistpopfront\addplot@tbl@error@x\to\pgfplots@current@point@x@error
			\fi
			\ifx\addplot@tbl@error@y\pgfutil@empty
				\let\pgfplots@current@point@y@error=\pgfutil@empty
			\else
				\pgfplotslistpopfront\addplot@tbl@error@y\to\pgfplots@current@point@y@error
			\fi
			\ifx\addplot@tbl@error@z\pgfutil@empty
				\let\pgfplots@current@point@z@error=\pgfutil@empty
			\else
				\pgfplotslistpopfront\addplot@tbl@error@z\to\pgfplots@current@point@z@error
			\fi
		\fi
		\pgfplots@coord@stream@coord
	\pgfutil@repeat
	\pgfplots@coord@stream@end
	\pgfmath@smuggleone\pgfplotsscanlinelength
	\endgroup
}

% A private helper macro which initialises the '#1 expr' keys for plot
% table from structure.
%
% PRECONDITION:
% 	\pgfplots@plot@tbl@#1 contains the column name which would be used
% 	if '#1 expr' is empty.
% 
% POSTCONDITION:
% 	\pgfplots@plot@tbl@#1 will be CHANGED to use the 'expr' column (a
% 	temporary name).
% 	The old value of \pgfplots@plot@tbl@#1 is available as column
% 	alias.
% 	the high level user interface command '#3' will be set correctly.
%
% #1: the key name of the current entity, for example 'x' for
% '/pgfplots/table/x'
% #2: the low level column name representing the data which is already
% defined somehow
% #3: a high level user interface command
\def\pgfplots@addplotimpl@table@fromstructure@prepareexpr@for#1#2#3{%
	% get old column name into a register:
	\t@pgfplots@tokb=\expandafter{#2}%
	%
	% high level user interface command:
	\edef#3{\noexpand\thisrow{\the\t@pgfplots@tokb}}%
	%
	\pgfkeysgetvalue{/pgfplots/table/#1 expr}{\pgfplots@loc@TMPa}%
	\ifx\pgfplots@loc@TMPa\pgfutil@empty
	\else
		% get expression into register: 
		\t@pgfplots@toka=\expandafter{\pgfplots@loc@TMPa}%
		%
		%
		% assemble pgfkeys statement which expands the names above
		% just one time:
		\edef\pgfplots@loc@TMPa{%
			/pgfplots/table/create on use/#1expr@tempcol/.style={%
				/pgfplots/table/create col/expr={\the\t@pgfplots@toka}%
			},%
			/pgfplots/table/alias/#1/.initial={\the\t@pgfplots@tokb}%
		}%
		\expandafter\pgfkeysalso\expandafter{\pgfplots@loc@TMPa}%
		%
		% tell `plot table' which column should be used for '#1': the
		% temporary column.
		\def#2{#1expr@tempcol}%
	\fi
}%


% \addplot[#1] table[#2] {#3} #4;
%
% This here is the (probably) faster input method from tables.
%
% It has linear complexity in the number of rows (as long as the
% number of rows is less than about 110000).
%
% #1: arguments to \addplot[...]
% #2: arguments to table[...] (already processed!)
% #3: the argument of plot table{...}
% #4: trailing path arguments after plot table{...}#4;
%
\long\def\pgfplots@addplotimpl@table@fromfile@gobble@space#1#2{%
	\pgfplotstablecollectoneargwithpreparecatcodes{%
		\pgfplots@addplotimpl@table@fromfile{#1}{#2}%
	}%
}%
\long\def\pgfplots@addplotimpl@table@fromfile#1#2#3#4;{\pgfplots@addplotimpl@table@startprocessing{#1}{#2}{#3}{#4}}%
% \addplot[#1] table[#2] {#3} {#4};
\long\def\pgfplots@addplotimpl@table@fromfile@#1#2#3#4{%
	\if1\pgfplots@addplotimpl@readcompletely@auto
		\pgfplots@addplotimpl@table@check@createonuse@for{x}%
		\pgfplots@addplotimpl@table@check@createonuse@for{y}%
		\ifpgfplots@curplot@threedim
			\pgfplots@addplotimpl@table@check@createonuse@for{z}%
		\fi
		\pgfplots@addplotimpl@table@check@createonuse@for{meta}%
	\fi
	%
	\ifpgfplots@addplotimpl@readcompletely
		\pgfplotstableread{#3}\pgfplots@table
		\pgfplots@addplotimpl@table@fromstructure@{#1}{}{\pgfplots@table}{#4}%
	\else
		\pgfplotsapplistXXglobalnewempty
		%
		% these data pointers will be prepared to allow fast access
		% into the current row while we read rows succesively from
		% disk.
		% Note: their initialisation must be postponed until
		% \pgfplotstableread is running - otherwise, we can't query
		% pointers into the table. See below.
		\let\pgfplots@table@PTR@x=\pgfutil@empty
		\let\pgfplots@table@PTR@y=\pgfutil@empty
		\let\pgfplots@table@PTR@z=\pgfutil@empty
		\let\pgfplots@table@PTR@meta=\pgfutil@empty
		%
		%
		\let\pgfplots@current@point@meta=\pgfutil@empty
		\let\pgfplots@current@point@z=\pgfutil@empty
		%
		% high level user interface functions:
		\def\lineno{\pgfplotstablelineno}%
		\def\columnx{\pgfplotstablereadvalueofptr{\pgfplots@table@PTR@x}}%
		\def\columny{\pgfplotstablereadvalueofptr{\pgfplots@table@PTR@y}}%
		\def\columnz{\pgfplotstablereadvalueofptr{\pgfplots@table@PTR@z}}%
		\def\columnmeta{\pgfplotstablereadvalueofptr{\pgfplots@table@PTR@meta}}%
		%
		\pgfplots@PREPARE@COORD@STREAM{#4}%
		\pgfplots@coord@stream@start
		\ifpgfplots@errorbars@enabled
			% more fast-access pointers for error data:
			\let\pgfplots@table@ERRPTR@x=\pgfutil@empty
			\let\pgfplots@table@ERRPTR@y=\pgfutil@empty
			\let\pgfplots@table@ERRPTR@z=\pgfutil@empty
			%
			% prepare:
			\let\pgfplots@current@point@x@error=\pgfutil@empty
			\let\pgfplots@current@point@y@error=\pgfutil@empty
			\let\pgfplots@current@point@z@error=\pgfutil@empty
			%
			% high level user interface functions:
			\def\columnerrorx{\pgfplotstablereadvalueofptr{\pgfplots@table@ERRPTR@x}}%
			\def\columnerrory{\pgfplotstablereadvalueofptr{\pgfplots@table@ERRPTR@y}}%
			\def\columnerrorz{\pgfplotstablereadvalueofptr{\pgfplots@table@ERRPTR@z}}%
			%
			\pgfplotstableread*{#3} to listener\pgfplots@addplotimpl@table@fromfile@listener@witherrors@COLLECTHIGHLEVEL
		\else
			\pgfplotstableread*{#3} to listener\pgfplots@addplotimpl@table@fromfile@listener@COLLECTNORMALIZED
		\fi
		\pgfplots@coord@stream@end
	\fi
}
\def\pgfplots@addplotimpl@table@check@createonuse@for#1{%
	\pgfkeysgetvalue{/pgfplots/table/#1}\pgfplots@addplotimpl@table@check@createonuse@for@
	\expandafter\pgfplotstableifiscreateonuse\expandafter{\pgfplots@addplotimpl@table@check@createonuse@for@}{%
		\pgfplots@addplotimpl@readcompletelytrue
	}{%
	}%
}%
\def\pgfplots@addplotimpl@table@fromfile@listener@COLLECTNORMALIZED{%
	\pgfplots@addplotimpl@table@fromfile@listener@
	\pgfplots@coord@stream@coord
}
\def\pgfplots@addplotimpl@table@fromfile@listener@PREPARE{%
	% this here is only evaluated ONCE.
	\pgfkeysgetvalue{/pgfplots/table/x}{\pgfplots@plot@tbl@x}%
	\pgfkeysgetvalue{/pgfplots/table/x index}{\pgfplots@plot@tbl@xindex}%
	\pgfkeysgetvalue{/pgfplots/table/y}{\pgfplots@plot@tbl@y}%
	\pgfkeysgetvalue{/pgfplots/table/y index}{\pgfplots@plot@tbl@yindex}%
	\pgfkeysgetvalue{/pgfplots/table/z}{\pgfplots@plot@tbl@z}%
	\pgfkeysgetvalue{/pgfplots/table/z index}{\pgfplots@plot@tbl@zindex}%
	\pgfkeysgetvalue{/pgfplots/table/meta}{\pgfplots@plot@tbl@meta}%
	\pgfkeysgetvalue{/pgfplots/table/meta index}{\pgfplots@plot@tbl@metaindex}%
	%
	\pgfkeysgetvalue{/pgfplots/table/x expr}{\pgfplots@loc@TMPa}%
	\ifx\pgfplots@loc@TMPa\pgfutil@empty
		\def\pgfplots@dereferencepointer@and@ASSIGN@x{%
			\pgfplotstablereadevalptr\pgfplots@table@PTR@x\pgfplots@current@point@x
		}%
	\else
		\def\pgfplots@dereferencepointer@and@ASSIGN@x{%
			\pgfmathparse{\pgfkeysvalueof{/pgfplots/table/x expr}}%
			\let\pgfplots@current@point@x=\pgfmathresult
		}%
	\fi
	%
	\pgfkeysgetvalue{/pgfplots/table/y expr}{\pgfplots@loc@TMPa}%
	\ifx\pgfplots@loc@TMPa\pgfutil@empty
		\def\pgfplots@dereferencepointer@and@ASSIGN@y{%
			\pgfplotstablereadevalptr\pgfplots@table@PTR@y\pgfplots@current@point@y
		}%
	\else
		\def\pgfplots@dereferencepointer@and@ASSIGN@y{%
			\pgfmathparse{\pgfkeysvalueof{/pgfplots/table/y expr}}%
			\let\pgfplots@current@point@y=\pgfmathresult
		}%
	\fi
	%
	\ifx\pgfplots@plot@tbl@x\pgfutil@empty
		\pgfplotstablereadgetptrtocolindex{\pgfplots@plot@tbl@xindex}{\pgfplots@table@PTR@x}%
	\else
		\pgfplotstablereadgetptrtocolname{\pgfplots@plot@tbl@x}{\pgfplots@table@PTR@x}%
	\fi
	\ifx\pgfplots@plot@tbl@y\pgfutil@empty
		\pgfplotstablereadgetptrtocolindex{\pgfplots@plot@tbl@yindex}{\pgfplots@table@PTR@y}%
	\else
		\pgfplotstablereadgetptrtocolname{\pgfplots@plot@tbl@y}{\pgfplots@table@PTR@y}%
	\fi
	\ifpgfplots@curplot@threedim
		%
		\pgfkeysgetvalue{/pgfplots/table/z expr}{\pgfplots@loc@TMPa}%
		\ifx\pgfplots@loc@TMPa\pgfutil@empty
			\def\pgfplots@dereferencepointer@and@ASSIGN@z{%
				\pgfplotstablereadevalptr\pgfplots@table@PTR@z\pgfplots@current@point@z
			}%
		\else
			\def\pgfplots@dereferencepointer@and@ASSIGN@z{%
				\pgfmathparse{\pgfkeysvalueof{/pgfplots/table/z expr}}%
				\let\pgfplots@current@point@z=\pgfmathresult
			}%
		\fi
		\ifx\pgfplots@plot@tbl@z\pgfutil@empty
			\pgfplotstablereadgetptrtocolindex{\pgfplots@plot@tbl@zindex}{\pgfplots@table@PTR@z}%
		\else
			\pgfplotstablereadgetptrtocolname{\pgfplots@plot@tbl@z}{\pgfplots@table@PTR@z}%
		\fi
	\else
		\let\pgfplots@dereferencepointer@and@ASSIGN@z=\relax
	\fi
	%
	%
	\def\pgfplots@dereferencepointer@and@ASSIGN@meta{%
		\pgfplotstablereadevalptr\pgfplots@table@PTR@meta\pgfplots@current@point@meta
	}%
	\ifx\pgfplots@plot@tbl@meta\pgfutil@empty
		\ifx\pgfplots@plot@tbl@metaindex\pgfutil@empty
			\let\pgfplots@dereferencepointer@and@ASSIGN@meta=\relax
		\else
			\pgfplotstablereadgetptrtocolindex{\pgfplots@plot@tbl@metaindex}{\pgfplots@table@PTR@meta}%
		\fi
	\else
		\pgfplotstablereadgetptrtocolname{\pgfplots@plot@tbl@meta}{\pgfplots@table@PTR@meta}%
	\fi
	\pgfkeysgetvalue{/pgfplots/table/meta expr}{\pgfplots@loc@TMPa}%
	\ifx\pgfplots@loc@TMPa\pgfutil@empty
	\else
		\def\pgfplots@dereferencepointer@and@ASSIGN@meta{%
			\pgfmathparse{\pgfkeysvalueof{/pgfplots/table/meta expr}}%
			\let\pgfplots@current@point@meta=\pgfmathresult
		}%
	\fi
	\let\pgfplots@addplotimpl@table@fromfile@listener@PREPARE=\relax
}%
\def\pgfplots@addplotimpl@table@fromfile@listener@{%
	\pgfplots@addplotimpl@table@fromfile@listener@PREPARE
	\pgfplots@dereferencepointer@and@ASSIGN@x
	\pgfplots@dereferencepointer@and@ASSIGN@y
	\pgfplots@dereferencepointer@and@ASSIGN@z
	\pgfplots@dereferencepointer@and@ASSIGN@meta
}%
\def\pgfplots@addplotimpl@table@fromfile@listener@witherrors@COLLECTHIGHLEVEL@prepare{%
	% this here is only evaluated ONCE.
	\pgfkeysgetvalue{/pgfplots/table/x error index}\pgfplots@plot@tbl@error@xindex
	\pgfkeysgetvalue{/pgfplots/table/x error}\pgfplots@plot@tbl@error@x
	\pgfkeysgetvalue{/pgfplots/table/y error index}\pgfplots@plot@tbl@error@yindex
	\pgfkeysgetvalue{/pgfplots/table/y error}\pgfplots@plot@tbl@error@y
	\pgfkeysgetvalue{/pgfplots/table/z error index}\pgfplots@plot@tbl@error@zindex
	\pgfkeysgetvalue{/pgfplots/table/z error}\pgfplots@plot@tbl@error@z
	%
	\def\pgfplots@table@ERRPTR@x{x error}%
	\def\pgfplots@table@ERRPTR@y{y error}%
	\def\pgfplots@table@ERRPTR@z{z error}%
	%
	\def\pgfplots@dereferencepointer@and@ASSIGN@error@x{%
		\pgfplotstablereadevalptr\pgfplots@table@ERRPTR@x\pgfplots@current@point@x@error
	}%
	\def\pgfplots@dereferencepointer@and@ASSIGN@error@y{%
		\pgfplotstablereadevalptr\pgfplots@table@ERRPTR@y\pgfplots@current@point@y@error
	}%
	\def\pgfplots@dereferencepointer@and@ASSIGN@error@z{%
		\pgfplotstablereadevalptr\pgfplots@table@ERRPTR@z\pgfplots@current@point@z@error
	}%
	%
	\ifx\pgfplots@plot@tbl@error@x\pgfutil@empty
		\ifx\pgfplots@plot@tbl@error@xindex\pgfutil@empty
			\let\pgfplots@table@ERRPTR@x=\relax%
			\let\pgfplots@dereferencepointer@and@ASSIGN@error@x=\relax
		\else
			\pgfplotstablereadgetptrtocolindex{\pgfplots@plot@tbl@error@xindex}{\pgfplots@table@ERRPTR@x}%
		\fi
	\else
		\pgfplotstablereadgetptrtocolname{\pgfplots@plot@tbl@error@x}{\pgfplots@table@ERRPTR@x}%
	\fi
	%
	\pgfkeysgetvalue{/pgfplots/table/x error expr}{\pgfplots@loc@TMPa}%
	\ifx\pgfplots@loc@TMPa\pgfutil@empty
	\else
		\def\pgfplots@dereferencepointer@and@ASSIGN@error@x{%
			\pgfmathparse{\pgfkeysvalueof{/pgfplots/table/x error expr}}%
			\let\pgfplots@current@point@x@error=\pgfmathresult
		}%
	\fi
	%
	%
	\ifx\pgfplots@plot@tbl@error@y\pgfutil@empty
		\ifx\pgfplots@plot@tbl@error@yindex\pgfutil@empty
			\let\pgfplots@table@ERRPTR@y=\relax%
			\let\pgfplots@dereferencepointer@and@ASSIGN@error@y=\relax
		\else
			\pgfplotstablereadgetptrtocolindex{\pgfplots@plot@tbl@error@yindex}{\pgfplots@table@ERRPTR@y}%
		\fi
	\else
		\pgfplotstablereadgetptrtocolname{\pgfplots@plot@tbl@error@y}{\pgfplots@table@ERRPTR@y}%
	\fi
	%
	\pgfkeysgetvalue{/pgfplots/table/y error expr}{\pgfplots@loc@TMPa}%
	\ifx\pgfplots@loc@TMPa\pgfutil@empty
	\else
		\def\pgfplots@dereferencepointer@and@ASSIGN@error@y{%
			\pgfmathparse{\pgfkeysvalueof{/pgfplots/table/y error expr}}%
			\let\pgfplots@current@point@y@error=\pgfmathresult
		}%
	\fi
	%
	%
	\ifpgfplots@curplot@threedim
		\ifx\pgfplots@plot@tbl@error@z\pgfutil@empty
			\ifx\pgfplots@plot@tbl@error@zindex\pgfutil@empty
				\let\pgfplots@table@ERRPTR@z=\relax%
				\let\pgfplots@dereferencepointer@and@ASSIGN@error@z=\relax
			\else
				\pgfplotstablereadgetptrtocolindex{\pgfplots@plot@tbl@error@zindex}{\pgfplots@table@ERRPTR@z}%
			\fi
		\else
			\pgfplotstablereadgetptrtocolname{\pgfplots@plot@tbl@error@z}{\pgfplots@table@ERRPTR@z}%
		\fi
		%
		\pgfkeysgetvalue{/pgfplots/table/z error expr}{\pgfplots@loc@TMPa}%
		\ifx\pgfplots@loc@TMPa\pgfutil@empty
		\else
			\def\pgfplots@dereferencepointer@and@ASSIGN@error@z{%
				\pgfmathparse{\pgfkeysvalueof{/pgfplots/table/z error expr}}%
				\let\pgfplots@current@point@z@error=\pgfmathresult
			}%
		\fi
		%
		%
	\else
		\let\pgfplots@dereferencepointer@and@ASSIGN@error@z=\relax
	\fi
	\let\pgfplots@addplotimpl@table@fromfile@listener@witherrors@COLLECTHIGHLEVEL@prepare=\relax
}
\def\pgfplots@addplotimpl@table@fromfile@listener@witherrors@COLLECTHIGHLEVEL{%
	\pgfplots@addplotimpl@table@fromfile@listener@
	\pgfplots@addplotimpl@table@fromfile@listener@witherrors@COLLECTHIGHLEVEL@prepare
	%
	\pgfplots@dereferencepointer@and@ASSIGN@error@x
	\pgfplots@dereferencepointer@and@ASSIGN@error@y
	\ifpgfplots@curplot@threedim
		\pgfplots@dereferencepointer@and@ASSIGN@error@z
		%\edef\pgfplots@current@point{(\pgfplots@current@point@x,\pgfplots@current@point@y,\pgfplots@current@point@z)+-(\pgfplots@current@point@x@error,\pgfplots@current@point@y@error,\pgfplots@current@point@z@error) [\pgfplots@current@point@meta]}%
	%\else
		%\edef\pgfplots@current@point{(\pgfplots@current@point@x,\pgfplots@current@point@y)+-(\pgfplots@current@point@x@error,\pgfplots@current@point@y@error) [\pgfplots@current@point@meta]}%
	\fi
	\pgfplots@coord@stream@coord
	%\expandafter\pgfplotsapplistXXglobalpushback\expandafter{\pgfplots@current@point}%
}%
\def\pgfplots@addplotimpl@table@installkeypath{%
	\pgfkeysdef{/pgfplots/table/.unknown}{%
		\let\pgfplots@table@curkeyname=\pgfkeyscurrentname
		\pgfqkeys{/pgfplots}{\pgfplots@table@curkeyname=##1}%
	}%
}%

% \addplot[#1] table[#2] shell{#3} #4;
%
% #1: arguments to \addplot[...]
% #2: arguments to table[...]
% #3: the argument of plot table shell{...}
% #4: trailing path arguments after plot table shell{...}#4;
\long\def\pgfplots@addplotimpl@table@fromshell#1#2shell#3#4;{%
	\pgfplots@gettikzinternal@keyval{prefix}{tikz@plot@prefix}{\jobname.}%
	\pgfplots@gettikzinternal@keyval{id}{tikz@plot@id}{pgf-shell}%
	%
	\def\pgfplots@plot@filename{\tikz@plot@prefix\tikz@plot@id}%  
	\pgfshell[\pgfplots@plot@filename]{#3}\pgfplots@addplotimpl@table@fromfile{#1}{#2}{\pgfplots@plot@filename.out}#4;%
}%

% This is a backwards-compatibility method to ensure that
% \axis[ybar]
% and
% \addplot[ybar]
% work as documented.
%
% The problem: earlier versions used /pgfplots/ybar for the global
% setting and /tikz/ybar for the local one. Now, both contexts yield
% /pgfplots/ybar in contradiction to the manual.
%
% So, this macro install special handlers to restore the old setting.
\def\pgfplots@install@local@bar@handlers{%
	\pgfkeysgetvalue{/pgfplots/xbar/.@cmd}\pgfplotskeys@orig@xbar
	\pgfkeysgetvalue{/pgfplots/ybar/.@cmd}\pgfplotskeys@orig@ybar
	\pgfkeysgetvalue{/pgfplots/xbar interval/.@cmd}\pgfplotskeys@orig@xbari
	\pgfkeysgetvalue{/pgfplots/ybar interval/.@cmd}\pgfplotskeys@orig@ybari
	\pgfkeysdef{/pgfplots/xbar}{%
		\ifpgfkeysaddeddefaultpath
			\pgfkeysalso{/tikz/xbar}%
		\else
			\pgfplotskeys@orig@xbar##1\pgfeov
		\fi
	}%
	\pgfkeysdef{/pgfplots/ybar}{%
		\ifpgfkeysaddeddefaultpath
			\pgfkeysalso{/tikz/ybar}%
		\else
			\pgfplotskeys@orig@ybar##1\pgfeov
		\fi
	}%
	\pgfkeysdef{/pgfplots/xbar interval}{%
		\ifpgfkeysaddeddefaultpath
			\pgfkeysalso{/tikz/xbar interval}%
		\else
			\pgfplotskeys@orig@xbari##1\pgfeov
		\fi
	}%
	\pgfkeysdef{/pgfplots/ybar interval}{%
		\ifpgfkeysaddeddefaultpath
			\pgfkeysalso{/tikz/ybar interval}%
		\else
			\pgfplotskeys@orig@ybari##1\pgfeov
		\fi
	}%
}%

\def\pgfplots@end@plot{%
	\ifpgfplots@curplot@isirrelevant
	\else
		\pgfplots@countplots@advance
	\fi
	\pgfkeysvalueof{/pgfplots/execute at end plot@@}%
	\pgfkeysvalueof{/pgfplots/execute at end plot}%
	\endgroup%<-- close the \begingroup of \pgfplots@addplotimpl@plot@withoptions
}

% \numplotsofactualtype
% Expands to the number of plots which have been seen in the current
% axis and which have the same type as the actual plot handler. 
%
% See also \plotnumofactualtype
\def\pgfplots@numplotsofactualtype{%
	\pgfutil@ifundefined{pgfplotssurveyphase@setactiveplothandlers@\pgfplotsplothandlername}{%
		0%
	}{%
		\csname c@pgfplots@numplotsofactualtype@\pgfplotsplothandlername\endcsname
	}%
}%
% use this only inside of \addplot or during the visualization phase
% of a plot.
\def\pgfplots@numplotsofactualtype@duringplot{%
	\pgfutil@ifundefined{pgfplotssurveyphase@setactiveplothandlers@\pgfplotsplothandlername@actual}{%
		0%
	}{%
		\csname c@pgfplots@numplotsofactualtype@\pgfplotsplothandlername@actual\endcsname
	}%
}%
%
%
\def\pgfplots@countplots@init{%
%
	%
	\pgfplotssurveyphase@setactiveplothandlers
	%
	\let\numplotsofactualtype=\pgfplots@numplotsofactualtype@duringplot
	%
	% Store this name during the \addplot command. Thus, even if the
	% plot handler changes, we will keep this one.
	\edef\pgfplotsplothandlername@actual{\pgfplotsplothandlername}%
	%
	\pgfutil@ifundefined{pgfplotssurveyphase@setactiveplothandlers@\pgfplotsplothandlername@actual}{%
		% oh. This is the first time \pgfplotsplothandlername was used
		% in this axis. Set its counter to 0 and remember that it has
		% been initialised.
		\expandafter\xdef\csname c@pgfplots@numplotsofactualtype@\pgfplotsplothandlername@actual\endcsname{0}%
		\t@pgfplots@toka=\expandafter{\pgfplotssurveyphase@setactiveplothandlers}%
		\t@pgfplots@tokb=\expandafter{\pgfplotsplothandlername@actual}%
		\xdef\pgfplotssurveyphase@setactiveplothandlers{%
			\the\t@pgfplots@toka
			\noexpand\expandafter\noexpand\def\noexpand\csname pgfplotssurveyphase@setactiveplothandlers@\the\t@pgfplots@tokb\noexpand\endcsname{1}%
		}%
		\expandafter\def\csname pgfplotssurveyphase@setactiveplothandlers@\the\t@pgfplots@tokb\endcsname{1}%
	}{%
		% ok. do nothing.
	}%
	%
}%
\def\pgfplots@countplots@advance{%
	\global\advance\pgfplots@numplots by1\relax%
	%
	\expandafter\pgfplotsutil@advancestringcounter@global\csname c@pgfplots@numplotsofactualtype@\pgfplotsplothandlername@actual\endcsname
}%

% \addplot[#1] [#2] {#3} #4;
\long\def\pgfplots@addplotimpl@coordinates#1#2plot coordinates#3#4;{\pgfplots@addplotimpl@coordinates@{#1}{#2}{#3}{#4}}%
% \addplot[#1] [#2] coordinates {#3} #4;
\long\def\pgfplots@addplotimpl@coordinates@#1#2#3#4{%
	\def\pgfplotssurveyphaseinputclass{coordinates}%
	\pgfplots@start@plot@with@behavioroptions{#1,/pgfplots/.cd,#2}%
	\pgfplots@PREPARE@COORD@STREAM{#4}%
	\ifpgfplots@curplot@threedim
		\pgfplots@coord@stream@foreach@threedim{#3}%
	\else
		\pgfplots@coord@stream@foreach{#3}%
	\fi
}%

{
	% A block which handles active semicolons.
	%
	% ATTENTION: this block does only work if
	% \pgfplots@addplotimpl.... changes are reflected here!
	%
	\catcode`\;=\active
	\globaldefs=1
	% 'AS' == 'active semicolon'
	% 'IS' == 'inactive semicolon'
	\let\pgfplots@gobble@until@semicolon@IS=\pgfplots@gobble@until@semicolon
	\let\pgfplots@addplotimpl@expression@IS=\pgfplots@addplotimpl@expression
	\let\pgfplots@addplotimpl@expression@curly@IS=\pgfplots@addplotimpl@expression@curly
	\let\pgfplots@addplotimpl@function@opt@IS=\pgfplots@addplotimpl@function@opt
	\let\pgfplots@addplotimpl@file@opt@IS=\pgfplots@addplotimpl@file@opt
	\let\pgfplots@addplotimpl@table@fromstructure@IS=\pgfplots@addplotimpl@table@fromstructure
	\let\pgfplots@addplotimpl@table@fromfile@IS=\pgfplots@addplotimpl@table@fromfile
	\let\pgfplots@addplotimpl@graphics@IS=\pgfplots@addplotimpl@graphics@
	\let\pgfplots@addplotimpl@coordinates@IS=\pgfplots@addplotimpl@coordinates
	%
	\def\pgfplots@gobble@until@semicolon@AS#1;{}
	\long\def\pgfplots@addplotimpl@expression@AS#1#2(#3,#4)#5;{\pgfplots@addplotimpl@expression@{#1}{#2}{#3}{#4}{#5}}%
	\long\def\pgfplots@addplotimpl@expression@curly@AS#1#2#3#4;{\pgfplots@addplotimpl@expression@curly@{#1}{#2}{#3}{#4}}%
	\def\pgfplots@addplotimpl@function@opt@AS#1#2[#3]#4#5;{\pgfplots@addplotimpl@function@opt@{#1}{#2}{#3}{#4}{#5}}%
	\def\pgfplots@addplotimpl@file@opt@AS#1#2[#3]#4#5;{\pgfplots@addplotimpl@file@opt@{#1}{#2}{#3}{#4}{#5}}%
	\long\def\pgfplots@addplotimpl@table@fromstructure@AS#1#2from#3#4;{\pgfplots@addplotimpl@table@startprocessing{#1}{#2}{#3}{#4}}%
	\long\def\pgfplots@addplotimpl@table@fromfile@AS#1#2#3#4;{\pgfplots@addplotimpl@table@startprocessing{#1}{#2}{#3}{#4}}%
	\long\def\pgfplots@addplotimpl@coordinates@AS#1#2plot coordinates#3#4;{\pgfplots@addplotimpl@coordinates@{#1}{#2}{#3}{#4}}%
	\long\def\pgfplots@addplotimpl@graphics@AS#1#2[#3]#4#5;{\pgfplots@addplotimpl@graphics@@{#1}{#2}{#3}{#4}{#5}}%
	%
	% Checks whether ';' is an active character and, if that is the
	% case, modifies all public macros for it.
	\pgfplots@appendto@activesemicolon@switcher{%
		\let\pgfplots@gobble@until@semicolon=\pgfplots@gobble@until@semicolon@AS
		\let\pgfplots@addplotimpl@expression=\pgfplots@addplotimpl@expression@AS
		\let\pgfplots@addplotimpl@expression@curly=\pgfplots@addplotimpl@expression@curly@AS
		\let\pgfplots@addplotimpl@function@opt=\pgfplots@addplotimpl@function@opt@AS
		\let\pgfplots@addplotimpl@file@opt=\pgfplots@addplotimpl@file@opt@AS
		\let\pgfplots@addplotimpl@table@fromstructure=\pgfplots@addplotimpl@table@fromstructure@AS
		\let\pgfplots@addplotimpl@table@fromfile=\pgfplots@addplotimpl@table@fromfile@AS
		\let\pgfplots@addplotimpl@coordinates=\pgfplots@addplotimpl@coordinates@AS
		\let\pgfplots@addplotimpl@graphics@=\pgfplots@addplotimpl@graphics@AS
	}%
}

\newif\ifpgfplots@update@limits@for@one@point@ISCLIPPED
\def\pgfplots@math@ONE{1.0}%

\def\pgfplots@streamerrorbarstart{%
}%
\def\pgfplots@streamerrorbarend{%
}%
\def\pgfplots@streamerrorbarcoords#1#2{%
}%

\def\pgfplots@streamerrorbar@recordto#1{%
	\def\pgfplots@streamerrorbarstart{%
		\pgfplotsapplistXnewempty\pgfplots@streamerrorbar@recordto@@
	}%
	\def\pgfplots@streamerrorbarend{%
		\pgfplotsapplistXlet#1=\pgfplots@streamerrorbar@recordto@@
		\pgfplotsapplistXnewempty\pgfplots@streamerrorbar@recordto@@% clear
	}%
	\def\pgfplots@streamerrorbarcoords##1##2{%
		\pgfplotsapplistXpushback{\pgfplots@errorbar@draw{##1}{##2}}\to\pgfplots@streamerrorbar@recordto@@
	}%
}
\def\pgfplots@streamerrorbar@directdraw{%
	\def\pgfplots@streamerrorbarstart{}%
	\def\pgfplots@streamerrorbarend{}%
	\def\pgfplots@streamerrorbarcoords##1##2{%
		\pgfplots@errorbar@draw{##1}{##2}%
	}%
}
	
\def\pgfplots@invoke@prefilter{%
	\pgfkeysvalueof{/pgfplots/pre filter/.@cmd}\pgfeov%
}%
\def\pgfplots@invoke@filter#1#2{%
	\pgfkeysvalueof{/pgfplots/#2 filter/.@cmd}#1\pgfeov%
}%
\def\pgfplots@invoke@filter@xyz{%
	\pgfkeysgetvalue{/pgfplots/filter point/.@cmd}\pgfplots@loc@TMPa
	\ifx\pgfplots@loc@TMPa\pgfplots@empty@command@key
	\else
		\pgfkeyslet{/data point/x}\pgfplots@current@point@x
		\pgfkeyslet{/data point/y}\pgfplots@current@point@y
		\pgfkeyslet{/data point/z}\pgfplots@current@point@z
		\pgfplots@loc@TMPa\pgfeov%
		\pgfkeysgetvalue{/data point/x}\pgfplots@current@point@x
		\pgfkeysgetvalue{/data point/y}\pgfplots@current@point@y
		\pgfkeysgetvalue{/data point/z}\pgfplots@current@point@z
	\fi%
}%

% this is a convenience macro to save storage in the long coordinate
% lists.
\def\pgfplots@stream#1#2{\pgfplotstreampoint{\pgfqpoint{#1}{#2}}}
\def\pgfplots@stream@#1#2#3{\def\pgfplots@current@point@coordindex{#1}\pgfplots@stream{#2}{#3}}
\def\pgfplots@stream@withmeta#1#2#3{\def\pgfplots@current@point@meta{#3}\pgfplotstreampoint{\pgfqpoint{#1}{#2}}}
\def\pgfplots@stream@withmeta@#1#2#3#4{\def\pgfplots@current@point@coordindex{#1}\pgfplots@stream@withmeta{#2}{#3}{#4}}

\def\pgfplots@stream@decode@and@apply#1#2#3#4{%
	\def\pgfplots@current@point@coordindex{#1}%
	\pgfplotsaxisdeserializedatapointfrom@private{#2}%
	\pgfplotstreampoint{\pgfqpoint{#3}{#4}}%
}

\newif\ifpgfplots@record@marker@stream
% Takes a sequence of PREPARED coordinates which are given in floating
% point representation and applies the data scaling trafo (if
% necessary).
%
% Any coordinate will be plotted with the selected PGF plot handler.
%
% This stream is designed to be done at the end of an axis.
% See \pgfplots@coord@stream@finalize@storedcoords@START
%
% #1 : a macro which will be filled with a pgf plot stream for the
% marker points.
\def\pgfplots@coord@stream@INIT@finalize@storedcoords#1{%
	%
	% Init the plot handlers:
	\pgfplots@getcurrent@plothandler\pgfplots@basiclevel@plothandler
	\pgfplots@gettikzinternal@keyval{mark}{tikz@plot@mark}{}%
	%
	%
	\ifpgfplots@clip@limits
	\else
		% "clip marker paths=true" actually doesn't checks anything --
		% it leaves the checks to the clip path. But since there is no
		% clip path, it is adequate to use it here:
		\pgfplots@clip@marker@pathstrue
	\fi
	%
	\pgfplots@perpointmeta@preparetrafo
	%
	\pgfplots@prepare@visualization@dependencies
	%
	\def\pgfplots@loc@TMPa{0}% <-- if (collectmark positions)
	\ifpgfplots@scatterplotenabled
		\def\pgfplots@loc@TMPa{1}% collect mark positions even if 'mark=none'! scatter might not even use markers.
	\fi
	\ifx\tikz@plot@mark\pgfutil@empty
	\else
		\def\pgfplots@loc@TMPa{1}%
	\fi
	\if\pgfplots@loc@TMPa0%
		% mark=none : no need to waste time collecting marker
		% positions.
		\pgfplots@record@marker@streamfalse
	\else
		% we need markers.
		\ifx\pgfplots@basiclevel@plothandler\pgfplothandlerdiscard
			\ifpgfplots@clip@marker@paths
				% only marks: draw markers directly; no need for the
				% two-pass-approach.
				\let\pgfplots@basiclevel@plothandler=\relax
				\pgfplots@install@plotmark@handler
				\pgfplots@record@marker@streamfalse
			\else
				% collect mark positions... they will be drawn after
				% the clipped axis range. Clipping will only be
				% applied to their *positions*, not their paths.
				\pgfplots@record@marker@streamtrue
			\fi
		\else
			% ok, mark!=none and we also have a plot handler.
			% So, collect mark positions!
			\pgfplots@record@marker@streamtrue
		\fi
	\fi
	\gdef#1{}%
	%
	% Now, set up coordinate streams.
	\def\pgfplots@coord@stream@start@{%
		\ifpgfplots@apply@datatrafo
			\ifpgfplots@stackedmode
				\pgfplots@stacked@beginplot
			\fi
		\fi
		\pgfplotsresetplothandler
		\pgfplots@basiclevel@plothandler
		\expandafter\pgfplotsplothandlerdeserializestatefrom\expandafter{\pgfplots@serialized@state@plothandler}%
		\pgfplotstreamstart
		\let\pgfplots@data@scaletrafo@result=\pgfutil@empty
		\ifpgfplots@record@marker@stream
			\pgfplotsapplistXXnewempty
			\pgfplotsapplistXXpushback{\pgfplotstreamstart}%
			%\gdef#1{\pgfplotstreamstart}%
		\fi
		\c@pgfplots@coordindex=0
	}%
	\def\pgfplots@coord@stream@end@{%
		\ifpgfplots@apply@datatrafo
			\ifpgfplots@stackedmode
				\pgfplots@stacked@endplot
			\fi
			\pgfplots@addplot@get@named@startendpoints@command\pgfplots@loc@TMPa
			\pgfplots@loc@TMPa
		\fi
		\pgfplotstreamend
		\ifpgfplots@record@marker@stream
			\pgfplotsapplistXXpushback{\pgfplotstreamend}%
			\pgfplotsapplistXXflushbuffers%
			\global\let#1=\pgfplotsapplistXX
			\pgfplotsapplistXXclear
			%\expandafter\gdef\expandafter#1\expandafter{#1\pgfplotstreamend}%
		\fi
	}%
	\def\pgfplots@visualize@performserialization{%
		% ATTENTION: a similar thing is REPLICATED for stacked plots!
		\t@pgfplots@tokb=\expandafter{\pgfplotsaxisdeserializedatapointfrom@private@lastvalue}%
		\edef\pgfplots@loc@TMPa{%
			\noexpand\pgfplots@stream@decode@and@apply
				{\the\c@pgfplots@coordindex}
				{\the\t@pgfplots@tokb}%
				{\the\pgf@x}{\the\pgf@y}
		}%
		\expandafter\pgfplotsapplistXXpushback\expandafter{\pgfplots@loc@TMPa}%
	}%
	\begingroup
	\let\E=\noexpand
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\pgfplots@coord@stream@INIT@finalize@storedcoords@prepare@scaletrafomacro
	%
	% Will be inserted in one of two possible places below (to collect
	% marker positions)
	% This finalize command maps the logical coordinate into PGF's
	% point space. Furthermore, it collects marker coordinates
	% (properly clipped by position) if markers are required (see
	% above).
	%
	% It is prepared here to eliminate if's.
	\xdef\pgfplots@coord@stream@finalize@currentpt{%
		%
		\ifpgfplots@record@marker@stream
			% remember the position (x,y) for markers.
			% remember it before \pgfplotstreampoint (which might change (x,y) )
			\ifpgfplots@clip
				% check for clip marker paths:
				\E\pgfplotsaxisifcontainspoint{\E\pgfplots@visualize@performserialization}{}%
			\else
				\E\pgfplots@visualize@performserialization
			\fi
		\fi
		%
		\E\pgfplotstreampoint{}% it will simply take \pgf@x and \pgf@y!
		%
		\advance\c@pgfplots@coordindex by1
	}%
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\endgroup
%
%\message{Prepared macro	\string \pgfplotsaxisvisphasetransformcoordinate {\meaning\pgfplotsaxisvisphasetransformcoordinate}}%
%\message{Prepared macro	\string \pgfplots@coord@stream@finalize@currentpt {\meaning\pgfplots@coord@stream@finalize@currentpt}}%
	\def\pgfplots@coord@stream@coord@{%
		\ifx\pgfplots@current@point@x\pgfutil@empty% this realizes `unbounded coords=jump', for example
			\pgfplotsplothandlervisualizejump
		\else
			\pgfplotsaxisvisphasegetpoint
			\pgfplots@coord@stream@finalize@currentpt
		\fi
	}%
}

% Takes the current point (defined by a set of macros) as input and defines \pgf@x and \pgf@y 
% as the output point.
\def\pgfplotsaxisvisphasegetpoint{%
	\pgfplotsaxisvisphasetransformcoordinate\pgfplots@current@point@x\pgfplots@current@point@y\pgfplots@current@point@z%
	\pgfplotsaxisvisphasepreparedatapoint
	\ifpgfplots@curplot@threedim
		\pgfplotsqpointxyz{\pgfplots@current@point@x}{\pgfplots@current@point@y}{\pgfplots@current@point@z}%
	\else
		\pgfplotsqpointxy{\pgfplots@current@point@x}{\pgfplots@current@point@y}%
	\fi
}%

\def\pgfplots@check@for@default@plot@mark{%
	% make sure there is a mark set!
	\pgfplots@gettikzinternal@keyval{mark}{tikz@plot@mark}{}%
	\def\pgfplots@loc@TMPa{none}%
	\ifx\tikz@plot@mark\pgfplots@loc@TMPa
		% this here happens only in older versions of pgf.
		\let\tikz@plot@mark\pgfutil@empty
	\fi
	\ifx\tikz@plot@mark\pgfutil@empty
		\pgfplots@getcurrent@plothandler\pgfplots@basiclevel@plothandler
		\ifx\pgfplots@basiclevel@plothandler\pgfplothandlerdiscard
			% oh, the "only marks" plot handler-- and no plot mark!?
			% what's that!?
			\ifpgfplots@scatterplotenabled
				% scatter handles this in /pgfplots/scatter/true
				% automatically.
			\else
				% that appears to be nonsense...
				\def\tikz@plot@mark{*}%
			\fi
		\fi
	\fi
}%


% Defines an optimized and matching \pgfplotsaxisvisphasetransformcoordinate 
% during the coordinate finalization step in \end{axis}.
\def\pgfplots@coord@stream@INIT@finalize@storedcoords@prepare@scaletrafomacro{%
	\begingroup
	\let\E=\noexpand
	%
	% \pgfplotsaxisvisphasetransformcoordinate
	% Maps a point to the low level xyz coordinate system by applying
	% data scaling transformations.
	%
	% This method should be invoked for every coordinate before it can
	% be drawn.
	%
	% It is prepared here to eliminate if's.
	%
	% Arguments:
	% #1 : a MACRO containing the x value
	% #2 : a MACRO containing the y value
	% #3 : a MACRO containing the z value
	%
	% PRECONDITION:
	% 	- the visualization phase is running.
	% 	- #1,#2,#3 are defined and contain
	% 	values resulting from the survey phase.
	%
	% POSTCONDITION
	% 	- #1,#2,#3 will be redefined to contain data which is
	% 	readily usable by low level pgf plot handlers for
	% 	visualization.
	%
	% @see \pgfplotsaxisvisphasepreparedatapoint
	\xdef\pgfplotsaxisvisphasetransformcoordinate##1##2##3{%
		\ifpgfplots@apply@datatrafo@x
			\E\pgfplotscoordmath{x}{datascaletrafo}{##1}%
			\E\let##1=\E\pgfmathresult
		\fi
		\ifpgfplots@apply@datatrafo@y
			\E\pgfplotscoordmath{y}{datascaletrafo}{##2}%
			\E\let##2=\E\pgfmathresult
		\fi
		\ifpgfplots@curplot@threedim
			\ifpgfplots@apply@datatrafo@z
				\E\pgfplotscoordmath{z}{datascaletrafo}{##3}%
				\E\let##3=\E\pgfmathresult
			\fi
		\fi
	%	\t@pgfplots@tokc=\expandafter{\pgfplots@data@scaletrafo@result}%
	%	\edef\pgfplots@data@scaletrafo@result{\the\t@pgfplots@tokc(\pgfplots@current@point@x,\pgfplots@current@point@y)}%
	}%
	%
	% Just before the visualization phase can call the low level
	% interface, this method is called to handle final changes.
	% It is currently only used by the stacked plot interface.
	\xdef\pgfplotsaxisvisphasepreparedatapoint{%
		\ifpgfplots@stackedmode
			% all these calls work with pgfmath; no more floating point
			% arithmetics are applied.
			\E\pgfplots@stacked@getnextzerolevelpoint
			\E\pgfplots@stacked@finishpoint%
			\E\pgfplots@stacked@rememberzerolevelpoint@for@next@plot{(\E\pgfplots@current@point@x,\E\pgfplots@current@point@y\ifpgfplots@threedim,\E\pgfplots@current@point@z\fi)}%
		\fi
	}%
	%
	\endgroup
}

\def\pgfplots@addplot@get@named@startendpoints@command#1{%
	\ifx\pgfplots@currentplot@firstcoord@x\pgfutil@empty
		% empty plot.
		\def#1{%
			\pgfcoordinate{current plot begin}{\pgfplotspointaxisorigin}%
			\pgfcoordinate{current plot end}{\pgfplotspointaxisorigin}%
		}%
	\else
		\ifpgfplots@curplot@threedim
			\edef#1{%
				\noexpand\pgfcoordinate{current plot begin}{\noexpand\pgfplotsqpointxyz{\pgfplots@currentplot@firstcoord@x}{\pgfplots@currentplot@firstcoord@y}{\pgfplots@currentplot@firstcoord@z}}%
				\noexpand\pgfcoordinate{current plot end}{\noexpand\pgfplotsqpointxyz{\pgfplots@currentplot@lastcoord@x}{\pgfplots@currentplot@lastcoord@y}{\pgfplots@currentplot@lastcoord@z}}%
			}%
		\else
			\edef#1{%
				\noexpand\pgfcoordinate{current plot begin}{\noexpand\pgfplotsqpointxy{\pgfplots@currentplot@firstcoord@x}{\pgfplots@currentplot@firstcoord@y}}%
				\noexpand\pgfcoordinate{current plot end}{\noexpand\pgfplotsqpointxy{\pgfplots@currentplot@lastcoord@x}{\pgfplots@currentplot@lastcoord@y}}%
			}%
		\fi
	\fi
}%

% This is the pgfplots implementation for 'node[pos=<fraction>]'.
% Besides modifications of the transformation matrix, it also defines the COORDINATES of the point to
% /data point/x
% /data point/y
% /data point/z
% (or more keys which depend on the plot handler).
\def\pgfplots@plot@timer{%
	\pgfplotstransformplotattime{\tikz@time}%
}

% Installs a transformation matrix such that (0,0) is the point of the
% current plot with fraction #1.
%
% This does actually nothing more than using
% \pgfplotspointplotattime{#1} as shift and using the slope of the
% curve at that point to set up the 'sloped' rotation (if enabled).
\def\pgfplotstransformplotattime#1{%
  \pgftransformshift{\pgfplotspointplotattime{#1}}%
  \ifpgfresetnontranslationattime%
    \pgftransformresetnontranslations%
  \fi%
  \ifpgfslopedattime%
	\pgfplotsplothandlertransformslopedattime{#1}{\pgfplotspointplotattimefirst}{\pgfplotspointplotattimesecond}%
  \fi%
}

\def\pgfplotspointplotattimeclearcache{%
	\global\let\pgfplotspointplotattime@cache=\pgfutil@empty
	\gdef\pgfplotspointplotattime@cachesize{0}%
}%
\pgfplotspointplotattimeclearcache
\def\pgfplotspointplotattime@cachesize@max{20}

% Checks if the cache for \pgfplotspointplotattime has a cached entry for '#1'.
% POSTCONDITION:
%   if \ifpgfplots@loc@tmp is true, the value(s) from the cache have been retrieved successfully.
%   if \ifpgfplots@loc@tmp is false, there is not hit.
\def\pgfplotspointplotattimegetfromcache#1{%
	\pgf@xa=#1pt %
	\pgfplotspointplotattime@cache
	\pgfkeysifdefined{/data point/@pos \the\pgf@xa/segment \pgfkeysvalueof{/tikz/pos segment}}{%
		\pgfkeysvalueof{/data point/@pos \the\pgf@xa/segment \pgfkeysvalueof{/tikz/pos segment}}%
		\pgfplots@loc@tmptrue
	}{%
		\pgfplots@loc@tmpfalse
	}%
}%
\def\pgfplotspointplotattimeaddtocache#1{%
	\pgfplotsutil@advancestringcounter@global\pgfplotspointplotattime@cachesize
	\ifnum\pgfplotspointplotattime@cachesize=\pgfplotspointplotattime@cachesize@max
		\pgfplotspointplotattimeclearcache
	\fi
	\pgf@xa=#1pt %
	\edef\pgfplots@loc@TMPa{%
		\noexpand\gdef\noexpand\pgfplotspointplotattimefirst{\pgfplotspointplotattimefirst}%
		\noexpand\gdef\noexpand\pgfplotspointplotattimesecond{\pgfplotspointplotattimesecond}%
		\noexpand\gdef\noexpand\pgfplotspointplotattimecoords{\pgfplotspointplotattimecoords}%
	}%
	\t@pgfplots@toka=\expandafter{\pgfplotspointplotattime@cache}%
	\t@pgfplots@tokb=\expandafter{\pgfplots@loc@TMPa}%
	\xdef\pgfplotspointplotattime@cache{%
		\the\t@pgfplots@toka
		\noexpand\pgfkeyssetvalue{/data point/@pos \the\pgf@xa/segment \pgfkeysvalueof{/tikz/pos segment}}{\the\t@pgfplots@tokb}%
	}%
}

% Sets (\pgf@x,\pgf@y) to the point of the current plot with fraction #1.
% For #1 = 0, this is the first point.
% For #1 = 1, this is the last point.
% For #1 = 0.5, it is the middle of the plot.
% The argument '#1' is optional: if you leave it away, the current value of the 'pos' key will be used.
% This method will work for most plot handlers, although some of them might be unsupported.
%
% As a side-effect, it defines the (global) macros 
% - \pgfplotspointplotattimefirst  the start coordinate of the line segment containing #1
% - \pgfplotspointplotattimesecond the end   coordinate of the line segment containing #1
% - \pgfplotspointplotattimecoords the coordinates of #1
% The first two are interesting in order to allow the computation of gradients. 
%	\pgfplotsplothandlerpointtokeys{/data point}%
% for the \pgfplotspointplotattimecoords point
% 
% Any of these macros can be decoded using
% \pgfplotsplothandlerdeserializepointfrom\pgfplotspointplotattimesecond
% \pgfplotsaxisvisphasegetpoint
%
% @see \pgfplotsplothandlerpointtokeys
\def\pgfplotspointplotattime{%
	\pgfutil@ifnextchar\bgroup{\pgfplotspointplotattime@}{\pgfplotspointplotattime@{\tikz@time}}%
}
\def\pgfplotspointplotattime@#1{%
	\edef\pgfplots@loc@TMPa{#1}%
	\ifx\pgfplots@loc@TMPa\pgfutil@empty
		\pgfplots@error{Sorry, the provided fraction of the plot is empty (maybe the argument of 'pos' has been cleared by the tikz node processing). Please provide a valid 'pos' argument}%
	\else
	\pgfplotspointplotattimegetfromcache{#1}%
	\ifpgfplots@loc@tmp
		% CACHE HIT! 
%\message{CACHE HIT for \string\pgfplotspointplotattime{#1}^^J}%
	\else
%\message{NO cache hit for \string\pgfplotspointplotattime{#1}^^J}%
		\begingroup
		%
		\pgfkeysgetvalue{/tikz/pos segment}\pgfplots@pos@segment
		%
		% 1. compute the total length of the plot (by integrating along a linear spline)
		%
		\def\pgfplots@coord@stream@start@{%
			\ifx\pgfplots@pos@segment\pgfutil@empty
				\let\c@pgfplots@segments=\pgfutil@empty
			\else
				\def\c@pgfplots@segments{0}%
				\c@pgf@countd=\pgfplots@pos@segment\relax
				\edef\pgfplots@pos@segment{\the\c@pgf@countd}%
			\fi
			\pgfplotscoordmath{default}{zero}%
			\let\pgfplots@len@total=\pgfmathresult
			\let\pgfplots@last@processed=\pgfutil@empty
			\def\pgfplots@last@was@empty{1}%
		}%
		\def\pgfplotspointattime@do{}%
		\def\pgfplots@coord@stream@coord@{%
%\message{plot at time (#1, segment \pgfplots@pos@segment): processing (\pgfplots@current@point@x,\pgfplots@current@point@y,\pgfplots@current@point@z)^^J}%
			\ifx\pgfplots@current@point@x\pgfutil@empty
				\if1\pgfplots@last@was@empty
				\else
					% oh. a jump... start new length segment
					\ifx\c@pgfplots@segments\pgfutil@empty
					\else
						\ifx\pgfplots@pos@segment\c@pgfplots@segments
							\let\pgfplots@coord@stream@coord@=\relax
						\fi
						\pgfplotsutil@advancestringcounter\c@pgfplots@segments
					\fi
				\fi
				\let\pgfplots@last@processed=\pgfutil@empty
				\def\pgfplots@last@was@empty{1}%
			\else
				\ifx\pgfplots@pos@segment\c@pgfplots@segments
					\ifx\pgfplots@last@processed\pgfutil@empty
					\else
						\pgfplotsplothandlerserializepointto{\pgfplots@cur}%
						\pgfplotsplothandlersurveydifflen{\pgfplots@last@processed}{\pgfplots@cur}%
						\pgfplotscoordmath{default}{op}{add}{{\pgfmathresult}{\pgfplots@len@total}}%
						\let\pgfplots@len@total=\pgfmathresult
%\message{plot at time (#1, segment \pgfplots@pos@segment): length \pgfplots@len@total^^J}%
						\pgfplotspointattime@do
					\fi
					%
					\pgfplotsplothandlerserializepointto{\pgfplots@last@processed}%
				\fi
				\def\pgfplots@last@was@empty{0}%
			\fi
		}%
		\def\pgfplots@coord@stream@end@{}%
		\let\pgfplots@coord@stream@coord@orig=\pgfplots@coord@stream@coord@
		\expandafter\pgfplots@coord@stream@foreach@NORMALIZED\expandafter{\pgfplots@plot@timer@args}%
		%
		% Now, we have the total length. Now, try to find time #1!
		\edef\pgfplots@time{#1}%
		\pgfplotscoordmathparsemacro{default}{\pgfplots@time}%
		%
		\pgfplotscoordmath{default}{op}{multiply}{{\pgfplots@time}{\pgfplots@len@total}}%
		\let\pgfplots@len@thresh=\pgfmathresult
		%
		\pgfplotscoordmath{default}{zero}%
		\let\pgfplots@len@last=\pgfmathresult
		\let\pgfplots@len@last@last=\pgfplots@len@last
%\message{plot at time (#1, segment \pgfplots@pos@segment): total length=\pgfplots@len@total; target len \pgfplots@len@thresh\space (#1)^^J}%
		%
		\def\pgfplots@HIT{0}%
		\let\pgfplots@last@last=\pgfutil@empty
		\let\pgfplots@coord@stream@coord@=\pgfplots@coord@stream@coord@orig
		\def\pgfplotspointattime@do{%
			\pgfplotscoordmath{default}{if less than}
				{\pgfplots@len@thresh}
				{\pgfplots@len@total}
				{% HIT!
					\def\pgfplots@HIT{1}%
					\pgfplotspointattime@pointbetween@two
					\let\pgfplots@coord@stream@coord@=\relax
				}{%
				}%
			\let\pgfplots@len@last@last=\pgfplots@len@last
			\let\pgfplots@len@last=\pgfplots@len@total
			\let\pgfplots@last@last=\pgfplots@last@processed
			\pgfplotsplothandlerserializepointto{\pgfplots@cur}%
		}%
		\expandafter\pgfplots@coord@stream@foreach@NORMALIZED\expandafter{\pgfplots@plot@timer@args}%
		\if\pgfplots@HIT0%
			\let\pgfplots@last@processed=\pgfplots@last@last
			\let\pgfplots@len@last=\pgfplots@len@last@last
			\pgfplotspointattime@pointbetween@two
		\fi
		\endgroup
		\pgfplotspointplotattimeaddtocache{#1}%
	\fi
	\pgfplotsplothandlerdeserializepointfrom\pgfplotspointplotattimecoords
	\pgfplotscoordmath{x}{tofixed}{\pgfplots@current@point@x}%
	\pgfplots@coord@inv@trafo@apply{x}{\pgfmathresult}%
	\let\pgfplots@current@point@x=\pgfmathresult
	\pgfplotscoordmath{y}{tofixed}{\pgfplots@current@point@y}%
	\pgfplots@coord@inv@trafo@apply{y}{\pgfmathresult}%
	\let\pgfplots@current@point@y=\pgfmathresult
	\ifpgfplots@curplot@threedim
		\pgfplotscoordmath{z}{tofixed}{\pgfplots@current@point@z}%
		\pgfplots@coord@inv@trafo@apply{z}{\pgfmathresult}%
		\let\pgfplots@current@point@z=\pgfmathresult
	\fi
	\pgfplotsplothandlerpointtokeys{/data point}%
	\fi
}
\def\pgfplotspointattime@pointbetween@two{%
	\pgfplotscoordmath{default}{op}{subtract}{{\pgfplots@len@thresh}{\pgfplots@len@last}}%
	\let\pgfplots@tmp=\pgfmathresult
	\pgfplotscoordmath{default}{op}{subtract}{{\pgfplots@len@total}{\pgfplots@len@last}}%
	\pgfplotscoordmath{default}{op}{divide}{{\pgfplots@tmp}{\pgfmathresult}}%
	\pgfplotscoordmath{default}{tofixed}{\pgfmathresult}%
	\let\pgfplots@time@between@two=\pgfmathresult
%\message{HIT between \pgfplots@len@last\space and \pgfplots@len@total\space (\pgfplots@time@between@two)^^J}%
	\ifx\pgfplots@last@processed\pgfutil@empty
		\pgfplotsplothandlerserializepointto{\pgfplots@cur}%
	\else
		\pgfplotsplothandlersurveypointattime{\pgfplots@time@between@two}{\pgfplots@last@processed}{\pgfplots@cur}%
	\fi
	\pgfplotsplothandlerserializepointto\pgfplots@loc@TMPa
	\global\let\pgfplotspointplotattimecoords=\pgfplots@loc@TMPa
	\pgfplotsaxisvisphasegetpoint
	\global\let\pgfplotspointplotattimefirst=\pgfplots@last@processed
	\global\let\pgfplotspointplotattimesecond=\pgfplots@cur
}%


% #1 : either x,y, or z
% #2 : the argument on which the inv trafo shall be applied. It has to
% be a fixed point number.
\def\pgfplots@coord@inv@trafo@apply#1#2{%
	\edef\pgfmathresult{#2}%
	\pgfkeysgetvalue{/pgfplots/#1 coord inv trafo/.@cmd}\pgfplots@loc@TMPa
	\ifx\pgfplots@loc@TMPa\pgfplots@empty@command@key
	\else
		\expandafter\pgfplots@loc@TMPa\expandafter{\pgfmathresult}\pgfeov
	\fi
}%

% INPUT: 
% 	either floating point or fixed point coordinates (depending on the
% 	state of the \ifpgfplots@apply@datatrafo boolean)
%
\long\def\pgfplots@coord@stream@finalize@storedcoords@START normalized coordinates #1#2;\pgfplots@EOI{%
	\ifpgfplots@threedim
		\pgfplots@apply@zbuffer{#1}%
		\let\pgfplots@coord@stream@finalize@storedcoords@START@coords=\pgfplotsglobalretval
		\global\let\pgfplotsglobalretval=\relax
	\else
		\def\pgfplots@coord@stream@finalize@storedcoords@START@coords{#1}%
	\fi
	\pgfplots@assert@tikzinternal@exists{tikz@make@last@position}%
	\pgfplots@stored@current@cmd%[current plot style] <--- options are already set
	\pgfextra
	\tikzset{every plot/.try}%
	\pgfplots@coord@stream@INIT@finalize@storedcoords\pgfplots@recorded@marker@stream%
	\expandafter\pgfplots@coord@stream@foreach@NORMALIZED\expandafter{\pgfplots@coord@stream@finalize@storedcoords@START@coords}%
	\pgfutil@ifundefined{pgfplotlastpoint}{}{%
		\tikz@make@last@position{\pgfplotlastpoint}%  
	}%
	\let\pgfplots@plot@timer@args=\pgfplots@coord@stream@finalize@storedcoords@START@coords
	\pgfplotspointplotattimeclearcache
	\let\tikz@timer=\pgfplots@plot@timer%
	\endpgfextra
	#2;
	%
	\pgfplotspointplotattimeclearcache
	%
	\ifx\pgfplots@recorded@marker@stream\pgfutil@empty
	\else
		\ifpgfplots@clip@marker@paths
			% Draw markers on top of the plot lines:
			%
			\pgfplots@stored@current@cmd%[current plot style] <--- options are already set
			\pgfextra 
				\pgfplots@install@plotmark@handler
				\pgfplots@recorded@marker@stream 
			\endpgfextra
			;
		\else
			% sigh... ok, store the marker list (once more again).
			% They need to be drawn after the clipped area.
			\pgfplots@stored@REMEMBER@MARK@COMMAND
		\fi
	\fi
	\gdef\pgfplots@recorded@marker@stream{}% clear
}%

% This method MUST be called while \pgfplots@stored@plotlist is
% evaluated, that means
% - \pgfplots@stored@* commands need to be valid,
% - the precommand has already been invoked.
% - pgfplots@recorded@marker@stream exists
% - current plot style is valid
\def\pgfplots@stored@REMEMBER@MARK@COMMAND{%
	\pgfkeysgetvalue{/tikz/current plot style/.@cmd}{\pgfplots@loc@TMPa}%
	\t@pgfplots@toka=\expandafter{\pgfplots@loc@TMPa\pgfeov}%
	\t@pgfplots@tokb=\expandafter{\pgfplots@stored@current@cmd[current plot style]}%
	\t@pgfplots@tokc=\expandafter{\pgfplots@recorded@marker@stream}%
	\edef\pgfplots@loc@TMPa{%
		\noexpand\pgfkeysvalueof{/pgfplots/execute at begin plot visualization}%
		\noexpand\def\noexpand\tikz@plot@mark{\tikz@plot@mark}% make sure we restore the environment setting
		\noexpand\pgfkeysdef{/tikz/current plot style}{\the\t@pgfplots@toka}%
		% de-activate the FPU here if it was active! I fear its number
		% format may cause errors when used in low-level
		% routines.
		\noexpand\pgfkeys{/pgf/fpu=false}%
		%
		\noexpand\xdef\noexpand\pgfplots@metamin{\pgfplots@metamin}%
		\noexpand\xdef\noexpand\pgfplots@metamax{\pgfplots@metamax}%
		\noexpand\def\noexpand\pgfplotspointmetainputhandler{\pgfplotspointmetainputhandler}%
		%
		\the\t@pgfplots@tokb
		\noexpand\pgfextra
		\noexpand\pgfplots@install@plotmark@handler
		\the\t@pgfplots@tokc
		\noexpand\endpgfextra
		;%
		\noexpand\pgfkeysvalueof{/pgfplots/execute at end plot visualization}%
	}%
	\t@pgfplots@toka=\expandafter{\pgfplots@loc@TMPa}%
	\t@pgfplots@tokb=\expandafter{\pgfplots@stored@current@precmd}%
	\edef\pgfplots@loc@TMPa{\the\t@pgfplots@tokb\the\t@pgfplots@toka}%
	\expandafter\pgfplotslistpushbackglobal\expandafter{\pgfplots@loc@TMPa}\to\pgfplots@stored@markerlist
}%

\def\pgfplots@install@plotmark@handler{%
	% note: I can't check on tikz@transform because it can be '\relax'.
	\pgfplots@gettikzinternal@keyval{mark indices}{tikz@mark@list}{}%
	\pgfplots@gettikzinternal@keyval{mark}{tikz@plot@mark}{}%
	%
	%
	% do not reset \tikz@options: draw color may be acquired
	% from 'current plot style'
	%\let\tikz@options=\pgfutil@empty%
	\let\tikz@transform=\pgfutil@empty%
	\tikzset{every plot/.try,every mark}%
	%
	% This sets colors:
	\tikz@options
	%
	% This sets the \iftikz@mode@draw etc:
	%\tikz@mode
	% FIXME: using 'color=blue' will NOT activate filltrue!
	% So: if 'tikz@mode' *contains* 'fillfalse', I know what to do... 
	% but all other cases are not clear
	%--------------------------------------------------
	% \iftikz@mode@draw
	% \else
	% 	% Override the marker codes: force 'draw=none'
	% 	% even if the markers likes to be stroked:
	% 	\let\pgfusepathqfillstroke=\pgfusepathqfill
	% \fi
	% \iftikz@mode@fill
	% \else
	% 	% Override the marker codes: force 'fill=none'
	% 	% even if the markers likes to be filled:
	% 	\let\pgfusepathqfillstroke=\pgfusepathqstroke
	% \fi
	%-------------------------------------------------- 
	\pgfplots@perpointmeta@preparetrafo
	%
	\pgfplots@prepare@visualization@dependencies
	%
	% this here is the MAIN marker code.
	% It may be modified if scatter plot is enabled, see below.
	\def\pgfplots@loc@TMPa{\tikz@transform\pgfuseplotmark{\tikz@plot@mark}}
	\ifpgfplots@scatterplotenabled
		% Scatter plots work like this:
		%
		% <compute per-point meta info>
		% /pgfplots/scatter/@pre marker code
		% <marker code, lowlevel>
		% /pgfplots/scatter/@post marker code
		%
		% -> that's all. The Rest is configurable with style which
		%  (re)define '@pre marker code' and '@post marker code' (see
		%  the docs for details).
		%
		% Prepare arguments for '@pre/@post' macros:
		\t@pgfplots@toka={%
			\begingroup
			\pgfplotsaxisvisphasetransformpointmeta
			\pgfkeysvalueof{/pgfplots/scatter/@pre marker code/.@cmd}\pgfeov
		}%
		\t@pgfplots@tokb=\expandafter{\pgfplots@loc@TMPa}%
		\t@pgfplots@tokc={%
			\pgfkeysvalueof{/pgfplots/scatter/@post marker code/.@cmd}\pgfeov
			\endgroup
		}%
		\edef\pgfplots@loc@TMPa{%
			\the\t@pgfplots@toka
			\the\t@pgfplots@tokb
			\the\t@pgfplots@tokc
		}%
	\fi
	\ifx\tikz@mark@list\pgfutil@empty%
		\expandafter\pgfplothandlermark\expandafter{\pgfplots@loc@TMPa}%
	\else
		\expandafter\pgfplothandlermarklisted\expandafter{\pgfplots@loc@TMPa}{\tikz@mark@list}%
	\fi
}%

	
% This thing here shall draw all error bar commands listed in '#2'.
%
% It will be invoked when any plotting commands take effect (that
% means all limits are computed; the axis has been drawn,
% transformations are set up...)
\def\pgfplots@errorbars@finishwithstyleoptions[#1]#2{%
	\scope[/pgfplots/.cd,#1,/pgfplots/every error bar]% it uses the /pgfplots/.unknown handler
	#2%
	\endscope
}

\def\pgfplots@errorbar@draw@float(#1,#2)(#3,#4){%
	\ifpgfplots@apply@datatrafo@x
		\pgfplotscoordmath{x}{datascaletrafo}{#1}%
		\let\pgfplots@xarg=\pgfmathresult%
		\pgfplotscoordmath{x}{datascaletrafo}{#3}%
		\let\pgfplots@error@xarg=\pgfmathresult%
	\else
		\def\pgfplots@xarg{#1}%
		\def\pgfplots@error@xarg{#3}%
	\fi
	\ifpgfplots@apply@datatrafo@y
		\pgfplotscoordmath{y}{datascaletrafo}{#2}%
		\let\pgfplots@yarg=\pgfmathresult%
		\pgfplotscoordmath{y}{datascaletrafo}{#4}%
		\let\pgfplots@error@yarg=\pgfmathresult%
	\else
		\def\pgfplots@yarg{#2}%
		\def\pgfplots@error@yarg{#4}%
	\fi
	\edef\pgfplots@loc@TMPa{{(\pgfplots@xarg,\pgfplots@yarg)}{(\pgfplots@error@xarg,\pgfplots@error@yarg)}}%
	\def\pgfplots@loc@TMPb{\pgfkeysvalueof{/pgfplots/error bars/draw error bar/.@cmd}}%
	\expandafter\pgfplots@loc@TMPb\pgfplots@loc@TMPa\pgfeov
}
\def\pgfplots@errorbar@draw@float@threedim(#1,#2,#3)(#4,#5,#6){%
	\ifpgfplots@apply@datatrafo@x
		\pgfplotscoordmath{x}{datascaletrafo}{#1}%
		\let\pgfplots@xarg=\pgfmathresult%
		\pgfplotscoordmath{x}{datascaletrafo}{#4}%
		\let\pgfplots@error@xarg=\pgfmathresult%
	\else
		\def\pgfplots@xarg{#1}%
		\def\pgfplots@error@xarg{#4}%
	\fi
	\ifpgfplots@apply@datatrafo@y
		\pgfplotscoordmath{y}{datascaletrafo}{#2}%
		\let\pgfplots@yarg=\pgfmathresult%
		\pgfplotscoordmath{y}{datascaletrafo}{#5}%
		\let\pgfplots@error@yarg=\pgfmathresult%
	\else
		\def\pgfplots@yarg{#2}%
		\def\pgfplots@error@yarg{#5}%
	\fi
	\ifpgfplots@apply@datatrafo@z
		\pgfplotscoordmath{z}{datascaletrafo}{#3}%
		\let\pgfplots@zarg=\pgfmathresult%
		\pgfplotscoordmath{z}{datascaletrafo}{#6}%
		\let\pgfplots@error@zarg=\pgfmathresult%
	\else
		\def\pgfplots@zarg{#3}%
		\def\pgfplots@error@zarg{#6}%
	\fi
	\edef\pgfplots@loc@TMPa{{(\pgfplots@xarg,\pgfplots@yarg,\pgfplots@zarg)}{(\pgfplots@error@xarg,\pgfplots@error@yarg,\pgfplots@error@zarg)}}%
	\def\pgfplots@loc@TMPb{\pgfkeysvalueof{/pgfplots/error bars/draw error bar/.@cmd}}%
	\expandafter\pgfplots@loc@TMPb\pgfplots@loc@TMPa\pgfeov
}

\def\pgfplots@errorbar@draw#1#2{%
	\begingroup
	\ifpgfplots@apply@datatrafo
		\ifpgfplots@curplot@threedim
			\pgfplots@errorbar@draw@float@threedim#1#2%
		\else
			\pgfplots@errorbar@draw@float#1#2%
		\fi
	\else
		\pgfkeysvalueof{/pgfplots/error bars/draw error bar/.@cmd}{#1}{#2}\pgfeov%
	\fi
	\endgroup
}%

% This routine is called at the begin of every plot.
% It initialises a zero level stream.
%
% The default is to use '0' as zero level streams.
%
% This method is called as "precommand"; before any Tikz drawing
% commands have been started.
\def\pgfplots@initzerolevelhandler{%
	\ifpgfplots@stackedmode
		% ATTENTION: this thing here says:
		%    "draw zero level coordinates from list XYZ."
		% But at the time of this initialisation, the list will be EMPTY!
		%
		% It will be filled later. That's ok, because 
		% \pgfplots@initzerolevelhandler will be
		% used as 'precommand', that means before Tikz sees any
		% coordinates.
		\pgfplots@stacked@initzerolevelhandler
	\else
		\ifpgfplots@threedim
			\def\pgfplotxzerolevelstreamstart{}%
			\def\pgfplotxzerolevelstreamend{}%
			\def\pgfplotxzerolevelstreamnext{%
				\begingroup
				\pgf@xa=\pgf@y
				\pgfplotsqpointxyz{\pgfplots@logical@ZERO@x}{\pgfplots@current@point@y}{\ifpgfplots@curplot@threedim\pgfplots@current@point@z\else\pgfplots@logical@ZERO@z\fi}%
				\global\pgf@x=\pgf@x
				\global\pgf@y=\pgf@xa
				\endgroup
			}%
			%
			\def\pgfplotyzerolevelstreamstart{}%
			\def\pgfplotyzerolevelstreamend{}%
			\def\pgfplotyzerolevelstreamnext{%
				\begingroup
				\pgf@xa=\pgf@y
				\pgfplotsqpointxyz{\pgfplots@current@point@x}{\pgfplots@current@point@y}{\pgfplots@logical@ZERO@z}%
				\global\pgf@x=\pgf@y
				\global\pgf@y=\pgf@xa
				\endgroup
			}%
		\else
			\pgfplotspointaxisorigin
			\expandafter\pgfplotxzerolevelstreamconstant\expandafter{\the\pgf@x}%
			\expandafter\pgfplotyzerolevelstreamconstant\expandafter{\the\pgf@y}%
		\fi
	\fi
}

% This code is mainly interesting for bar plots.
%
% It precomputes x = 0 and y = 0 - which is not necessarily
% trivial in case of data scaling. Furthermore, it applies
% coordinate clipping to the resulting values and multiplies them
% with x- and y scale vectors.
\def\pgfplots@prepare@ZERO@coordinates{%
	\ifpgfplots@xislinear
		\ifpgfplots@apply@datatrafo@x
			\pgfplotscoordmath{x}{parsenumber}{0}%
			\pgfplotscoordmath{x}{datascaletrafo}{\pgfmathresult}%
			\global\let\pgfplots@logical@ZERO@x=\pgfmathresult
		\else
			\gdef\pgfplots@logical@ZERO@x{0}%
		\fi
		% this works in standard fixed pt math:
		\pgfplotsmathmax{\pgfplots@logical@ZERO@x}{\pgfplots@xmin}%
		\global\let\pgfplots@logical@ZERO@x=\pgfmathresult
		\pgfplotsmathmin{\pgfplots@logical@ZERO@x}{\pgfplots@xmax}%
		\global\let\pgfplots@logical@ZERO@x=\pgfmathresult
	\else
		\if\pgfplots@log@origin@choice@x0%
			\global\let\pgfplots@logical@ZERO@x=\pgfplots@xmin%
		\else
			\gdef\pgfplots@logical@ZERO@x{0}%
		\fi
	\fi
	%
	\ifpgfplots@yislinear
		\ifpgfplots@apply@datatrafo@y
			\pgfplotscoordmath{y}{parsenumber}{0}%
			\pgfplotscoordmath{y}{datascaletrafo}{\pgfmathresult}%
			\global\let\pgfplots@logical@ZERO@y=\pgfmathresult
		\else
			\gdef\pgfplots@logical@ZERO@y{0}%
		\fi
		\pgfplotsmathmax{\pgfplots@logical@ZERO@y}{\pgfplots@ymin}%
		\global\let\pgfplots@logical@ZERO@y=\pgfmathresult
		\pgfplotsmathmin{\pgfplots@logical@ZERO@y}{\pgfplots@ymax}%
		\global\let\pgfplots@logical@ZERO@y=\pgfmathresult
	\else
		\if\pgfplots@log@origin@choice@y0%
			\global\let\pgfplots@logical@ZERO@y=\pgfplots@ymin%
		\else
			\gdef\pgfplots@logical@ZERO@y{0}%
		\fi
	\fi
	%
	\ifpgfplots@threedim
		\ifpgfplots@zislinear
			\ifpgfplots@apply@datatrafo@z
				\pgfplotscoordmath{z}{parsenumber}{0}%
				\pgfplotscoordmath{z}{datascaletrafo}{\pgfmathresult}%
				\global\let\pgfplots@logical@ZERO@z=\pgfmathresult
			\else
				\gdef\pgfplots@logical@ZERO@z{0}%
			\fi
			\pgfplotsmathmax{\pgfplots@logical@ZERO@z}{\pgfplots@zmin}%
			\global\let\pgfplots@logical@ZERO@z=\pgfmathresult
			\pgfplotsmathmin{\pgfplots@logical@ZERO@z}{\pgfplots@zmax}%
			\global\let\pgfplots@logical@ZERO@z=\pgfmathresult
		\else
			\if\pgfplots@log@origin@choice@z0%
				\global\let\pgfplots@logical@ZERO@z=\pgfplots@zmin%
			\else
				\gdef\pgfplots@logical@ZERO@z{0}%
			\fi
		\fi
	\fi
	%
	%
	\ifpgfplots@threedim
		\pgfplotsqpointxyz{\pgfplots@logical@ZERO@x}{\pgfplots@logical@ZERO@y}{\pgfplots@logical@ZERO@z}%
	\else
		\pgfplotsqpointxy{\pgfplots@logical@ZERO@x}{\pgfplots@logical@ZERO@y}%
	\fi
	\xdef\pgfplots@ZERO@x{\the\pgf@x}%
	\xdef\pgfplots@ZERO@y{\the\pgf@y}%
	\xdef\pgfplotspointaxisorigin{\noexpand\global\pgf@x=\pgfplots@ZERO@x\space\noexpand\global\pgf@y=\pgfplots@ZERO@y\space}%
}%



% the low-level Tikz command which realizes 'plot graphics'.
%
% It's current state is described by some pgfkeys options and two
% coordinates.
\def\pgfplotsplothandlergraphics{%
	\def\pgf@plotstreamstart{%
		\gdef\pgfplots@plot@handler@graphics@bb@first{\pgf@x=16000pt \pgf@y=16000pt }%
		\gdef\pgfplots@plot@handler@graphics@bb@second{\pgf@x=-16000pt \pgf@y=-16000pt }%
		\global\let\pgf@plotstreampoint=\pgfplots@plot@handler@graphics@collectbb%
		\global\let\pgf@plotstreamspecial=\pgfutil@gobble%
		\global\let\pgf@plotstreamend=\pgfplots@plot@handler@graphics@finish%
		\def\pgfplotsplothandlervisualizejump{%
			\pgfplots@error{Sorry, plot graphics does not support 'unbounded coords=jump'.}%
		}%
	}%
}%
\def\pgfplots@plot@handler@graphics@collectbb#1{%
	\pgf@process{#1}%
	\pgf@xa=\pgf@x
	\pgf@ya=\pgf@y
	\pgfplots@plot@handler@graphics@bb@first
	\ifdim\pgf@xa<\pgf@x \pgf@x=\pgf@xa\fi
	\ifdim\pgf@ya<\pgf@y \pgf@y=\pgf@ya\fi
	\xdef\pgfplots@plot@handler@graphics@bb@first{\pgf@x=\the\pgf@x\space\pgf@y=\the\pgf@y\space}%
	%
	\pgfplots@plot@handler@graphics@bb@second
	\ifdim\pgf@xa>\pgf@x \pgf@x=\pgf@xa\fi
	\ifdim\pgf@ya>\pgf@y \pgf@y=\pgf@ya\fi
	\xdef\pgfplots@plot@handler@graphics@bb@second{\pgf@x=\the\pgf@x\space\pgf@y=\the\pgf@y\space}%
	%
}%
\def\pgfplots@plot@handler@graphics@finish{%
	\let\pgfplots@plot@handler@graphics@pointmap@B@canvas\pgfutil@empty
	%
	% check if we have a pointmap. If so, the pointmap should be used
	% to place the graphics.
	\pgfkeysgetvalue{/pgfplots/plot graphics/points}\pgfplots@plot@handler@graphics@pointmap
	\ifx\pgfplots@plot@handler@graphics@pointmap\pgfutil@empty
	\else
		\let\pgfplots@plot@handler@graphics@parsepointmap@error=\relax
		\expandafter\pgfplots@plot@handler@graphics@parsepointmap\expandafter{\pgfplots@plot@handler@graphics@pointmap}%
	\fi
	%
	%
	\ifx\pgfplots@plot@handler@graphics@pointmap@B@canvas\pgfutil@empty
		% no pointmap. Good; then squeze graphics into the bounding
		% box:
		\pgfplots@plot@handler@graphics@usebb
	\else
		% oh, a pointmap! Process it.
		\pgfplots@plot@handler@graphics@process@pointmap
	\fi
}%

% Parses the argument of '/pgfplots/plot graphics/points'.
%
% #1: the argument of the key above.
\def\pgfplots@plot@handler@graphics@parsepointmap#1{%
	\let\pgfplots@plot@handler@graphics@pointmap@A@canvas\pgfutil@empty
	\let\pgfplots@plot@handler@graphics@pointmap@A@img\pgfutil@empty
	\let\pgfplots@plot@handler@graphics@pointmap@B@canvas\pgfutil@empty
	\let\pgfplots@plot@handler@graphics@pointmap@B@img\pgfutil@empty
	\let\pgfplots@plot@handler@graphics@pointmap@C@canvas\pgfutil@empty
	\let\pgfplots@plot@handler@graphics@pointmap@C@img\pgfutil@empty
	\let\pgfplots@plot@handler@graphics@pointmap@D@canvas\pgfutil@empty
	\let\pgfplots@plot@handler@graphics@pointmap@D@img\pgfutil@empty
	\pgfplots@plot@handler@graphics@parsepointmap@loop#1\pgfplots@EOI
	\ifpgfplots@plot@graphics@autoadjustaxis
		\ifx\pgfplots@plot@handler@graphics@pointmap@A@img\pgfutil@empty
		\else
			\ifx\pgfplots@plot@handler@graphics@pointmap@D@img\pgfutil@empty
				\def\pgfplots@loc@TMPa{#1}%
				\pgfplots@plot@handler@graphics@parsepointmap@error
			\fi
		\fi
	\fi
}%
\def\pgfplots@plot@handler@graphics@parsepointmap@error{%
	\pgfplots@error{plot graphics/points={\pgfplots@loc@TMPa} cannot be processed: I need at least *four* inner anchor points to automatically adjust the axis, i.e. 4 points of the form (x,y,z) => (imgx,imgy). Use 'plot graphics/auto adjust axis=false' to disable this feature}%
}%
\def\pgfplots@plot@handler@graphics@parsepointmap@loop{%
	\pgfutil@ifnextchar\pgfplots@EOI{%
		\pgfplots@gobble@until@EOI
	}{%
		\pgfplots@plot@handler@graphics@parsepointmap@loop@
	}%
}%
\def\pgfplots@plot@handler@graphics@parsepointmap@loop@(#1,#2){%
	\pgfutil@ifnextchar={%
		\pgfplots@plot@handler@graphics@parsepointmap@loop@@(#1,#2)%
	}{%
		\pgfplots@plot@handler@graphics@parsepointmap@loop@@(#1,#2)=>(,)%
	}%
}%
\def\pgfplots@plot@handler@graphics@parsepointmap@loop@@(#1,#2)=>{%
	\pgfutil@ifnextchar({%
		\pgfplots@plot@handler@graphics@parsepointmap@loop@@@(#1,#2)%
	}{%
		\pgfplots@error{Syntax error for plot graphics/pointmap: expected '(#1,#2) => (...,...)'}%
		\pgfplots@gobble@until@EOI
	}%
}
\def\pgfplots@plot@handler@graphics@parsepointmap@loop@@@(#1,#2)(#3,#4){%
	\def\pgfplotsplothandlergraphicspointmappointindex{}%
	\def\pgfplots@loc@TMPc{#4}%
	\ifx\pgfplots@loc@TMPc\pgfutil@empty
	\else
		\ifx\pgfplots@plot@handler@graphics@pointmap@A@img\pgfutil@empty
			\def\pgfplotsplothandlergraphicspointmappointindex{A}%
		\else
			\ifx\pgfplots@plot@handler@graphics@pointmap@B@img\pgfutil@empty
				\def\pgfplotsplothandlergraphicspointmappointindex{B}%
			\else
				\ifx\pgfplots@plot@handler@graphics@pointmap@C@img\pgfutil@empty
					\def\pgfplotsplothandlergraphicspointmappointindex{C}%
				\else
					\ifx\pgfplots@plot@handler@graphics@pointmap@D@img\pgfutil@empty
						\def\pgfplotsplothandlergraphicspointmappointindex{D}%
					\else
						\def\pgfplotsplothandlergraphicspointmappointindex{*}%
						%\pgfplots@error{Sorry, the argument '(#1,#2) => (#3,#4)' of plot graphics/pointmap is superfluos; ignoring it.}%
					\fi
				\fi
			\fi
		\fi
		\pgfmathparse{#3}%
		\let\pgfplots@loc@TMPb=\pgfmathresult
		%
		\pgfmathparse{#4}%
		\expandafter\edef\csname pgfplots@plot@handler@graphics@pointmap@\pgfplotsplothandlergraphicspointmappointindex @img\endcsname{{\pgfplots@loc@TMPb}{\pgfmathresult}}%
	\fi
	%
	%
	\pgfutil@in@,{#2}%
	\ifpgfutil@in@
		\def\pgfplots@loc@TMPa##1,##2\relax{%
			\expandafter\edef\csname pgfplots@plot@handler@graphics@pointmap@\pgfplotsplothandlergraphicspointmappointindex @logical\endcsname{{#1}{##1}{##2}}%
			%
			\pgfplotsplothandlergraphicspointmappoint(#1,##1,##2)(#3,#4)
		}%
		\pgfplots@loc@TMPa#2\relax
	\else
		\expandafter\edef\csname pgfplots@plot@handler@graphics@pointmap@\pgfplotsplothandlergraphicspointmappointindex @logical\endcsname{{#1}{#2}{}}%
		\pgfplotsplothandlergraphicspointmappoint(#1,#2,)(#3,#4)
	\fi
	\pgfplots@plot@handler@graphics@parsepointmap@loop
}

\def\pgfplotsplothandlergraphics@survey@pointmappoint(#1,#2,#3)(#4,#5){%
	\def\pgfplots@current@point@x{#1}%
	\def\pgfplots@current@point@y{#2}%
	\def\pgfplots@current@point@z{#3}%
	\pgfplots@coord@stream@coord
}%

% PRECONDITION:
% 	\pgfplotsplothandlergraphicspointmappointindex is 
% 	empty if and only if (#4,#5) is empty 
% 	or it is an index among all points with non--empty (#4,#5) image
% 	coordinates.
\def\pgfplotsplothandlergraphicspointmappoint(#1,#2,#3)(#4,#5){%
	\ifx\pgfplotsplothandlergraphicspointmappointindex\pgfutil@empty
	\else
		\def\pgfplots@loc@TMPc{#3}%
		\ifx\pgfplots@loc@TMPc\pgfutil@empty
			\pgfplotspointaxisxy{#1}{#2}%
		\else
			\pgfplotspointaxisxyz{#1}{#2}{#3}%
		\fi
		\expandafter\edef\csname pgfplots@plot@handler@graphics@pointmap@\pgfplotsplothandlergraphicspointmappointindex @canvas\endcsname{\pgf@x=\the\pgf@x\space\pgf@y=\the\pgf@y\space}%
	\fi
}%

% Computes view-related keys which should be communicated to the axis
% in order to render the plot graphics correctly.
%
% @POSTCONDITION: \pgfplotsretval contains any required keys.
\def\pgfplotsplothandlergraphicspointmapcomputerequiredview{%
	\begingroup
	\let\pgfplotsretval=\pgfutil@empty
	\ifx\pgfplots@plot@handler@graphics@pointmap@D@img\pgfutil@empty
	\else
		\pgfkeysgetvalue{/pgfplots/plot graphics/debug}\pgfplots@loc@TMPa
		\def\pgfplots@loc@TMPb{true}%
		\ifx\pgfplots@loc@TMPa\pgfplots@loc@TMPb
			\def\pgfplotsplothandlergraphicspointmapcomputerequiredview@debug{1}%
		\else
			\def\pgfplotsplothandlergraphicspointmapcomputerequiredview@debug{0}%
		\fi
		% The following implementation computes the 'unit vector
		% ratio' of the IMAGE.
		%
		% It then tells PGFPlots to use the very same unit vector
		% ratio for its axis.
		%
		%
		% The actual implementation is dumb; it requires 4 (!) points for
		% which BOTH, the 3D coordinates and the projected 2D
		% coordinates relative to the image's lower left corner are
		% available.
		%
		% Since the 2D projected coordinates are generated by the map
		%
		% T(x,y,z) = o + x e_x + y e_y + z e_z in R^2
		% with o,e_x,e_y,e_z in R^2,
		%
		% I have 8 degrees of freedom (two for each of the four
		% involved vectors). Thus, a simple approach is to provide 4
		% linearly independend points to get 8 equations.
		%
		% Then, I solve for o,e_x,e_y,e_z 
		%
		\pgfplotsmatrixnewempty\pgfplotsmatrix
		\pgfplotsmatrixresize\pgfplotsmatrix88%
		%
		\pgfplotsarraynewempty\pgfplotsE
		\pgfplotsarrayresize\pgfplotsE8%
		%
		\def\pgfplots@extractimg##1##2{%
			\def\pgfplots@img@x{##1}%
			\def\pgfplots@img@y{##2}%
		}%
		\def\pgfplots@extractlogical##1##2##3{%
			\def\pgfplots@logical@x{##1}%
			\def\pgfplots@logical@y{##2}%
			\def\pgfplots@logical@z{##3}%
		}%
		% Assemble the linear system such that
		% x = [ 
		%  exx 
		%  exy
		%  eyx
		%  eyy
		%  ezx
		%  ezy
		%  ox
		%  oy]
		% are the degrees of freedom.
		\c@pgfplots@coordindex=0
		\pgfplotsutilforeachcommasep{A,B,C,D}\as\pgfplots@loc@TMPa{%
			\expandafter\expandafter\expandafter\pgfplots@extractimg\csname pgfplots@plot@handler@graphics@pointmap@\pgfplots@loc@TMPa @img\endcsname
			\expandafter\expandafter\expandafter\pgfplots@extractlogical\csname pgfplots@plot@handler@graphics@pointmap@\pgfplots@loc@TMPa @logical\endcsname
			\ifx\pgfplots@logical@z\pgfutil@empty
			\else
			%
			\pgfplotsmatrixletentry \the\c@pgfplots@coordindex,0\of\pgfplotsmatrix=\pgfplots@logical@x%
			\pgfplotsmatrixset \the\c@pgfplots@coordindex,1\of\pgfplotsmatrix\to{0}%
			\pgfplotsmatrixletentry \the\c@pgfplots@coordindex,2\of\pgfplotsmatrix=\pgfplots@logical@y%
			\pgfplotsmatrixset \the\c@pgfplots@coordindex,3\of\pgfplotsmatrix\to{0}%
			\pgfplotsmatrixletentry \the\c@pgfplots@coordindex,4\of\pgfplotsmatrix=\pgfplots@logical@z%
			\pgfplotsmatrixset \the\c@pgfplots@coordindex,5\of\pgfplotsmatrix\to{0}%
			\pgfplotsmatrixset \the\c@pgfplots@coordindex,6\of\pgfplotsmatrix\to{1}%
			\pgfplotsmatrixset \the\c@pgfplots@coordindex,7\of\pgfplotsmatrix\to{0}%
			%
			\pgfplotsarrayletentry\c@pgfplots@coordindex\of\pgfplotsE=\pgfplots@img@x
			%
			\advance\c@pgfplots@coordindex by1
			\pgfplotsmatrixset \the\c@pgfplots@coordindex,0\of\pgfplotsmatrix\to{0}%
			\pgfplotsmatrixletentry \the\c@pgfplots@coordindex,1\of\pgfplotsmatrix=\pgfplots@logical@x%
			\pgfplotsmatrixset \the\c@pgfplots@coordindex,2\of\pgfplotsmatrix\to{0}%
			\pgfplotsmatrixletentry \the\c@pgfplots@coordindex,3\of\pgfplotsmatrix=\pgfplots@logical@y%
			\pgfplotsmatrixset \the\c@pgfplots@coordindex,4\of\pgfplotsmatrix\to{0}%
			\pgfplotsmatrixletentry \the\c@pgfplots@coordindex,5\of\pgfplotsmatrix=\pgfplots@logical@z%
			\pgfplotsmatrixset \the\c@pgfplots@coordindex,6\of\pgfplotsmatrix\to{0}%
			\pgfplotsmatrixset \the\c@pgfplots@coordindex,7\of\pgfplotsmatrix\to{1}%
			%
			\pgfplotsarrayletentry\c@pgfplots@coordindex\of\pgfplotsE=\pgfplots@img@y
			%
			\advance\c@pgfplots@coordindex by1
			\fi
		}%
		\ifx\pgfplots@logical@z\pgfutil@empty
		\else
			\if1\pgfplotsplothandlergraphicspointmapcomputerequiredview@debug
				\pgfplotsplothandlergraphics@debug@matrix@to@string
			\fi
			%
			%
			\pgfplotsmatrixsolveLEQS\pgfplotsmatrix=\pgfplotsE
			%
			\edef\pgfmathresult{\pgfplotsarrayvalueofelem0\of\pgfplotsE}%
			\pgfplotscoordmath{default}{tofixed}{\pgfmathresult}%
			\let\pgfplots@xx=\pgfmathresult
			\edef\pgfmathresult{\pgfplotsarrayvalueofelem1\of\pgfplotsE}%
			\pgfplotscoordmath{default}{tofixed}{\pgfmathresult}%
			\let\pgfplots@xy=\pgfmathresult
			\if r\pgfkeysvalueof{/pgfplots/x dir/value}%
				% they will be reversed again during the final
				% processing:
				\edef\pgfplots@xx{-\pgfplots@xx}%
				\edef\pgfplots@xy{-\pgfplots@xy}%
			\fi
			%
			\edef\pgfmathresult{\pgfplotsarrayvalueofelem2\of\pgfplotsE}%
			\pgfplotscoordmath{default}{tofixed}{\pgfmathresult}%
			\let\pgfplots@yx=\pgfmathresult
			\edef\pgfmathresult{\pgfplotsarrayvalueofelem3\of\pgfplotsE}%
			\pgfplotscoordmath{default}{tofixed}{\pgfmathresult}%
			\let\pgfplots@yy=\pgfmathresult
			\if r\pgfkeysvalueof{/pgfplots/y dir/value}%
				% they will be reversed again during the final
				% processing:
				\edef\pgfplots@yx{-\pgfplots@yx}%
				\edef\pgfplots@yy{-\pgfplots@yy}%
			\fi
			%
			\edef\pgfmathresult{\pgfplotsarrayvalueofelem4\of\pgfplotsE}%
			\pgfkeysgetvalue{/pgfplots/plot graphics/snap z}\pgfplots@loc@TMPa
			\ifx\pgfplots@loc@TMPa\pgfutil@empty
			\else
				\let\pgfplots@zx=\pgfmathresult
				\pgfplotscoordmath{default}{op}{veclen}{%
					{\pgfplotsarrayvalueofelem4\of\pgfplotsE}%
					{\pgfplotsarrayvalueofelem5\of\pgfplotsE}%
				}%
				\let\pgfplotszlen=\pgfmathresult
				%
				% compute 'snap z' relative to
				% '\pgfplotszlen'
				\pgfplotscoordmath{default}{parsenumber}{\pgfplots@loc@TMPa}%
				\pgfplotscoordmath{default}{op}{multiply}{{\pgfmathresult}{\pgfplotszlen}}%
				\let\pgfplots@loc@TMPa=\pgfmathresult
				%
				\pgfplotscoordmath{default}{op}{abs}{{\pgfplots@zx}}%
				\pgfplotscoordmath{default}{if less than}{\pgfmathresult}{\pgfplots@loc@TMPa}{%
					\pgfplotscoordmath{default}{zero}%
				}{%
					\let\pgfmathresult=\pgfplots@zx
				}%
			\fi
			\pgfplotscoordmath{default}{tofixed}\pgfmathresult%
			\let\pgfplots@zx=\pgfmathresult
			%
			\edef\pgfmathresult{\pgfplotsarrayvalueofelem5\of\pgfplotsE}%
			\pgfplotscoordmath{default}{tofixed}{\pgfmathresult}%
			\let\pgfplots@zy=\pgfmathresult
			\if r\pgfkeysvalueof{/pgfplots/z dir/value}%
				% they will be reversed again during the final
				% processing:
				\edef\pgfplots@zx{-\pgfplots@zx}%
				\edef\pgfplots@zy{-\pgfplots@zy}%
			\fi
			%
			%
			\edef\pgfplotsretval{%
				x={(\pgfplots@xx,\pgfplots@xy)},%
				y={(\pgfplots@yx,\pgfplots@yy)},%
				z={(\pgfplots@zx,\pgfplots@zy)},%
				scale mode=scale uniformly,%
			}%
			%
			\if1\pgfplotsplothandlergraphicspointmapcomputerequiredview@debug
				\pgfplotsplothandlergraphicspointmapcomputerequiredview@debug@output
			\fi
			%
			\ifx\pgfplotsretval\pgfutil@empty
				\pgfplots@error{plot graphics failed to perform the 'auto adjust axis' feature \csname on@line\endcsname\space\space (compare 'plot graphics[debug]). The graphics might be scaled incorrectly. Perhaps the provided 'points' are not linearly independent?}%
			\else
				\begingroup
				\pgfkeysgetvalue{/pgfplots/plot graphics/src}\pgfplots@loc@TMPa
				\t@pgfplots@tokc=\expandafter{\pgfplots@loc@TMPa}%
				\immediate\write
					\if1\pgfplotsplothandlergraphicspointmapcomputerequiredview@debug 16\else -1\fi
					{PGFPlots plot graphics[auto adjust axis=true] {\the\t@pgfplots@tokc} \csname on@line\endcsname: determined options '\pgfplotsretval'. 
					\if1\pgfplotsplothandlergraphicspointmapcomputerequiredview@debug
						See \the\t@pgfplots@tokc.dat for debug output.
					\else
						Use 'plot graphics[debug] to generate debug output files.
					\fi
					^^J}% 
				\endgroup
			\fi
			%
		\fi
	\fi
	\pgfmath@smuggleone\pgfplotsretval
	\endgroup
}%
\def\pgfplotsplothandlergraphics@debug@matrix@to@string{%
	\pgfplotsmatrixtotext\pgfplotsmatrix
	\let\pgfplotsmatrix@text=\pgfplotsretval
	\pgfplotsarraytotext\pgfplotsE
	\let\pgfplotsrhs@text=\pgfplotsretval
}%
\def\pgfplotsplothandlergraphicspointmapcomputerequiredview@debug@output{%
	\begingroup
	\immediate\openout\w@pgf@writea=\pgfkeysvalueof{/pgfplots/plot graphics/src}.dat
	\pgfplotsarrayselect0\of\pgfplotsE\to\pgfmathresult \pgfplotscoordmath{default}{tofixed}{\pgfmathresult}\let\pgfplots@loc@TMPa=\pgfmathresult
	\pgfplotsarrayselect1\of\pgfplotsE\to\pgfmathresult \pgfplotscoordmath{default}{tofixed}{\pgfmathresult}\let\pgfplots@loc@TMPb=\pgfmathresult
	\immediate\write\w@pgf@writea{img x unit=\pgfplots@loc@TMPa\space\pgfplots@loc@TMPb\if r\pgfkeysvalueof{/pgfplots/x dir/value}(reversed due to x dir=reverse)\fi,}%
	\pgfplotsarrayselect2\of\pgfplotsE\to\pgfmathresult \pgfplotscoordmath{default}{tofixed}{\pgfmathresult}\let\pgfplots@loc@TMPa=\pgfmathresult
	\pgfplotsarrayselect3\of\pgfplotsE\to\pgfmathresult \pgfplotscoordmath{default}{tofixed}{\pgfmathresult}\let\pgfplots@loc@TMPb=\pgfmathresult
	\immediate\write\w@pgf@writea{img y unit=\pgfplots@loc@TMPa\space\pgfplots@loc@TMPb\if r\pgfkeysvalueof{/pgfplots/y dir/value}(reversed due to y dir=reverse)\fi,}%
	\pgfplotsarrayselect4\of\pgfplotsE\to\pgfmathresult \pgfplotscoordmath{default}{tofixed}{\pgfmathresult}\let\pgfplots@loc@TMPa=\pgfmathresult
	\pgfplotsarrayselect5\of\pgfplotsE\to\pgfmathresult \pgfplotscoordmath{default}{tofixed}{\pgfmathresult}\let\pgfplots@loc@TMPb=\pgfmathresult
	\immediate\write\w@pgf@writea{img z unit=\pgfplots@loc@TMPa\space\pgfplots@loc@TMPb,}%
	\pgfplotsarrayselect6\of\pgfplotsE\to\pgfmathresult \pgfplotscoordmath{default}{tofixed}{\pgfmathresult}\let\pgfplots@loc@TMPa=\pgfmathresult
	\pgfplotsarrayselect7\of\pgfplotsE\to\pgfmathresult \pgfplotscoordmath{default}{tofixed}{\pgfmathresult}\let\pgfplots@loc@TMPb=\pgfmathresult
	\immediate\write\w@pgf@writea{img origin=\pgfplots@loc@TMPa\space\pgfplots@loc@TMPb\if r\pgfkeysvalueof{/pgfplots/z dir/value}(reversed due to z dir=reverse)\fi,}%
	\def\n{^^J}%
	\def\t{^^I}%
	\immediate\write\w@pgf@writea{canvasmapmatrix=[\pgfplotsmatrix@text];^^Jcanvasmaprhs = [\pgfplotsrhs@text];^^J}%
	\immediate\closeout\w@pgf@writea
	\endgroup
}%

\def\pgfplots@plot@handler@graphics@process@pointmap{%
	\begingroup
	% determine natural size:
	\pgfplots@invoke@pgfkeyscode{/pgfplots/plot graphics/lowlevel get natural size/.@cmd}{}%
	\def\pgfplots@loc@TMPa##1##2{%
		\global\pgf@x=##1
		\global\pgf@y=##2
	}%
	\expandafter\pgfplots@loc@TMPa\pgfmathresult
	\edef\pgfplots@W{\pgf@sys@tonumber\pgf@x}% natural WIDTH
	\edef\pgfplots@H{\pgf@sys@tonumber\pgf@y}% natural HEIGHT
	%
	\def\pgfplots@extractimg##1##2{%
		\def\pgfplots@img@x{##1}%
		\def\pgfplots@img@y{##2}%
	}%
	\def\pgfplots@extractimgaspoint##1##2{%
		\pgfqpoint{##1pt}{##2pt}%
	}%
	\expandafter\pgfplots@extractimg\pgfplots@plot@handler@graphics@pointmap@A@img% anchor 1 in image
	\let\pgfplots@Ax=\pgfplots@img@x
	\let\pgfplots@Ay=\pgfplots@img@y
	%
	\pgfplots@plot@handler@graphics@pointmap@A@canvas% the canvas coordinate corresponding to 'A'
	\edef\pgfplots@ax{\pgf@sys@tonumber\pgf@x}% call it 'a'
	\edef\pgfplots@ay{\pgf@sys@tonumber\pgf@y}%
	%
	% compute the CANVAS diagonal between the two anchors points a,b,
	%  dd := b-a
	\pgfpointdiff
		\pgfplots@plot@handler@graphics@pointmap@A@canvas
		\pgfplots@plot@handler@graphics@pointmap@B@canvas
	\edef\pgfplots@ddx{\pgf@sys@tonumber\pgf@x}%
	\edef\pgfplots@ddy{\pgf@sys@tonumber\pgf@y}%
	%
	% compute the IMAGE diagonal between the two image anchor points A,B,
	%   DD := B - A
	\pgfpointdiff
		{\expandafter\pgfplots@extractimgaspoint\pgfplots@plot@handler@graphics@pointmap@A@img}
		{\expandafter\pgfplots@extractimgaspoint\pgfplots@plot@handler@graphics@pointmap@B@img}%
	\pgfplots@loop@CONTINUEtrue
	\ifdim\pgf@x=0pt \pgfplots@loop@CONTINUEfalse \fi
	\ifdim\pgf@y=0pt \pgfplots@loop@CONTINUEfalse \fi
	\ifpgfplots@loop@CONTINUE
	\else
		\pgfplots@error{Sorry, the first two points with '=>' in plot graphics[points={}] are expected to have different image Y coordinates. Please reorder the sequence.}%
	\fi
	\edef\pgfplots@DDx{\pgf@sys@tonumber\pgf@x}%
	\edef\pgfplots@DDy{\pgf@sys@tonumber\pgf@y}%
	%
	% What I need now is a shift and the CANVAS dimensions of the
	% image. Both can be computed using the relative sizes dd/DD.
	%
	% The shift is needed to compute the lower left corner of the
	% CANVAS image. thus, the lower left CANVAS image corresponds to
	% the (0,0) coordinate in the IMAGE.
	%
	% Remember that 'A' is the anchor 1 in IMAGE coordinates. It is a
	% vector from (0,0) --> (A_x,A_y) in IMAGE coordinates.
	%
	% Now, I want a vector (v_x,v_y)  such that q + v = a in CANVAS
	% coordinates. Here, 'q' is the lower left corner; it corresponds
	% to the (0,0) in IMAGE coordinates. Thus, we have
	% v = (a-q). Taking the relative sizes of dd and DD, we find
	%
	%   DD_x / A_x = dd_x / v_x
	%   DD_y / A_y = dd_y / v_y
	%
	% and finally q = a-v is the lower left CANVAS coordinate.
	\pgfmath@basic@divide@{\pgfplots@ddx}{\pgfplots@DDx}%
	\let\pgfplots@x@rel=\pgfmathresult
	%
	\pgfmath@basic@divide@{\pgfplots@ddy}{\pgfplots@DDy}%
	\let\pgfplots@y@rel=\pgfmathresult
	%
	\pgfmath@basic@multiply@{\pgfplots@Ax}{\pgfplots@x@rel}%
	\let\pgfplots@vx=\pgfmathresult
	%
	\pgfmath@basic@multiply@{\pgfplots@Ay}{\pgfplots@y@rel}%
	\let\pgfplots@vy=\pgfmathresult
	%
	%
	%
	%
	% now, the canvas width. It is even simpler because it holds
	%
	%  DD_x / dd_x = W / w
	%  DD_y / dd_y = H / h
	%
	% where (W,H) is the natural size (i.e. in IMAGE coordinates) of the picture and 
	% (w,h) is the size the picture will occupy in CANVAS coordinates.
	%  
	\pgfmath@basic@multiply@{\pgfplots@x@rel}{\pgfplots@W}%
	\let\pgfplots@w=\pgfmathresult
	%
	\pgfmath@basic@multiply@{\pgfplots@y@rel}{\pgfplots@H}%
	\let\pgfplots@h=\pgfmathresult
	%
	\edef\pgfplots@plot@handler@graphics@DRAW@{%
		\noexpand\pgfplots@invoke@pgfkeyscode{/pgfplots/plot graphics/lowlevel draw/.@cmd}{%
			{\pgfplots@w pt}% width
			{\pgfplots@h pt}% height
		}%
	}%
	\pgfpointadd
		{\pgfplots@plot@handler@graphics@pointmap@A@canvas}% the canvas coordinate corresponding to 'A'
		{\pgfqpointscale{-1}
			{\pgfqpoint{\pgfplots@vx pt}{\pgfplots@vy pt}}%
		}%
	\edef\pgfplots@plot@handler@graphics@pointmap@lowerleft@canvas{\pgf@x=\the\pgf@x\space\pgf@y=\the\pgf@y\space}%
%
	%
	%
	\begingroup
		\pgftransformshift{}% simply take \pgf@x and \pgf@y
		%
		\node[/pgfplots/plot graphics/node] {%
			\pgfplots@plot@handler@graphics@DRAW@
		};%
	\endgroup
	\ifx\pgfplots@plot@handler@graphics@pointmap@C@canvas\pgfutil@empty
		\ifpgfplots@threedim
			\pgfplots@warning{plot graphics in 3D axis has just two inner anchors (those with '(x,y,z)=>(imgx,imgy)'). You should provide a third one such that I can check for correct scaling.}%
		\fi
	\else
		\pgfplots@plot@handler@graphics@pointmap@sanitize@scaling{C}%
		\ifx\pgfplots@plot@handler@graphics@pointmap@D@canvas\pgfutil@empty
		\else
			\pgfplots@plot@handler@graphics@pointmap@sanitize@scaling{D}%
		\fi
	\fi
	\endgroup
}%

% Checks if the logical and canvas coordinates of the point identified
% by #1 are correct.
%
% #1: a character in {A,B,C...}.
%
\def\pgfplots@plot@handler@graphics@pointmap@sanitize@scaling#1{%
	\begingroup
	\expandafter\let\expandafter\pgfplots@point@img\csname pgfplots@plot@handler@graphics@pointmap@#1@img\endcsname
	\expandafter\let\expandafter\pgfplots@point@canvas\csname pgfplots@plot@handler@graphics@pointmap@#1@canvas\endcsname
	\expandafter\let\expandafter\pgfplots@point@logical\csname pgfplots@plot@handler@graphics@pointmap@#1@logical\endcsname
	\expandafter\pgfplots@extractimgaspoint\pgfplots@point@img% anchor 3 in image
	\edef\pgfplots@Cx{\pgf@sys@tonumber\pgf@x}%
	\edef\pgfplots@Cy{\pgf@sys@tonumber\pgf@y}%
	%
	\pgfmath@basic@multiply@{\pgfplots@Cx}{\pgfplots@x@rel}%
	\let\pgfplots@Cx=\pgfmathresult
	%
	\pgfmath@basic@multiply@{\pgfplots@Cy}{\pgfplots@y@rel}%
	\let\pgfplots@Cy=\pgfmathresult
	\pgfpointadd
		{\pgfplots@plot@handler@graphics@pointmap@lowerleft@canvas}%
		{\pgfpoint\pgfplots@Cx\pgfplots@Cy}%
	\edef\pgfplots@point@canvas@check{\pgf@x=\the\pgf@x\space\pgf@y=\the\pgf@y\space}%
	\pgfpointdiff
		{\pgfplots@point@canvas@check}%
		{\pgfplots@point@canvas}%
	\ifdim\pgf@x<0pt \pgf@x=-\pgf@x\fi
	\ifdim\pgf@y<0pt \pgf@y=-\pgf@y\fi
	\def\pgfplots@is@the@same@point{1}%
	\ifdim\pgf@x>\pgfkeysvalueof{/pgfplots/plot graphics/squeeze tol}
		\def\pgfplots@is@the@same@point{0}%
	\else
		\ifdim\pgf@y>\pgfkeysvalueof{/pgfplots/plot graphics/squeeze tol}
			\def\pgfplots@is@the@same@point{0}%
		\fi
	\fi
	\if0\pgfplots@is@the@same@point
		%
		\begingroup
		\pgfkeysgetvalue{/pgfplots/plot graphics/src}\pgfplots@loc@TMPa
		\t@pgfplots@tokc=\expandafter{\pgfplots@loc@TMPa}%
		\def\pgfplots@extractcoord##1##2##3{##1,##2,##3}%
		\pgfplots@error{sorry, I can't fix the scaling of 'plot graphics {\the\t@pgfplots@tokc}'.
			The points (\expandafter\pgfplots@extractcoord\pgfplots@plot@handler@graphics@pointmap@A@logical) and (\expandafter\pgfplots@extractcoord\pgfplots@plot@handler@graphics@pointmap@B@logical) are correct, but the point (\expandafter\pgfplots@extractcoord\pgfplots@point@logical) is wrong (its position vector has an error of (\the\pgf@x,\the\pgf@y) which is larger than 'squeeze tol=\pgfkeysvalueof{/pgfplots/plot graphics/squeeze tol}'). This is probably caused by improper relations between the axis' unit vectors because the view is incorrect.^^J
			- Is the 'view' argument correct (matlab: [h,v] = view)? ^^J
			- Does your image have a non-trivial 'plot box ratio' (matlab: ratio = pbaspect)?^^J
			Please refer to the pgfplots manual for details. If you continue now, I'll show the points in the image}%
		\endgroup
		%
		%
		\scope
		\pgfsetstrokecolor{black}%
		\pgfsetfillcolor{red}%
		\pgfpathcircle{\pgfplots@point@canvas@check}{2pt}%
		\pgfusepath{stroke,fill}%
		\pgfsetfillcolor{green}%
		\pgfpathcircle{\pgfplots@point@canvas}{2pt}%
		\pgfusepath{stroke,fill}%
		\draw[->,red] 
			\pgfextra{
				\pgfpathmoveto{\pgfplots@point@canvas@check}%
				\pgfpathlineto{\pgfplots@point@canvas}};
		\endscope
	\fi
	\endgroup
}

\def\pgfplots@plot@handler@graphics@usebb{%
	\pgfpointdiff{\pgfplots@plot@handler@graphics@bb@first}{\pgfplots@plot@handler@graphics@bb@second}%
	\def\pgfplots@plot@handler@graphics@finish@ok{1}%
	\ifdim\pgf@x=0pt
		\def\pgfplots@plot@handler@graphics@finish@ok{0}%
	\else
		\ifdim\pgf@y=0pt
			\def\pgfplots@plot@handler@graphics@finish@ok{0}%
		\fi
	\fi
	\if0\pgfplots@plot@handler@graphics@finish@ok
		\pgfplots@error{Error using 'plot graphics': I got too few coordinates! I expected the lower left and upper right corners!}%
		\xdef\pgfplots@plot@handler@graphics@bb@first{\noexpand\pgfqpoint{0pt}{0pt}}%
		\xdef\pgfplots@plot@handler@graphics@bb@first{\noexpand\pgfqpoint{0pt}{0pt}}%
		
	\fi	
	\begingroup
	% determine the lower left / upper right corners.
	\pgfplots@plot@handler@graphics@bb@first
	\pgf@xa=\pgf@x
	\pgf@ya=\pgf@y
	\pgfplots@plot@handler@graphics@bb@second
	\pgf@xb=\pgf@x
	\pgf@yb=\pgf@y
	%
	% xc,yc = lower left corner
	% x,y = upper right
	\ifdim\pgf@xa<\pgf@xb
		\pgf@xc=\pgf@xa
		\pgf@x=\pgf@xb
	\else
		\pgf@xc=\pgf@xb
		\pgf@x=\pgf@xa
	\fi
	\ifdim\pgf@ya<\pgf@yb
		\pgf@yc=\pgf@ya
		\pgf@y=\pgf@yb
	\else
		\pgf@yc=\pgf@yb
		\pgf@y=\pgf@ya
	\fi
	\advance\pgf@x by-\pgf@xc
	\advance\pgf@y by-\pgf@yc
	\edef\pgfplots@plot@handler@graphics@DRAW@{%
		\noexpand\pgfplots@invoke@pgfkeyscode{/pgfplots/plot graphics/lowlevel draw/.@cmd}{%
			{\the\pgf@x}% width
			{\the\pgf@y}% height
		}%
	}%
	\pgf@x=\pgf@xc
	\pgf@y=\pgf@yc
	\pgftransformshift{}%
	\node[/pgfplots/plot graphics/node] {%
		\pgfplots@plot@handler@graphics@DRAW@
	};%
	\endgroup
}%
% initial value for /pgfplots/plots graphics/lowlevel draw:
\def\pgfplots@plot@handler@graphics@DRAW#1#2{%
	\pgfkeysgetvalue{/pgfplots/plot graphics/includegraphics}{\pgfplots@loc@TMPc}%
	\pgfkeysgetvalue{/pgfplots/plot graphics/src}{\pgfplots@loc@TMPd}%
	\ifx\pgfplots@loc@TMPd\pgfutil@empty
		\pgfplots@error{Error using 'plot graphics': I don't have a graphics file name! Please set the '/pgfplots/plot graphics/src' key to the image file name. Skipping this plot.}%
	\else
		\begingroup
		\t@pgfplots@toka=\expandafter{\pgfplots@loc@TMPc}%
		%
		\def\pgfplots@loc@TMPa{#1}%
		\def\pgfplots@loc@TMPb{#2}%
		%
		\edef\pgfplots@loc@TMPc{%
			\the\t@pgfplots@toka,%
			\ifx\pgfplots@loc@TMPa\pgfutil@empty\else width=#1,\fi
			\ifx\pgfplots@loc@TMPb\pgfutil@empty\else height=#2,\fi
		}%
		\pgfmath@smuggleone\pgfplots@loc@TMPc
		\endgroup
		%
		\def\pgfplots@loc@TMPa{\pgfkeysvalueof{/pgfplots/plot graphics/includegraphics cmd}}%
		\expandafter\pgfplots@loc@TMPa\expandafter[\pgfplots@loc@TMPc]{\pgfplots@loc@TMPd}%
	\fi
}%

\def\pgfplots@plot@handler@graphics@getnaturalsize{%
	\begingroup
	\setbox0=\hbox{%
		\pgfplots@invoke@pgfkeyscode{/pgfplots/plot graphics/lowlevel draw/.@cmd}{{}{}}%
	}%
	\pgf@x=\wd0
	\pgf@y=\ht0
	\ifdim\dp0>0pt
		\advance\pgf@y by\dp0
	\else
		\ifdim\dp0<0pt
			\advance\pgf@y by-\dp0
		\fi
	\fi
	\xdef\pgfplots@glob@TMPb{{\the\pgf@x}{\the\pgf@y}}%
	\endgroup
	\let\pgfmathresult=\pgfplots@glob@TMPb
}%

% legends for plot graphics should not use 'plot graphics' themselfes
% (for obvious reasons).
% This key handles that. Furthermore, it remembers the plot mark for
% the legend -- although no plot mark is allowed for plot graphics as
% such.
\pgfkeysdef{/pgfplots/plot graphics/@prepare legend}{%
	\pgfplots@gettikzinternal@keyval{mark}{tikz@plot@mark}{}%
	%
	\pgfplots@getcurrent@plothandler\pgfplots@basiclevel@plothandler
	\t@pgfplots@tokc=\expandafter{\pgfplots@basiclevel@plothandler}%
	%
	\edef\pgfplots@loc@TMPa{%
		\noexpand\pgfkeys{/pgfplots/every legend image post/.append code={%
				\noexpand\def\noexpand\tikz@plot@handler{\the\t@pgfplots@tokc}%
				\ifx\tikz@plot@mark\pgfutil@empty
				\else
					\noexpand\pgfkeysalso{/tikz/mark=\tikz@plot@mark}%
				\fi
			}%
		}%
	}%
	\pgfplots@loc@TMPa
}



% #1: a normalized coordinate stream.
%
% Output: a normalized coordinate stream in \pgfplotsglobalretval.
\def\pgfplots@apply@zbuffer#1{%
	\ifcase\pgfplotsplothandlermesh@zbuffer@choice\relax
		% none.
		\gdef\pgfplotsglobalretval{#1}%
	\or
		% reverse x seq: only for 'mesh'
		\if\pgfplots@meshmode n%
			\pgfplots@error{Sorry, `/pgfplots/z buffer=reverse x seq' can only be used for mesh/surf plots.}%
			\gdef\pgfplotsglobalretval{#1}%
		\else
			\pgfplotsautocompletemeshkeys
			\if\pgfplots@plot@mesh@ordering0%
				% ordering = rowwise -> scanline is cols!
				\pgfkeysgetvalue{/pgfplots/mesh/cols}\pgfplotsscanlinelength
				\pgfplots@apply@zbuffer@reversescanline{#1}%
			\else
				% ordering = colwise: scanline is rows!
				\pgfkeysgetvalue{/pgfplots/mesh/rows}\pgfplotsscanlinelength
				\pgfplots@apply@zbuffer@reversetransposed{#1}%
			\fi
		\fi
	\or
		% reverse y seq: only for 'mesh'
		\if\pgfplots@meshmode n%
			\pgfplots@error{Sorry, `/pgfplots/z buffer=reverse y seq' can only be used for mesh/surf plots.}%
			\gdef\pgfplotsglobalretval{#1}%
		\else
			\pgfplotsautocompletemeshkeys
			\if\pgfplots@plot@mesh@ordering0%
				% ordering = rowwise -> scanline is cols!
				\pgfkeysgetvalue{/pgfplots/mesh/cols}\pgfplotsscanlinelength
				\pgfplots@apply@zbuffer@reversetransposed{#1}%
			\else
				% ordering = colwise: scanline is rows!
				\pgfkeysgetvalue{/pgfplots/mesh/rows}\pgfplotsscanlinelength
				\pgfplots@apply@zbuffer@reversescanline{#1}%
			\fi
		\fi
	\or
		% reverse xy seq:
		\begingroup
		\def\pgfplots@coord@stream@start{%
			\pgfplotsprependlistXnewempty{reversed}%
		}%
		\def\pgfplots@coord@stream@coord{%
			\expandafter\pgfplotsprependlistXpushfront\expandafter{\pgfplots@coord@stream@foreach@NORMALIZED@curencoded@braced}\to{reversed}%
		}%
		\def\pgfplots@coord@stream@end{%
			\pgfplotsprependlistXlet\pgfplots@loc@TMPa={reversed}%
			\pgfplotsprependlistXnewempty{reversed}% clear it
			\global\let\pgfplotsglobalretval=\pgfplots@loc@TMPa
		}%
		\pgfplots@coord@stream@foreach@NORMALIZED{#1}%
		\endgroup
	\or
		% sort.
		\if\pgfplots@meshmode n%
			\begingroup
			\def\pgfplots@coord@stream@start{%
				\pgfplotsarraynewempty\pgfplots@zbuffer@local
				\pgfplotsarrayresize\pgfplots@zbuffer@local{\numcoords}%
				\c@pgfplots@scanlineindex=0
				\def\pgfplots@zbuffer@local@SETCUR####1{%
					\expandafter\pgfplotsarrayset\c@pgfplots@scanlineindex\of\pgfplots@zbuffer@local\to{####1}%
				}%
			}%
			\def\pgfplots@coord@stream@coord{%
				\expandafter\pgfplots@zbuffer@local@SETCUR\expandafter{\pgfplots@coord@stream@foreach@NORMALIZED@curencoded}%
				\advance\c@pgfplots@scanlineindex by1
			}%
			\def\pgfplots@coord@stream@end{%
				\ifnum\c@pgfplots@scanlineindex=\numcoords
				\else
					\pgfplotsarrayresize\pgfplots@zbuffer@local{\c@pgfplots@scanlineindex}%
				\fi
				\pgfkeyslet{/pgfplots/iflessthan/.@cmd}\pgfplots@apply@zbuffer@SORT@iflessthan
				\pgfkeysdef{/pgfplots/array/unscope pre}{%
					\pgfplotsapplistXnewempty{\pgfp@sortedlist}%
					\pgfplotsarrayforeachungrouped\pgfplots@zbuffer@local\as\curelem{%
						\expandafter\pgfplotsapplistXpushback\expandafter{\expandafter{\curelem}}\to{\pgfp@sortedlist}%
					}%
					\pgfplotsapplistXlet\pgfplots@loc@TMPa={\pgfp@sortedlist}%
					\global\let\pgfplotsglobalretval=\pgfplots@loc@TMPa
				}%
				\pgfkeysdef{/pgfplots/array/unscope post}{}%
				\pgfplotsarraysort\pgfplots@zbuffer@local
			}%
			\pgfplots@coord@stream@foreach@NORMALIZED{#1}%
			\endgroup
		\else
			% meshmode handles sort separately!
			\gdef\pgfplotsglobalretval{#1}%
		\fi
	\or
		% z buffer=auto
		%
		% I can decide for each axis if coordinate reversal is
		% necessary.
		% Idea: check if axis side planes are on foreground or not (a
		% very simple task)! I
		% only need to know whether [xy] coordinates are sorted
		% ascending or descending. This information is already ready.
		%
		\if1\pgfplotsplothandlermesh@matrixinput
			% mesh input=lattice
			\begingroup
			\if+\pgfkeysvalueof{/pgfplots/x coord sorting}%
				\def\pgfplots@minmaxvalue@x{0}%
			\else
				\def\pgfplots@minmaxvalue@x{0}%
			\fi
			\if+\pgfkeysvalueof{/pgfplots/y coord sorting}%
				\def\pgfplots@minmaxvalue@y{0}%
			\else
				\def\pgfplots@minmaxvalue@y{1}%
			\fi
			\pgfplotsifaxissurfaceisforeground{\pgfplots@minmaxvalue@x vv}{%
				\def\pgfplots@reverse@x{1}%
			}{%
				\def\pgfplots@reverse@x{0}%
			}%
			\pgfplotsifaxissurfaceisforeground{v\pgfplots@minmaxvalue@y v}{%
				\def\pgfplots@reverse@y{1}%
			}{%
				\def\pgfplots@reverse@y{0}%
			}%
			\if1\pgfplots@reverse@x
				\if1\pgfplots@reverse@y
					\pgfkeys{/pgfplots/z buffer=reverse xy seq}%
				\else
					\pgfkeys{/pgfplots/z buffer=reverse x seq}%
				\fi
			\else
				\if1\pgfplots@reverse@y
					\pgfkeys{/pgfplots/z buffer=reverse y seq}%
				\else
					\pgfkeys{/pgfplots/z buffer=none}%
				\fi
			\fi
%\message{z buffer=auto mode chose  z buffer= \ifcase\pgfplotsplothandlermesh@zbuffer@choice NONE \or reverse x seq \or reverse y seq \or reverse xy seq \or sort\or default \fi. mesh ordering = \ifcase\pgfplots@plot@mesh@ordering x varies/rowwise\or y varies/colwise\fi}%
		% 'z buffer' is no longer 'auto' now:
			\pgfplots@apply@zbuffer{#1}%
			\endgroup
		\else
			% mesh input=patches
			\ifpgfplots@threedim
				\if\pgfplots@meshmode n%
				\else
					\pgfkeys{/pgfplots/z buffer=sort}%
				\fi
			\else
				\pgfkeys{/pgfplots/z buffer=none}%
			\fi
			\gdef\pgfplotsglobalretval{#1}%
		\fi
	\or
		% z buffer=default.
		\if\pgfplots@meshmode n%
			% mesh mode deactivated!
			\gdef\pgfplotsglobalretval{#1}%
		\else
			% mesh=true
			\pgfkeysalso{/pgfplots/z buffer=auto}%
			\pgfplots@apply@zbuffer{#1}%
		\fi
	\fi
}%

% Defines \pgfplotsglobalretval (globally) to be a partial reversion of the
% (normalized) 2d coordinate sequence '#1'.
%
% In other words, the normalized coordinate sequence '#1' is visited
% linearly and while we go, each scanline is reversed. The result is
% collected into \pgfplotsglobalretval.
%
% This implements the 'z buffer=reverse x seq' feature for
% ordering=y varies.
%
% PRECONDITION:
% 	\pgfplotsscanlinelength contains the scanline length
% POSTCONDITION:
% 	\pgfplotsglobalretval contains the partial reversion.
\def\pgfplots@apply@zbuffer@reversescanline#1{%
	\begingroup
	\def\pgfplots@coord@stream@start{%
		\pgfplotsprependlistXnewempty{reversedscanline}%
		\c@pgfplots@scanlineindex=0
		\pgfplotsapplistXnewempty{\resultlist}%
	}%
	\def\pgfplots@coord@stream@coord{%
		\expandafter\pgfplotsprependlistXpushfront\expandafter{\pgfplots@coord@stream@foreach@NORMALIZED@curencoded@braced}\to{reversedscanline}%
		\advance\c@pgfplots@scanlineindex by1
		\ifnum\c@pgfplots@scanlineindex=\pgfplotsscanlinelength\relax
			\pgfplotsprependlistXlet\pgfplots@loc@TMPa={reversedscanline}%
			\expandafter\pgfplotsapplistXpushback\expandafter{\pgfplots@loc@TMPa}\to\resultlist
			\pgfplotsprependlistXnewempty{reversedscanline}%
			\c@pgfplots@scanlineindex=0
		\fi
	}%
	\def\pgfplots@coord@stream@end{%
		\pgfplotsprependlistXlet\pgfplots@loc@TMPa={reversedscanline}%
		\ifx\pgfplots@loc@TMPa\pgfutil@empty
		\else
			\pgfplots@zbuffer@error
		\fi
		\pgfplotsapplistXlet\pgfplots@loc@TMPa={\resultlist}%
		\global\let\pgfplotsglobalretval=\pgfplots@loc@TMPa
	}%
	\pgfplots@coord@stream@foreach@NORMALIZED{#1}%
%\message{I have performed partial reversion of '#1' and got     '\pgfplotsglobalretval'!}%
	\endgroup
}%

% A very similar method of \pgfplots@apply@zbuffer@reversescanline,
% but this one keeps everything inside of each scanline in the
% original ordering, and reverses the ordering in which whole
% scanlines occur.
\def\pgfplots@apply@zbuffer@reversetransposed#1{%
	\begingroup
	\def\pgfplots@coord@stream@start{%
		\pgfplotsapplistXnewempty{\scanline}%
		\c@pgfplots@scanlineindex=0
		\pgfplotsprependlistXnewempty{resultlist}%
	}%
	\def\pgfplots@coord@stream@coord{%
		\expandafter\pgfplotsapplistXpushback\expandafter{\pgfplots@coord@stream@foreach@NORMALIZED@curencoded@braced}\to{\scanline}%
		\advance\c@pgfplots@scanlineindex by1
		\ifnum\c@pgfplots@scanlineindex=\pgfplotsscanlinelength\relax
			\pgfplotsapplistXlet\pgfplots@loc@TMPa={\scanline}%
			\expandafter\pgfplotsprependlistXpushfront\expandafter{\pgfplots@loc@TMPa}\to{resultlist}
			\pgfplotsapplistXnewempty{\scanline}%
			\c@pgfplots@scanlineindex=0
		\fi
	}%
	\def\pgfplots@coord@stream@end{%
		\pgfplotsapplistXlet\pgfplots@loc@TMPa={\scanline}%
		\ifx\pgfplots@loc@TMPa\pgfutil@empty
		\else
			\pgfplots@zbuffer@error
		\fi
		\pgfplotsprependlistXlet\pgfplots@loc@TMPa={resultlist}%
		\global\let\pgfplotsglobalretval=\pgfplots@loc@TMPa
	}%
	\pgfplots@coord@stream@foreach@NORMALIZED{#1}%
%\message{I have performed partial reversion of '#1' and got     '\pgfplotsglobalretval'!}%
	\endgroup
}%
\def\pgfplots@zbuffer@error{%
	\pgfplots@error{An internal error occured during z buffer reorderings: the rows/cols where not balanced! I have rows= \pgfkeysvalueof{/pgfplots/mesh/rows}, cols=\pgfkeysvalueof{/pgfplots/mesh/cols}. If this happens to be wrong, you might want to provide rows and cols manually.}%
}

% A special '<' operation which returns true if the point coordinate
% '#1' is BEHIND #2 with respect to the current 3D view.
\def\pgfplots@apply@zbuffer@SORT@iflessthan#1#2#3#4\pgfeov{%
	\pgfplotsaxisdeserializedatapointfrom{#1}%
	\pgfplotsmathfloatviewdepthxyz{\pgfplots@current@point@x}{\pgfplots@current@point@y}{\pgfplots@current@point@z}%
	\let\pgfplots@apply@zbuffer@SORT@iflessthan@a=\pgfmathresult
	%
	\pgfplotsaxisdeserializedatapointfrom{#2}%
	\pgfplotsmathfloatviewdepthxyz{\pgfplots@current@point@x}{\pgfplots@current@point@y}{\pgfplots@current@point@z}%
	\let\pgfplots@apply@zbuffer@SORT@iflessthan@b=\pgfmathresult
	%
	\pgfmathfloatlessthan@{\pgfplots@apply@zbuffer@SORT@iflessthan@b}{\pgfplots@apply@zbuffer@SORT@iflessthan@a}%
	\ifpgfmathfloatcomparison
		#3\relax
	\else
		#4\relax
	\fi
}%


% Defines \pgfmathresult to be the view depth of a three component
% vector. The third component will be used if and only if the boolean
% \ifpgfplots@curplot@threedim is true.
% The return value will be assigned in floating point.
%
% The arguments need to be numbers (will be parsed with
% \pgfmathfloatparsenumber).
% @see \pgfplotsmathviewdepthxyz
\def\pgfplotsmathfloatviewdepthxyz#1#2#3{%
	\pgfmathfloatparsenumber{#1}\let\pgfplots@loc@TMPa=\pgfmathresult
	\pgfmathfloatparsenumber{#2}\let\pgfplots@loc@TMPb=\pgfmathresult
	\pgfmathfloatparsenumber{#3}\let\pgfplots@loc@TMPc=\pgfmathresult
	\edef\pgfplots@loc@TMPa{{\pgfplots@loc@TMPa}{\pgfplots@loc@TMPb}{\pgfplots@loc@TMPc}}%
	\expandafter\pgfplotsmathfloatviewdepthxyz@\pgfplots@loc@TMPa
}%

\def\pgfplotsmathfloatviewdepthxyz@#1#2#3{%
	\pgfplots@error{Sorry, you can't use \string\pgfplotsmathfloatviewdepthxyz\space in this context.}%
}%
\def\pgfplotsmathfloatviewdepthxyz@infigure#1#2#3{%
	\pgfmathfloatmultiplyfixed@{#1}{\pgfplots@view@dir@threedim@x}%
	\let\pgfplots@loc@TMPa=\pgfmathresult
	\pgfmathfloatmultiplyfixed@{#2}{\pgfplots@view@dir@threedim@y}%
	\let\pgfplots@loc@TMPb=\pgfmathresult
	\pgfmathfloatadd@{\pgfplots@loc@TMPa}{\pgfplots@loc@TMPb}%
	\let\pgfplots@loc@TMPb=\pgfmathresult
	\ifpgfplots@curplot@threedim
		\pgfmathfloatmultiplyfixed@{#3}{\pgfplots@view@dir@threedim@z}%
		\let\pgfplots@loc@TMPc=\pgfmathresult
		\pgfmathfloatadd@{\pgfplots@loc@TMPb}{\pgfplots@loc@TMPc}%
		\let\pgfplots@loc@TMPb=\pgfmathresult
	\fi
	\let\pgfmathresult=\pgfplots@loc@TMPb
}%

% Similar to \pgfplotsmathfloatviewdepthxyz, but this always relies on
% fixed point arithmetics.
\def\pgfplotsmathviewdepthxyz#1#2#3{\pgfplotsmathviewdepthxyz@{#1}{#2}{#3}}
\def\pgfplotsmathviewdepthxyz@#1#2#3{%
	\pgfplots@error{Sorry, you can't use \string\pgfplotsmathviewdepthxyz\space in this context.}%
}
\def\pgfplotsmathviewdepthxyz@infigure#1#2#3{%
	\pgfmath@basic@multiply@{#1}{\pgfplots@view@dir@threedim@x}%
	\let\pgfplots@loc@TMPa=\pgfmathresult
	\pgfmath@basic@multiply@{#2}{\pgfplots@view@dir@threedim@y}%
	\let\pgfplots@loc@TMPb=\pgfmathresult
	\pgfmath@basic@add@{\pgfplots@loc@TMPa}{\pgfplots@loc@TMPb}%
	\let\pgfplots@loc@TMPb=\pgfmathresult
	\ifpgfplots@curplot@threedim
		\pgfmath@basic@multiply@{#3}{\pgfplots@view@dir@threedim@z}%
		\let\pgfplots@loc@TMPc=\pgfmathresult
		\pgfmath@basic@add@{\pgfplots@loc@TMPb}{\pgfplots@loc@TMPc}%
		\let\pgfplots@loc@TMPb=\pgfmathresult
	\fi
	\let\pgfmathresult=\pgfplots@loc@TMPb
}%


% Evaluate shell commands.
%
% #1 = filename prefix for .sh and .out files (optional,
%      default is \jobname)
% #2 = shell command text
%
% Description:
%
% This command will write the command text to a file called
% #1.sh. Then it calls sh (using the \write18 mechanism) to
% execute the file and redirect the output to a file called
% #1.out.
% In contrast to pgfplotgnuplot the result has to be read
% from #1.out later using \pgfplotxyfile. (This allows
% using the function from within the plot table functions
% as well.)
%
% Example:
%
% \pgfplothandlerlineto
% \pgfshell[\jobname]{cat table.dat}
% \pgfplotxyfile{\jobname.out}

\pgfutil@ifundefined{w@pgf@writea}{%
	\csname newwrite\endcsname\pgf@shellwrite
}{%
	\let\pgf@shellwrite=\w@pgf@writea
}
\newif\ifpgf@resample@shell

\def\pgfshell{\pgfutil@ifnextchar[{\pgf@shell}{\pgf@shell[\jobname]}}%}
\def\pgf@shell[#1]#2{%
  \pgf@resample@shelltrue%
  % Check, whether it is up-to-date
  \openin\pgfutil@inputcheck=#1.sh
  \ifeof\pgfutil@inputcheck%
  \else%
    \read\pgfutil@inputcheck to\pgf@shell@line%
    \edef\pgf@plot@code{#2\space}%
    \ifx\pgf@plot@code\pgf@shell@line%
      \openin\pgfutil@inputcheck=#1.out
      \ifeof\pgfutil@inputcheck%
      \else%
        \pgf@resample@shellfalse
      \fi%
    \fi%
  \fi
  \ifpgf@resample@shell%
    \immediate\openout\pgf@shellwrite=#1.sh
    \immediate\write\pgf@shellwrite{#2}%
    \immediate\closeout\pgf@shellwrite%
    \immediate\write18{sh #1.sh > #1.out}
  \fi%
}
% Used inside of /pgfplots/scatter/classes :
\def\pgfplots@scatter@classes@pre@marker@code{%
	\pgfutil@ifundefined{pgfp@scatter@class@\pgfplotspointmeta}{%
		\let\pgfplots@loc@TMPa=\pgfplotspointmeta
		%
		% ups - no styles available? Maybe something went
		% wrong with the 'scatter src' key. Check whether it
		% was accidentally a numerical style:
		\if1\csname pgfpmeta@\pgfplotspointmetainputhandler @issymbolic\endcsname
		\else
			% ok, be fault tolerant and round to an integer:
			\pgfplotscoordmath{meta}{tofixed}{\pgfplotspointmeta}%
			\begingroup
			\pgfkeys{/pgf/number format/precision=0}%
			\expandafter\pgfmathroundto\expandafter{\pgfmathresult}%
			\pgfmath@smuggleone\pgfmathresult
			\endgroup
			\let\pgfplotspointmeta=\pgfmathresult
		\fi
		% now, check again:
		\pgfutil@ifundefined{pgfp@scatter@class@\pgfplotspointmeta}{%
			% still not possible? Then, try truncating the
			% number to an integer.
			\expandafter\pgfutil@in@\expandafter.\expandafter{\pgfplotspointmeta}%
			\ifpgfutil@in@
				\def\pgfplots@loc@TMPb##1.##2\relax{\def\pgfplotspointmeta{##1}}%
				\expandafter\pgfplots@loc@TMPb\pgfplots@loc@TMPa\relax
			\fi
			% now, check again:
			\pgfutil@ifundefined{pgfp@scatter@class@\pgfplotspointmeta}{%
				\pgfutil@ifundefined{pgfp@scatter@WARNING@\pgfplotspointmeta}{%
					\pgfplots@warning{scatter/classes: can't find class for '\pgfplotspointmeta'!? Please make sure you have specified 'scatter src=explicit symbolic'. Ignoring class '\pgfplotspointmeta' (this message will not come again).}%
					\expandafter\gdef\csname pgfp@scatter@WARNING@\pgfplotspointmeta\endcsname{ALREADY CHECKED}%
				}{}%
				\def\pgfplots@loc@TMPa{}%
			}{%
				\expandafter\let\expandafter\pgfplots@loc@TMPa\csname pgfp@scatter@class@\pgfplotspointmeta\endcsname
			}%
		}{%
			\expandafter\let\expandafter\pgfplots@loc@TMPa\csname pgfp@scatter@class@\pgfplotspointmeta\endcsname
		}%
	}{%
		\expandafter\let\expandafter\pgfplots@loc@TMPa\csname pgfp@scatter@class@\pgfplotspointmeta\endcsname
	}%
	\expandafter\scope\expandafter[\pgfplots@loc@TMPa]%
}%
